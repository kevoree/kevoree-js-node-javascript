require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Class               = require('pseudoclass'),
    kevoree             = require('kevoree-library').org.kevoree,
    Kotlin              = require('kevoree-kotlin'),
    ModelObjectMapper   = require('./ModelObjectMapper');

// Adaptation Primitives
var AddInstance         = require('./adaptations/AddInstance'),
    AddBinding          = require('./adaptations/AddBinding'),
    AddDeployUnit       = require('./adaptations/AddDeployUnit'),
    RemoveBinding       = require('./adaptations/RemoveBinding'),
    RemoveDeployUnit    = require('./adaptations/RemoveDeployUnit'),
    RemoveInstance      = require('./adaptations/RemoveInstance'),
    StartInstance       = require('./adaptations/StartInstance'),
    StopInstance        = require('./adaptations/StopInstance'),
    UpdateInstance      = require('./adaptations/UpdateInstance'),
    UpdateDictionary    = require('./adaptations/UpdateDictionary'),
    HaraKiri            = require('./adaptations/HaraKiri');


// CONSTANTS
var COMMAND_RANK = {
    // highest priority
    StopInstance:     0,
    RemoveBinding:    1,
    RemoveInstance:   2,
    RemoveTypeDef:    3,
    RemoveDeployUnit: 4,
    AddDeployUnit:    5,
    AddTypeDef:       6,
    AddInstance:      7,
    AddBinding:       8,
    UpdateDictionary: 9,
    UpdateInstance:   10,
    StartInstance:    11,
    HaraKiri:         12
    // lowest priority
};

/**
 * AdaptationEngine knows each AdaptationPrimitive command available
 * for JavascriptNode.
 * Plus, it handles model - object mapping
 *
 * @type {AdaptationEngine}
 */
var AdaptationEngine = Class({
    toString: 'AdaptationEngine',

    construct: function (node) {
        this.node = node;
        this.modelObjMapper = new ModelObjectMapper();
        this.modelObjMapper.addEntry(this.node.getPath(), this.node);
        var factory = new kevoree.factory.DefaultKevoreeFactory();
        this.compare = factory.createModelCompare();
        this.alreadyProcessedTraces = {};
        this.targetModel = null;
    },

    /**
     * Process traces to find the right adaptation primitive command
     * Returns a command to execute in order to do the adaptation logic
     * @param diffSeq
     * @param targetModel
     * @returns {Array}
     */
    processTraces: function (diffSeq, targetModel) {
        this.targetModel = targetModel;
        var cmdList = [];
        // reset traces map
        this.alreadyProcessedTraces = {};

        // know if a trace has already been added to cmdList for {path <-> AdaptationPrimitive}
        var traceAlreadyProcessed = function (cmd) {
            return this.alreadyProcessedTraces[cmd.modelElement.path()] && this.alreadyProcessedTraces[cmd.modelElement.path()][cmd.toString()];
        }.bind(this);

        // add a trace to the processed trace map
        var addProcessedTrace = function (cmd) {
            this.alreadyProcessedTraces[cmd.modelElement.path()] = this.alreadyProcessedTraces[cmd.modelElement.path()] || {};
            this.alreadyProcessedTraces[cmd.modelElement.path()][cmd.toString()] = cmd;
        }.bind(this);

        // fill adaptation primitives list
        var traces = diffSeq.traces.iterator();
        var cmds;
        while (traces.hasNext()) {
            var trace = traces.next();
            cmds = this.processTrace(trace, targetModel.findByPath(trace.previousPath || trace.srcPath));
            for (var i=0; i < cmds.length; i++) {
                if (!traceAlreadyProcessed(cmds[i])) {
                    cmdList.push(cmds[i]);
                    addProcessedTrace(cmds[i]);
                }
            }
        }

        // clean primitives:
        //  - don't call UpdateInstance when StopInstance will be executed
        for (var path in this.alreadyProcessedTraces) {
            if (this.alreadyProcessedTraces[path][UpdateInstance.prototype.toString()]) {
                for (var type in this.alreadyProcessedTraces[path]) {
                    if (type === StopInstance.prototype.toString() || type === StartInstance.prototype.toString()) {
                        var index = cmdList.indexOf(this.alreadyProcessedTraces[path][UpdateInstance.prototype.toString()]);
                        if (index > -1) {
                            cmdList.splice(index, 1);
                        }
                    }
                }
            }
        }

        ////return sorted command list (sort by COMMAND_RANK in order to process adaptations properly)
        //cmds = this.sortCommands(cmdList);
        //for (var j=0; j < cmds.length; j++) {
        //    console.log('CMD >>><<< ', cmds[j].toString(), cmds[j].modelElement.path());
        //}
        return this.sortCommands(cmdList);
    },

    /**
     * Creates an array of AdaptationPrimitive according to the trace
     * @param trace
     * @param modelElement
     */
    processTrace: function (trace, modelElement) {
        var cmds = [], currentModel, instance, du, meta;

        switch (trace.refName) {
            case 'groups':
            case 'hosts':
            case 'components':
                switch (trace.traceType.name()) {
                    case 'ADD':
                        if (this.isRelatedToPlatform(modelElement)) {
                            meta = modelElement.typeDefinition.select('deployUnits[name=*]/filters[name=platform,value=javascript]');
                            if (meta.size() > 0) {
                                du = meta.get(0).eContainer();
                                if (!this.modelObjMapper.getObject(du.path())) {
                                    cmds.push(this.createCommand(AddDeployUnit, du));
                                }
                            } else {
                                var err = new Error("no DeployUnit found for '"+modelElement.name+": "+modelElement.typeDefinition.name+"/"+modelElement.typeDefinition.version+"' that matches the 'javascript' platform");
                                err.className = this.toString();
                                throw err;
                            }

                            if (!this.modelObjMapper.getObject(modelElement.path())) {
                                cmds.push(this.createCommand(AddInstance, modelElement));
                            }
                        }
                        break;

                    case 'REMOVE':
                        currentModel = this.node.getKevoreeCore().getCurrentModel(); // old model
                        var instFromCurrModel = currentModel.findByPath(trace.objPath); // instance from current model
                        var instFromTargModel = this.targetModel.findByPath(trace.objPath); // instance in target model
                        if ((instFromTargModel && !this.isRelatedToPlatform(instFromTargModel)) || !instFromTargModel) {
                            // instance is no longer related to platform or present in new model: stop & remove
                            if (this.modelObjMapper.getObject(instFromCurrModel.path())) {
                                if (instFromCurrModel.started) {
                                    cmds.push(this.createCommand(StopInstance, instFromCurrModel));
                                }
                                if (this.modelObjMapper.getObject(trace.objPath)) {
                                    cmds.push(this.createCommand(RemoveInstance, instFromCurrModel));
                                }
                            }
                        }

                        break;
                }
                break;

            case 'deployUnits':
                switch (trace.traceType.name()) {
                    case 'ADD':
                        if (this.isRelatedToPlatform(modelElement)) {
                            cmds.push(this.createCommand(AddDeployUnit, modelElement));
                        }
                        break;

                    case 'REMOVE':
                        currentModel = this.node.getKevoreeCore().getCurrentModel();
                        du = currentModel.findByPath(trace.objPath);
                        if (du) {
                            cmds.push(this.createCommand(RemoveDeployUnit, du));
                        }
                        break;
                }
                break;

            case 'bindings':
                switch (trace.traceType.name()) {
                    case 'ADD':
                        if (this.isRelatedToPlatform(modelElement)) {
                            cmds.push(this.createCommand(AddBinding, modelElement));

                            if (modelElement.hub && this.isRelatedToPlatform(modelElement.hub)) {
                                if (!this.modelObjMapper.getObject(modelElement.hub.path())) {
                                    meta = modelElement.hub.typeDefinition.select('deployUnits[name=*]/filters[name=platform,value=javascript]');
                                    if (meta.size() > 0) {
                                        du = meta.get(0).eContainer();
                                        if (!this.modelObjMapper.getObject(du.path())) {
                                            cmds.push(this.createCommand(AddDeployUnit, du));
                                        }
                                    } else {
                                        var e = new Error("no DeployUnit found for '"+modelElement.hub.name+": "+modelElement.hub.typeDefinition.name+"/"+modelElement.hub.typeDefinition.version+"' that matches the 'javascript' platform");
                                        e.className = this.toString();
                                        throw e;
                                    }

                                    if (modelElement.hub.dictionary) {
                                        cmds = cmds.concat(this.createUpdateDictionaryCommands(modelElement.hub.dictionary));
                                    }

                                    var fragDics = modelElement.hub.fragmentDictionary.iterator();
                                    while (fragDics.hasNext()) {
                                        var fragDic = fragDics.next();
                                        if (fragDic.name === this.node.getName()) {
                                            cmds = cmds.concat(this.createUpdateDictionaryCommands(fragDic));
                                        }
                                    }

                                    cmds.push(this.createCommand(AddInstance, modelElement.hub));
                                    if (modelElement.hub.started) {
                                        cmds.push(this.createCommand(StartInstance, modelElement.hub));
                                    }
                                }
                            }
                        }
                        break;

                    case 'REMOVE':
                        currentModel = this.node.getKevoreeCore().getCurrentModel(); // old model
                        var binding = currentModel.findByPath(trace.objPath); // binding before removal trace
                        if (binding) {
                            var newChan = this.targetModel.findByPath(binding.hub.path());
                            var chanStillUsed = false;
                            if (newChan) {
                                var bindings = newChan.bindings.iterator();
                                while (bindings.hasNext()) {
                                    if (this.isRelatedToPlatform(bindings.next())) {
                                        // there is still a binding between this chan and this platform => cant remove
                                        chanStillUsed = true;
                                        break;
                                    }
                                }
                            }

                            if (!chanStillUsed && this.modelObjMapper.getObject(binding.hub.path())) {
                                if (this.modelObjMapper.getObject(binding.hub.path())) {
                                    cmds.push(this.createCommand(RemoveInstance, binding.hub));
                                }

                                if (binding.hub.started) {
                                    cmds.push(this.createCommand(StopInstance, binding.hub));
                                }
                            }
                        }

                        if (this.isRelatedToPlatform(binding)) {
                            cmds.push(this.createCommand(RemoveBinding, binding));
                        }
                        break;
                }
                break;

            case 'started':
                if (trace.traceType.name() === 'SET' && Kotlin.isType(modelElement, kevoree.Instance)) {
                    if (this.isRelatedToPlatform(modelElement)) {
                        if (Kotlin.isType(modelElement, kevoree.ContainerNode) && modelElement.name === this.node.getName()) {
                            if (trace.content === 'true') {
                                // start this node platform
                                cmds.push(this.createCommand(StartInstance, modelElement));
                            } else {
                                // stop this node platform
                                cmds.push(this.createCommand(HaraKiri, modelElement));
                            }
                        } else {
                            if (trace.content === 'true') {
                                cmds.push(this.createCommand(StartInstance, modelElement));
                                if (!modelElement.host) {
                                    if (modelElement.dictionary) {
                                        var updateDicCmds = this.createUpdateDictionaryCommands(modelElement.dictionary);
                                        if (updateDicCmds.length > 0) {
                                            cmds = cmds.concat(updateDicCmds);
                                            cmds.push(this.createCommand(UpdateInstance, modelElement));
                                        }
                                    }

                                    var elemFragDics = modelElement.fragmentDictionary.iterator();
                                    while (elemFragDics.hasNext()) {
                                        var fDic = elemFragDics.next();
                                        if (fDic.name === this.node.getName()) {
                                            var updateFDicCmds = this.createUpdateDictionaryCommands(fDic);
                                            if (updateFDicCmds.length > 0) {
                                                cmds = cmds.concat(updateFDicCmds);
                                                cmds.push(this.createCommand(UpdateInstance, modelElement));
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (modelElement.host && modelElement.host.name === this.node.getName()) {
                                    // modelElement is an hosted node (so it does not have an instance in this platform)
                                    cmds.push(this.createCommand(StopInstance, modelElement));

                                } else {
                                    instance = this.modelObjMapper.getObject(modelElement.path());
                                    if (instance && instance.isStarted()) {
                                        cmds.push(this.createCommand(StopInstance, modelElement));
                                    }
                                }
                            }
                        }
                    }
                }
                break;

            case 'value':
                if (trace.traceType.name() === 'SET' &&
                    Kotlin.isType(modelElement, kevoree.Value) &&
                    Kotlin.isType(modelElement.eContainer(), kevoree.Dictionary)) {
                    if (this.isRelatedToPlatform(modelElement)) {
                        instance = modelElement.eContainer().eContainer();
                        if (instance.started && !instance.host) {
                            var updateDicAttrs = this.createUpdateDictionaryCommands(modelElement.eContainer());
                            if (updateDicAttrs.length > 0) {
                                cmds = cmds.concat(updateDicAttrs);
                                cmds.push(this.createCommand(UpdateInstance, modelElement.eContainer().eContainer()));
                            }
                        }
                    }
                }
                break;

            case 'typeDefinition':
                //console.log('>>>>> typeDef', trace.traceType.name(), modelElement.path());
                //if (trace.traceType.name() === 'ADD') {
                //
                //}
                break;
        }

        return cmds;
    },

    /**
     * know if an modelElement is related to the current plarform node
     * @param element
     * @returns {boolean}
     */
    isRelatedToPlatform: function (element) {
        if (Kotlin.isType(element, kevoree.ComponentInstance)) {
            // if parent is this node platform: it's ok
            return (element.eContainer().name === this.node.getName());

        } else if (Kotlin.isType(element, kevoree.Channel)) {
            // if this channel has bindings with components hosted in this node platform: it's ok
            var bindings = element.bindings.iterator();
            while (bindings.hasNext()) {
                var binding = bindings.next();
                if (binding.port && binding.port.eContainer()) {
                    if (this.isRelatedToPlatform(binding.port.eContainer())) {
                        return true;
                    }
                }
            }

        } else if (Kotlin.isType(element, kevoree.Group)) {
            var subNodes = element.subNodes.iterator();
            while (subNodes.hasNext()) {
                if (subNodes.next().name === this.node.getName()) {
                    return true;
                }
            }

        } else if (Kotlin.isType(element, kevoree.ContainerNode)) {
            return ((element.name === this.node.getName()) || (element.host && element.host.name === this.node.getName()));

        } else if (Kotlin.isType(element, kevoree.MBinding)) {
            if (element.port && element.port.eContainer()) {
                if (this.isRelatedToPlatform(element.port.eContainer())) {
                    return true;
                }
            }
            if (element.hub) {
                return this.isRelatedToPlatform(element.hub);
            }

        } else if (Kotlin.isType(element, kevoree.Value)) {
            if (Kotlin.isType(element.eContainer(), kevoree.FragmentDictionary)) {
                return (element.eContainer().name === this.node.getName());
            } else {
                return this.isRelatedToPlatform(element.eContainer().eContainer());
            }

        } else if (Kotlin.isType(element, kevoree.Port)) {
            return this.isRelatedToPlatform(element.eContainer());
        }

        return false;
    },

    /**
     *
     * @param Cmd
     * @param element
     * @returns {Object}
     */
    createCommand: function (Cmd, element) {
        return new Cmd(this.node, this.modelObjMapper, this.targetModel, element);
    },

    /**
     *
     * @param kDic
     * @returns {Array}
     */
    createUpdateDictionaryCommands: function (kDic) {
        var cmds = [],
            dictionary = null;

        var entityInstance;
        if (kDic.eContainer().path() === this.node.getPath()) {
            entityInstance = this.node;
        } else {
            entityInstance = this.modelObjMapper.getObject(kDic.eContainer().path());
        }
        if (entityInstance) {
            dictionary = entityInstance.getDictionary();
        }
        var values = kDic.values.iterator();
        while (values.hasNext()) {
            var val = values.next();
            if (dictionary) {
                var oldVal = dictionary.getValue(val.name);
                if (oldVal !== val.value) {
                    cmds.push(this.createCommand(UpdateDictionary, val));
                }
            } else {
                cmds.push(this.createCommand(UpdateDictionary, val));
            }
        }

        return cmds;
    },

    /**
     * Sorts primitives array according to COMMAND_RANK
     * @param list
     * @returns {*}
     */
    sortCommands: function (list) {
        list.sort(function (a, b) {
            if (COMMAND_RANK[a.toString()] > COMMAND_RANK[b.toString()]) return 1;
            else if (COMMAND_RANK[a.toString()] < COMMAND_RANK[b.toString()]) return -1;
            else return 0;
        });

        return list;
    },

    setLogger: function (logger) {
        this.log = logger;
    }
});

module.exports = AdaptationEngine;
},{"./ModelObjectMapper":2,"./adaptations/AddBinding":3,"./adaptations/AddDeployUnit":4,"./adaptations/AddInstance":5,"./adaptations/HaraKiri":6,"./adaptations/RemoveBinding":7,"./adaptations/RemoveDeployUnit":8,"./adaptations/RemoveInstance":9,"./adaptations/StartInstance":10,"./adaptations/StopInstance":11,"./adaptations/UpdateDictionary":12,"./adaptations/UpdateInstance":13,"kevoree-kotlin":122,"kevoree-library":124,"pseudoclass":125}],2:[function(require,module,exports){
var Class   = require('pseudoclass');

var ModelObjectMapper = Class({
    toString: 'ModelObjectMapper',

    construct: function () {
        this.map = {};
    },

    addEntry: function (path, object) {
        this.map[path] = object;
    },

    removeEntry: function (path) {
        if (this.map[path]) {
            delete this.map[path];
        }
    },

    getObject: function (path) {
        return this.map[path];
    },

    hasObject: function (path) {
        return (this.map[path] != undefined && this.map[path] != null);
    },

    getMap: function () {
        return this.map;
    }
});

module.exports = ModelObjectMapper;
},{"pseudoclass":125}],3:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive,
    Port                = require('kevoree-entities').Port;

module.exports = AdaptationPrimitive.extend({
    toString: 'AddBinding',

    execute: function (callback) {
        this._super(callback);

        var bindings, binding;

        var chanInstance = this.mapper.getObject(this.modelElement.hub.path()),
            compInstance = this.mapper.getObject(this.modelElement.port.eContainer().path()),
            portInstance = this.mapper.getObject(this.modelElement.port.path());

        if (chanInstance) {
            if (compInstance) {
                if (!portInstance) {
                    portInstance = new Port(this.modelElement.port.name, this.modelElement.port.path());
                    this.mapper.addEntry(this.modelElement.port.path(), portInstance);
                }
                portInstance.setComponent(compInstance);
                portInstance.setChannel(chanInstance);

                var provided = this.modelElement.port.eContainer().findProvidedByID(this.modelElement.port.name);
                if (provided) {
                    // binding related port is an 'in' port type
                    compInstance.addInternalInputPort(portInstance);
                    chanInstance.addInternalInputPort(portInstance);
                    this.log.debug(this.toString(), 'input '+portInstance.getPath()+' <-> '+chanInstance.getPath());
                } else {
                    // binding related port is an 'out' port type
                    // so we need to get all this channel 'in' ports
                    // and give them to this chan fragment
                    compInstance.addInternalOutputPort(portInstance);
                    this.log.debug(this.toString(), 'output '+portInstance.getPath()+' <-> '+chanInstance.getPath());

                    // retrieve every bindings related to this binding chan
                    bindings = this.modelElement.hub.bindings.iterator();
                    while (bindings.hasNext()) {
                        binding = bindings.next();
                        if (binding != this.modelElement) { // ignore this binding because we are already processing it
                            provided = binding.port.eContainer().findProvidedByID(binding.port.name);
                            if (provided) {
                                portInstance = this.mapper.getObject(provided.path());
                                if (!portInstance) {
                                    portInstance = new Port(provided.name, provided.path());
                                    this.mapper.addEntry(provided.path(), portInstance);
                                }
                                chanInstance.addInternalInputPort(portInstance);
                            }
                        }
                    }
                }

                callback();

            } else {
                if (this.modelElement.port.eContainer().eContainer().path() === this.node.getPath()) {
                    callback(new Error(this.toString()+" error: unable to find component "+this.modelElement.port.eContainer().name+" instance on platform."));
                } else {
                    // the component is not related to the current platform, just add the input for the channel
                    var isProvided = this.modelElement.port.eContainer().findProvidedByID(this.modelElement.port.name);
                    if (isProvided) {
                        // only add provided ones
                        chanInstance.addInternalInputPort(new Port(this.modelElement.port.name, this.modelElement.port.path()));
                        this.log.debug(this.toString(), 'input '+this.modelElement.port.path()+' <-> '+chanInstance.getPath());
                    }
                    callback();
                }
            }
        } else {
            callback(new Error(this.toString()+" error: unable to find channel "+this.modelElement.hub.name+" instance on platform."));
        }
    },

    undo: function (callback) {
        this._super(callback);

        var RemoveBinding = require('./RemoveBinding');
        var cmd = new RemoveBinding(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    }
});
},{"./RemoveBinding":7,"kevoree-entities":58}],4:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;

/**
 * AddDeployUnit Adaptation command
 *
 * @type {AddDeployUnit} extends AdaptationPrimitive
 */
module.exports = AdaptationPrimitive.extend({
    toString: 'AddDeployUnit',

    /**
     *
     * @param callback function: if this function first parameter != null it means that there is an error
     */
    execute: function (callback) {
        this._super(callback);

        if (!this.mapper.hasObject(this.modelElement.path())) {
            var bootstrapper = this.node.getKevoreeCore().getBootstrapper();

            bootstrapper.bootstrap(this.modelElement, false, function (err) {
                if (err) return callback(err);

                // bootstrap success: add deployUnit path & packageName into mapper
                this.log.debug(this.toString(), this.modelElement.path());
                this.mapper.addEntry(this.modelElement.path(), this.modelElement.name);
                return callback();
            }.bind(this));
        } else {
            // this deploy unit is already installed, move on
            return callback();
        }
    },

    undo: function (callback) {
        this._super(callback);

        var RemoveDeployUnit = require('./RemoveDeployUnit');
        var cmd = new RemoveDeployUnit(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    }
});
},{"./RemoveDeployUnit":8,"kevoree-entities":58}],5:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;

/**
 * AddInstance Adaptation command
 *
 * @type {AddInstance} extends AdaptationPrimitive
 */
module.exports = AdaptationPrimitive.extend({
    toString: 'AddInstance',

    /**
     *
     * @param callback function: if this function first parameter != null it means that there is an error
     */
    execute: function (callback) {
        this._super(callback);

        // inception check
        if (this.modelElement && (this.modelElement.name !== this.node.getName())) {
            // platform related check
            // already added check
            if (!this.mapper.hasObject(this.modelElement.path())) {
                var moduleName = this.mapper.getObject(this.modelElement.typeDefinition.select('deployUnits[name=*]/filters[name=platform,value=javascript]').get(0).eContainer().path());
                if ((moduleName !== undefined) && (moduleName !== null)) {
                    try {
                        var InstanceClass = require(moduleName);
                        var instance = new InstanceClass();
                        instance.setKevoreeCore(this.node.getKevoreeCore());
                        instance.setName(this.modelElement.name);
                        instance.setPath(this.modelElement.path());
                        instance.setNodeName(this.node.getName());

                        this.log.debug(this.toString(), instance.getName()+' '+this.modelElement.typeDefinition.path());
                        this.mapper.addEntry(this.modelElement.path(), instance);
                        callback();
                        return;

                    } catch (e) {
                        callback(e);
                        return;
                    }

                } else {
                    // there is no DeployUnit installed for this instance TypeDefinition
                    callback(new Error(this.toString()+ " error: no DeployUnit installed for "+this.modelElement.path()));
                    return;
                }
            }
        }

        callback();
    },

    undo: function (callback) {
        this._super(callback);

        var RemoveInstance = require('./RemoveInstance');
        var cmd = new RemoveInstance(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    }
});
},{"./RemoveInstance":9,"kevoree-entities":58}],6:[function(require,module,exports){
// Created by leiko on 26/01/15 17:30
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;

var HaraKiri = AdaptationPrimitive.extend({
    toString: 'HaraKiri',

    execute: function (callback) {
        this.log.warn(this.toString(), 'Hara-kiri requested. This runtime is going to be shutdown.');
        var kCore = this.node.getKevoreeCore();
        kCore.once('deployed', function deployed() {
            kCore.off('deployed', deployed);
            kCore.stop();
        }.bind(this));
        callback();
    },

    undo: function (callback) {
        callback();
    }
});

module.exports = HaraKiri;
},{"kevoree-entities":58}],7:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;

module.exports = AdaptationPrimitive.extend({
    toString: 'RemoveBinding',

    execute: function (callback) {
        this._super(callback);

        var chanInstance = this.mapper.getObject(this.modelElement.hub.path()),
            compInstance = this.mapper.getObject(this.modelElement.port.eContainer().path()),
            portInstance = this.mapper.getObject(this.modelElement.port.path());

        if (chanInstance && compInstance && portInstance) {
            this.mapper.removeEntry(this.modelElement.port.path());

            var provided = this.modelElement.port.eContainer().findProvidedByID(this.modelElement.port.name);
            if (provided) {
                this.log.debug(this.toString(), 'input '+portInstance.getPath()+' <-> '+chanInstance.getPath());
                compInstance.removeInternalInputPort(portInstance);
                chanInstance.removeInternalInputPort(portInstance);
            } else {
                this.log.debug(this.toString(), 'output '+portInstance.getPath()+' <-> '+chanInstance.getPath());
                compInstance.removeInternalOutputPort(portInstance);
            }

            // retrieve every bindings related to this binding chan
            var bindings = this.modelElement.hub.bindings.iterator();
            while (bindings.hasNext()) {
                var binding = bindings.next();
                if (binding != this.modelElement) { // ignore this binding because we are already processing it
                    provided = binding.port.eContainer().findProvidedByID(binding.port.name);
                    if (provided) {
                        portInstance = this.mapper.getObject(provided.path());
                        if (portInstance) {
                            this.mapper.removeEntry(provided.path());
                            chanInstance.removeInternalInputPort(portInstance);
                        }
                    }
                }
            }
        }

        callback();
    },

    undo: function (callback) {
        this._super(callback);

        var AddBinding = require('./AddBinding');
        var cmd = new AddBinding(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    },

    isInputPortType: function (kPort) {
        var kCompTD = kPort.eContainer().typeDefinition;
        var inputs = kCompTD.provided ? kCompTD.provided.iterator() : null;
        if (inputs) {
            while (inputs.hasNext()) {
                var input = inputs.next();
                if (input.name == kPort.name) return true;
            }
        }

        var outputs = kCompTD.required ? kCompTD.required.iterator() : null;
        if (outputs) {
            while (outputs.hasNext()) {
                var output = outputs.next();
                if (output.name == kPort.name) return false;
            }
        }

        return false;
    }
});
},{"./AddBinding":3,"kevoree-entities":58}],8:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;

/**
 * RemoveDeployUnit Adaptation
 *
 * @type {RemoveDeployUnit} extend AdaptationPrimitive
 */
module.exports = AdaptationPrimitive.extend({
    toString: 'RemoveDeployUnit',

    execute: function (callback) {
        this._super(callback);

        if (this.modelElement) {
            var bootstrapper = this.node.getKevoreeCore().getBootstrapper();
            return bootstrapper.uninstall(this.modelElement, function (err) {
                if (err) {
                    return callback(err);
                }

                this.log.debug(this.toString(), this.modelElement.path());
                this.mapper.removeEntry(this.modelElement.path());
                callback();
            }.bind(this));
        }

        return callback();
    },

    undo: function (callback) {
        this._super(callback);

        var AddDeployUnit = require('./AddDeployUnit');
        var cmd = new AddDeployUnit(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    }
});
},{"./AddDeployUnit":4,"kevoree-entities":58}],9:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive,
    timesUp             = require('times-up');

/**
 * RemoveInstance Adaptation command
 *
 * @type {RemoveInstance} extends AdaptationPrimitive
 */
module.exports = AdaptationPrimitive.extend({
    toString: 'RemoveInstance',

    /**
     *
     * @param callback function: if this function first parameter != null it means that there is an error
     */
    execute: function (callback) {
        this._super(callback);

        if (this.modelElement.host && this.modelElement.host.name === this.node.getName()) {
            // this element is a subNode to this.node
            this.node.removeSubNode(this.modelElement, timesUp(this.node.getName() + '.removeSubNode(...)', 30000, function (err) {
                if (!err) {
                    this.log.debug(this.toString(), this.node.getName()+' removed '+this.modelElement.name);
                    // TODO ? add eventEmitter hook for subNode too ?
                }
                callback(err);
            }.bind(this)));
            return;

        } else {
            var instance = this.mapper.getObject(this.modelElement.path());
            if (instance) {
                this.mapper.removeEntry(this.modelElement.path());
                this.log.debug(this.toString(), instance.getName()+' '+this.modelElement.typeDefinition.path());
                this.node.kCore.emitter.emit('instanceRemoved', instance);
                callback();
                return;
            }
        }

        this.log.warn(this.toString(), 'Nothing performed...shouldnt see that');
        callback();
    },

    undo: function (callback) {
        this._super(callback);

        var AddInstance = require('./AddInstance');
        var cmd = new AddInstance(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    }
});
},{"./AddInstance":5,"kevoree-entities":58,"times-up":126}],10:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;
var timesUp             = require('times-up');

var StartInstance = AdaptationPrimitive.extend({
    toString: 'StartInstance',

    execute: function (callback) {
        this._super(callback);

        if (this.modelElement.host && this.modelElement.host.name === this.node.getName()) {
            // this element is a subNode to this.node
            this.node.startSubNode(this.modelElement, timesUp(this.node.getName() + '.startSubNode(...)', 30000, function (err) {
                if (!err) {
                    this.log.debug(this.toString(), this.node.getName()+' started '+this.modelElement.name);
                    // TODO ? add eventEmitter hook for subNode too ?
                }
                callback(err);
            }.bind(this)));

        } else {
            var instance;
            if (this.modelElement.name === this.node.getName()) {
                instance = this.node;
            } else {
                instance = this.mapper.getObject(this.modelElement.path());
            }
            if (instance != undefined && instance != null) {
                // check dictionary value and give default values if none set
                var dicType = this.modelElement.typeDefinition.dictionaryType;
                if (dicType) {
                    var attrs = dicType.attributes.iterator();
                    while (attrs.hasNext()) {
                        var attr = attrs.next();
                        var val = instance.dictionary.getValue(attr.name);
                        if (typeof(val) === 'undefined') {
                            // there is no value set for this attribute
                            // lets inflate dictionary with default values if any
                            if (attr.optional) {
                                // the attribute is optional, we will only add the value if defaultValue is set
                                if (attr.defaultValue.length > 0) {
                                    instance.dictionary.setEntry(attr.name, attr.defaultValue);
                                }
                            } else {
                                // attribute is not optional, we have to have a value, then set defaultValue
                                instance.dictionary.setEntry(attr.name, attr.defaultValue);
                            }
                        }
                    }
                }

                // check if instance is already started
                if (!instance.isStarted()) {
                    instance.__start__(timesUp(instance.getPath() + ' start(...)', 30000, function (err) {
                        if (!err) {
                            this.log.debug(this.toString(), instance.getPath());
                            this.node.kCore.emitter.emit('instanceStarted', instance);
                        }
                        callback(err);
                    }.bind(this)));
                } else {
                    callback();
                }

            } else {
                callback(new Error(this.toString()+" error: unable to find instance "+this.modelElement.name));
            }
        }
    },

    undo: function (callback) {
        this._super(callback);

        var StopInstance = require('./StopInstance');
        var cmd = new StopInstance(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    }
});

module.exports = StartInstance;
},{"./StopInstance":11,"kevoree-entities":58,"times-up":126}],11:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;
var timesUp = require('times-up');

var StopInstance = AdaptationPrimitive.extend({
    toString: 'StopInstance',

    execute: function (callback) {
        this._super(callback);

        if (this.modelElement.host && this.modelElement.host.name === this.node.getName()) {
            // this element is a subNode to this.node
            this.node.stopSubNode(this.modelElement, timesUp(this.node.getName() + '.stopSubNode(...)', 30000, function (err) {
                if (!err) {
                    this.log.debug(this.toString(), this.node.getName()+' stopped '+this.modelElement.name);
                    // TODO ? add eventEmitter hook for subNode too ?
                }
                callback(err);
            }.bind(this)));
            return;

        } else {
            var instance;
            if (this.modelElement.name === this.node.getName()) {
                instance = this.node;
            } else {
                instance = this.mapper.getObject(this.modelElement.path());
            }
            if (instance && instance.isStarted()) {
                instance.__stop__(timesUp(instance.getPath() + ' stop(...)', 30000, function (err) {
                    if (!err) {
                        this.log.debug(this.toString(), instance.getName());
                        this.node.kCore.emitter.emit('instanceStopped', instance);
                    }
                    callback(err);
                }.bind(this)));
                return;
            }
        }

        this.log.warn(this.toString(), 'Nothing performed...shouldnt see that');
        callback();
    },

    undo: function (callback) {
        this._super(callback);

        var StartInstance = require('./StartInstance');
        var cmd = new StartInstance(this.node, this.mapper, this.adaptModel, this.modelElement);
        cmd.execute(callback);
    }
});

module.exports = StopInstance;
},{"./StartInstance":10,"kevoree-entities":58,"times-up":126}],12:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive;
var kevoree = require('kevoree-library').org.kevoree;
var Kotlin = require('kevoree-kotlin');

module.exports = AdaptationPrimitive.extend({
    toString: 'UpdateDictionary',

    construct: function () {
        this.oldDictionaryMap = null;
        this.instance = null;
    },

    execute: function (callback) {
        this._super(callback);

        var kDictionary = this.modelElement.eContainer();
        var instance;
        if (kDictionary.eContainer().name === this.node.getName()) {
            // instance is the current platform node
            instance = this.node;
        } else {
            instance = this.mapper.getObject(kDictionary.eContainer().path());
        }

        if (instance) {
            var dictionary = instance.getDictionary();

            this.oldDictionaryMap = dictionary.cloneMap();
            this.instance = instance;
            if (Kotlin.isType(kDictionary, kevoree.FragmentDictionary)) {
                if (kDictionary.name === this.node.getName()) {
                    this.log.debug(this.toString(), kDictionary.eContainer().name+'.'+this.modelElement.name+'/'+kDictionary.name+' = '+this.modelElement.value);
                    dictionary.setEntry(this.modelElement.name, this.modelElement.value);
                }
            } else {
                this.log.debug(this.toString(), kDictionary.eContainer().name+'.'+this.modelElement.name+' = '+this.modelElement.value);
                dictionary.setEntry(this.modelElement.name, this.modelElement.value);
            }
            callback();
        } else {
            this.log.warn(this.toString(), 'Did not update any dictionary because '+kDictionary.eContainer().path()+' is not related to this platform obvsiouly');
            callback();
        }
    },

    undo: function (callback) {
        this._super(callback);

        if (this.instance != null && this.oldDictionaryMap != null) {
            this.instance.getDictionary().setMap(this.oldDictionaryMap);
        }

        callback();
    }
});
},{"kevoree-entities":58,"kevoree-kotlin":122,"kevoree-library":124}],13:[function(require,module,exports){
var AdaptationPrimitive = require('kevoree-entities').AdaptationPrimitive,
    timesUp             = require('times-up');

/**
 * Created by leiko on 07/05/14.
 */
module.exports = AdaptationPrimitive.extend({
    toString: 'UpdateInstance',

    execute: function (callback) {
        this._super(callback);

        var instance;
        if (this.modelElement.name === this.node.getName()) {
            instance = this.node;
        } else {
            instance = this.mapper.getObject(this.modelElement.path());
        }

        if (instance) {
            if (instance.isStarted()) {
                instance.__update__(timesUp(instance.getPath() + ' update(...)', 30000, function (err) {
                    if (!err) {
                        this.log.debug(this.toString(), instance.getName());
                    }
                    callback(err);
                }.bind(this)));
            }
        } else {
            callback(new Error(this.toString()+" error: unable to update instance "+this.modelElement.name));
        }
    },

    undo: function (callback) {
        this._super(callback);
        callback();
    }
});
},{"kevoree-entities":58,"times-up":126}],14:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= q.concurrency; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
          return a.priority - b.priority;
        };

        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }

        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };

              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":28}],15:[function(require,module,exports){

},{}],16:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = String(string)

  if (string.length === 0) return 0

  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      return string.length
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return string.length * 2
    case 'hex':
      return string.length >>> 1
    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(string).length
    case 'base64':
      return base64ToBytes(string).length
    default:
      return string.length
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":17,"ieee754":18,"is-array":19}],17:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],18:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],19:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],21:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":22,"events":20,"url":46}],22:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":23,"Base64":24,"inherits":25,"stream":44}],23:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":44,"util":48}],24:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],25:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],26:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],27:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":28}],28:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],29:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],30:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],31:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],32:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":30,"./encode":31}],33:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":34}],34:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":36,"./_stream_writable":38,"_process":28,"core-util-is":39,"inherits":25}],35:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":37,"core-util-is":39,"inherits":25}],36:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"./_stream_duplex":34,"_process":28,"buffer":16,"core-util-is":39,"events":20,"inherits":25,"isarray":26,"stream":44,"string_decoder/":45,"util":15}],37:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":34,"core-util-is":39,"inherits":25}],38:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":34,"_process":28,"buffer":16,"core-util-is":39,"inherits":25,"stream":44}],39:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)
},{"buffer":16}],40:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":35}],41:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":34,"./lib/_stream_passthrough.js":35,"./lib/_stream_readable.js":36,"./lib/_stream_transform.js":37,"./lib/_stream_writable.js":38,"stream":44}],42:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":37}],43:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":38}],44:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":20,"inherits":25,"readable-stream/duplex.js":33,"readable-stream/passthrough.js":40,"readable-stream/readable.js":41,"readable-stream/transform.js":42,"readable-stream/writable.js":43}],45:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":16}],46:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":29,"querystring":32}],47:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],48:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":47,"_process":28,"inherits":25}],49:[function(require,module,exports){
module.exports.Resolver      = require('./lib/Resolver');
module.exports.Bootstrapper  = require('./lib/Bootstrapper');
module.exports.KevoreeLogger = require('./lib/KevoreeLogger');
module.exports.FileSystem    = require('./lib/FileSystem');
},{"./lib/Bootstrapper":50,"./lib/FileSystem":51,"./lib/KevoreeLogger":52,"./lib/Resolver":53}],50:[function(require,module,exports){
var Class = require('pseudoclass');

/**
 * Bootstrapper API
 * @type {Bootstrapper}
 */
var Bootstrapper = Class({
    toString: 'Bootstrapper',

    /**
     *
     * @param {KevoreeLogger} logger
     * @param {Resolver} resolver
     */
    construct: function (logger, resolver) {
        if (logger) {
            this.log = logger;
            if (resolver) {
                this.resolver = resolver;
            } else {
                throw new Error('No resolver given to '+this.toString()+' (you need to give a proper Resolver to your Bootstrapper)');
            }
        } else {
            throw new Error('No logger given to '+this.toString()+' (you need to give a proper KevoreeLogger to your Bootstrapper)');
        }
    },

    /**
     *
     * @param nodeName
     * @param model
     * @param callback
     */
    bootstrapNodeType: function (nodeName, model, callback) {
        callback = callback || function () {};

        var node = model.findNodesByID(nodeName);
        if (node) {
            var meta = node.typeDefinition.select('deployUnits[name=*]/filters[name=platform,value=javascript]');
            if (meta.size() > 0) {
                this.bootstrap(meta.get(0).eContainer(), false, callback);
            } else {
                callback(new Error("No DeployUnit found for '"+nodeName+"' that matches the 'javascript' platform"));
            }
        } else {
            return callback(new Error("Unable to find '"+nodeName+"' in the given model."));
        }
    },

    /**
     *
     * @param deployUnit
     * @param forceInstall [optional] boolean to indicate whether or not we should force re-installation
     * @param callback                function(Error, Clazz, ContainerRoot)
     */
    bootstrap: function (deployUnit, forceInstall, callback) {
        if (!callback) {
            // "forceInstall" parameter is not specified (optional)
            callback = forceInstall;
            forceInstall = false;
        }

        // --- Resolvers callback
        var bootstrapper = this;
        this.resolver.resolve(deployUnit, forceInstall, function (err, EntityClass, model) {
            if (err) {
                bootstrapper.log.error(bootstrapper.toString(), err.stack);
                return callback(new Error("'"+deployUnit.name+"' bootstrap failed!"));
            }

            // install success
            callback(null, EntityClass, model);
        });
    },

    /**
     *
     * @param deployUnit
     * @param callback
     */
    uninstall: function (deployUnit, callback) {
        var bootstrapper = this;
        this.resolver.uninstall(deployUnit, function (err) {
            if (err) {
                bootstrapper.log.error(bootstrapper.toString(), err.stack);
                callback(new Error("'"+deployUnit.name+"' uninstall failed!"));
                return;
            }

            // uninstall success
            callback(null);
        });
    }
});

module.exports = Bootstrapper;
},{"pseudoclass":125}],51:[function(require,module,exports){
var Class = require('pseudoclass');

var FileSystem = Class({
    toString: 'FileSystem',

    getFileSystem: function (size, callback) {
        if (document) {
            getBrowserFileSystem(this, size, callback);
        } else {
            console.error('Kevoree FileSystem API only handles Browser FS for now.');
        }
    }
});

var getBrowserFileSystem = function getBrowserFileSystem(fsapi, size, callback) {
    window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
    navigator.persistentStorage = navigator.persistentStorage || navigator.webkitPersistentStorage;

    if (window.requestFileSystem && navigator.persistentStorage) {

        var successHandler = function successHandler(grantedSize) {
            window.requestFileSystem(window.PERSISTENT, grantedSize, function (fs) {
                callback.call(fsapi, null, fs);
            });
        };

        var errorHandler = function errorHandler(e) {
            callback.call(fsapi, null);
        };

        navigator.persistentStorage.requestQuota(size, successHandler, errorHandler);
    }
};

module.exports = FileSystem;
},{"pseudoclass":125}],52:[function(require,module,exports){
var Class  = require('pseudoclass'),
    chalk  = require('chalk');

var LEVELS = ['all', 'debug', 'info', 'warn', 'error', 'quiet'];

var chalkInfo       = chalk.grey,
    chalkWarn       = chalk.grey.bgYellow,
    chalkWarnMsg    = chalk.yellow,
    chalkError      = chalk.white.bgRed,
    chalkErrorMsg   = chalk.red,
    chalkDebug      = chalk.cyan;

var KevoreeLogger = Class({
    toString: 'KevoreeLogger',

    construct: function (tag) {
        this.tag = tag;
        this.level = 2;
        this.filter = '';
    },

    info: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('info')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.log(getTime()+'  '+chalkInfo('INFO')+'   '+processTag(tag)+'  '+chalkInfo(msg));
            }
        }
    },

    debug: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('debug')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.log(getTime()+'  '+chalkDebug('DEBUG ')+' '+processTag(tag)+'  '+chalkDebug(msg));
            }
        }
    },

    warn: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('warn')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.warn(getTime()+'  '+chalkWarn('WARN')+'   '+processTag(tag)+'  '+chalkWarnMsg(msg));
            }
        }
    },

    error: function (tag, msg) {
        if (this.level <= LEVELS.indexOf('error')) {
            if (typeof(msg) === 'undefined') {
                msg = tag;
                tag = this.tag;
            }

            if (this.filter.length === 0 || (this.filter.length > 0 && tag === this.filter)) {
                console.error(getTime() + '  ' + chalkError('ERROR') + '  ' + processTag(tag) + '  ' + chalkErrorMsg(msg));
            }
        }
    },

    setLevel: function (level) {
        this.level = level;
        console.log(getTime()+'  '+chalkInfo('ALL ')+'   '+processTag(this.toString())+'  '+chalkInfo('Set logLevel= '+LEVELS[this.level]));
    },

    setFilter: function (filter) {
        this.filter = filter;
        console.log(getTime()+'  '+chalkInfo('ALL ')+'   '+processTag(this.toString())+'  '+chalkInfo('Set logFilter= "'+this.filter+'"'));
    }
});

var processTag = function processTag(tag) {
    if (tag.length >= 15) {
        tag = tag.substr(0, 14)+'.';
    } else {
        var spaces = '';
        for (var i=0; i < 15 - tag.length; i++) spaces += ' ';
        tag += spaces;
    }

    return chalk.magenta(tag);
};

var getTime = function getTime() {
    var time = new Date();
    var hours = (time.getHours().toString().length == 1) ? '0'+time.getHours() : time.getHours();
    var mins = (time.getMinutes().toString().length == 1) ? '0'+time.getMinutes() : time.getMinutes();
    var secs = (time.getSeconds().toString().length == 1) ? '0'+time.getSeconds() : time.getSeconds();
    return chalk.grey(hours+':'+mins+':'+secs);
};


KevoreeLogger.ALL   = LEVELS.indexOf('all');
KevoreeLogger.INFO  = LEVELS.indexOf('info');
KevoreeLogger.DEBUG = LEVELS.indexOf('debug');
KevoreeLogger.WARN  = LEVELS.indexOf('warn');
KevoreeLogger.ERROR = LEVELS.indexOf('error');
KevoreeLogger.QUIET = LEVELS.indexOf('quiet');

module.exports = KevoreeLogger;
},{"chalk":54,"pseudoclass":125}],53:[function(require,module,exports){
var Class = require('pseudoclass'),
    KevoreeLogger = require('./KevoreeLogger');

/**
 * Resolver API
 * @type {Resolver}
 */
var Resolver = Class({
    toString: 'Resolver',

    construct: function (modulesPath, logger) {
        this.modulesPath = modulesPath || '';
        this.log = logger || new KevoreeLogger(this.toString());
        this.repositories = [];
    },

    /**
     *
     * @param deployUnit Kevoree DeployUnit
     * @param force [optional] boolean that indicates whether or not we should force re-installation no matter what
     * @param callback function(err, Class, model)
     */
    resolve: function (deployUnit, force, callback) {},

    uninstall: function (deployUnit, force, callback) {},

    addRepository: function (url) {
        if (this.repositories.indexOf(url) === -1) this.repositories.push(url);
    }
});

module.exports = Resolver;
},{"./KevoreeLogger":52,"pseudoclass":125}],54:[function(require,module,exports){
'use strict';
var ansi = require('ansi-styles');
var stripAnsi = require('strip-ansi');
var hasColor = require('has-color');
var defineProps = Object.defineProperties;
var chalk = module.exports;

var styles = (function () {
	var ret = {};

	ansi.grey = ansi.gray;

	Object.keys(ansi).forEach(function (key) {
		ret[key] = {
			get: function () {
				this._styles.push(key);
				return this;
			}
		};
	});

	return ret;
})();

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				var obj = defineProps(function self() {
					var str = [].slice.call(arguments).join(' ');

					if (!chalk.enabled) {
						return str;
					}

					return self._styles.reduce(function (str, name) {
						var code = ansi[name];
						return str ? code.open + str + code.close : '';
					}, str);
				}, styles);

				obj._styles = [];

				return obj[name];
			}
		}
	});

	return ret;
}

defineProps(chalk, init());

chalk.styles = ansi;
chalk.stripColor = stripAnsi;
chalk.supportsColor = hasColor;

// detect mode if not set manually
if (chalk.enabled === undefined) {
	chalk.enabled = chalk.supportsColor;
}

},{"ansi-styles":55,"has-color":56,"strip-ansi":57}],55:[function(require,module,exports){
'use strict';
var styles = module.exports;

var codes = {
	reset: [0, 0],

	bold: [1, 22],
	italic: [3, 23],
	underline: [4, 24],
	inverse: [7, 27],
	strikethrough: [9, 29],

	black: [30, 39],
	red: [31, 39],
	green: [32, 39],
	yellow: [33, 39],
	blue: [34, 39],
	magenta: [35, 39],
	cyan: [36, 39],
	white: [37, 39],
	gray: [90, 39],

	bgBlack: [40, 49],
	bgRed: [41, 49],
	bgGreen: [42, 49],
	bgYellow: [43, 49],
	bgBlue: [44, 49],
	bgMagenta: [45, 49],
	bgCyan: [46, 49],
	bgWhite: [47, 49]
};

Object.keys(codes).forEach(function (key) {
	var val = codes[key];
	var style = styles[key] = {};
	style.open = '\x1b[' + val[0] + 'm';
	style.close = '\x1b[' + val[1] + 'm';
});

},{}],56:[function(require,module,exports){
(function (process){
'use strict';
module.exports = (function () {
	if (process.argv.indexOf('--no-color') !== -1) {
		return false;
	}

	if (process.argv.indexOf('--color') !== -1) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

}).call(this,require('_process'))
},{"_process":28}],57:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return typeof str === 'string' ? str.replace(/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]/g, '') : str;
};

},{}],58:[function(require,module,exports){
exports.KevoreeEntity       = require('./lib/KevoreeEntity');
exports.AbstractGroup       = require('./lib/AbstractGroup');
exports.AbstractChannel     = require('./lib/AbstractChannel');
exports.AbstractNode        = require('./lib/AbstractNode');
exports.AdaptationPrimitive = require('./lib/AdaptationPrimitive');
exports.AbstractComponent   = require('./lib/AbstractComponent');
exports.Port                = require('./lib/Port');
exports.DataType            = require('./lib/DataType');
},{"./lib/AbstractChannel":59,"./lib/AbstractComponent":60,"./lib/AbstractGroup":61,"./lib/AbstractNode":62,"./lib/AdaptationPrimitive":63,"./lib/DataType":64,"./lib/KevoreeEntity":66,"./lib/Port":68}],59:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity');

/**
 * AbstractChannel entity
 *
 * @class
 */
var AbstractChannel = KevoreeEntity.extend({
    toString: 'AbstractChannel',

    /**
     * @constructs
     */
    construct: function () {
        this.inputs = {};
    },

    /**
     * @param {String} outputPath
     * @param {String} msg
     * @param {Function} callback
     */
    internalSend: function (outputPath, msg, callback) {
        var paths = [];
        for (var inputPath in this.inputs) {
            if (this.inputs.hasOwnProperty(inputPath)) {
                // do not send message to stopped component
                var model = this.getKevoreeCore().getCurrentModel();
                if (model) {
                    var port = model.findByPath(inputPath);
                    if (port) {
                        var comp = port.eContainer();
                        if (comp && comp.started) {
                            paths.push(inputPath);
                        }
                    }
                }
            }
        }

        if (this.started) {
            this.onSend(outputPath, paths, msg, callback);
        }
    },

    /**
     *
     * @param {String} fromPortPath
     * @param {Array} destPortPaths Array
     * @param {String} msg
     * @param {Function} callback
     *
     * @abstract
     */
    onSend: function (fromPortPath, destPortPaths, msg, callback) {},

    /**
     * Dispatch messages to all bound ports
     * @param msg
     * @param {Function} [callback]
     */
    localDispatch: function (msg, callback) {
        // javascript trick to convert msg to an array if it isn't already one
        msg = [].concat(msg);

        // if no callback given, then prevent exception to be thrown
        callback = callback || function () {};

        for (var path in this.inputs) {
            if (this.inputs.hasOwnProperty(path)) {
                var port = this.inputs[path];
                var comp = port.getComponent();
                if (comp !== null && port.getInputPortMethodName() !== null && typeof comp[port.getInputPortMethodName()] === 'function') {
                    if (comp.getModelEntity().started) {
                        // call component's input port function with 'msg' parameter
                        try {
                            var res = comp[port.getInputPortMethodName()].apply(comp, msg);
                            callback(null, res);

                        } catch (err) {
                            var error = new Error('Exception thrown when processing '+comp.getName()+'.'+port.getInputPortMethodName()+'(...) @'+this.getNodeName());
                            error.message += ':\n\t' + err.message;
                            callback(error);
                            this.log.error(this.toString(), error.message);
                        }
                    } else {
                        var errMsg = 'Component '+comp.getName()+'@'+this.getNodeName()+' is stopped. Drop message.';
                        callback(new Error(errMsg));
                        this.log.debug(this.toString(), errMsg);
                    }
                }
            }
        }
    },

    /**
     * Returns this channel output port paths
     * @returns {Array}
     */
    getOutputs: function () {
        var outputs = [];

        var chan = this.getModelEntity();
        if (chan) {
            chan.bindings.array.forEach(function (binding) {
                if (binding.port && binding.port.getRefInParent() === 'required') {
                    if (binding.port.eContainer().eContainer().name === this.getNodeName()) {
                        if (outputs.indexOf(binding.port.path()) === -1) {
                            outputs.push(binding.port.path());
                        }
                    }
                }
            }.bind(this));
        }

        return outputs;
    },

    /**
     * Returns this channel input port paths
     * @returns {Array}
     */
    getInputs: function () {
        var inputs = [];

        var chan = this.getModelEntity();
        if (chan) {
            chan.bindings.array.forEach(function (binding) {
                if (binding.port && binding.port.getRefInParent() === 'provided') {
                    if (binding.port.eContainer().eContainer().name === this.getNodeName()) {
                        if (inputs.indexOf(binding.port.path()) === -1) {
                            inputs.push(binding.port.path());
                        }
                    }
                }
            }.bind(this));
        }

        return inputs;
    },

    /**
     *
     * @param port
     */
    addInternalInputPort: function (port) {
        this.inputs[port.getPath()] = port;
    },

    /**
     *
     * @param port
     */
    removeInternalInputPort: function (port) {
        delete this.inputs[port.getPath()];
    }
});

module.exports = AbstractChannel;
},{"./KevoreeEntity":66}],60:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity'),
    Port          = require('./Port'),
    KevoreeUI     = require('./KevoreeUI');

/**
 * AbstractComponent entity
 *
 * @class
 */
var AbstractComponent = KevoreeEntity.extend({
    toString: 'AbstractComponent',

    /**
     * @constructs
     */
    construct: function () {
        this.inputs = {};
        this.ui = new KevoreeUI(this);
    },

    __start__: function (done) {
        this.ui.name = this.name;
        this._super(done);
    },

    __stop__: function (done) {
        if (this.ui.isReady()) {
            // there is an UI running for this comp
            // remove it
            this.ui.destroy();
        }
        this._super(done);
    },

    addInternalInputPort: function (port) {
        this.inputs[port.getPath()] = port;
        if (typeof(this[AbstractComponent.IN_PORT+port.getName()]) === 'undefined') {
            throw new Error("Unable to find provided port '"+AbstractComponent.IN_PORT+port.getName()+"' (Function defined in class?)");
        } else port.setInputPortMethodName(AbstractComponent.IN_PORT+port.getName());
    },

    addInternalOutputPort: function (port) {
        this[AbstractComponent.OUT_PORT+port.getName()] = function (msg, callback) {
            port.processSend(msg, callback);
        };
    },

    removeInternalInputPort: function (port) {
        delete this.inputs[port.getPath()];
    },

    removeInternalOutputPort: function (port) {
        this[AbstractComponent.OUT_PORT+port.getName()] = function () {}; // reset function binding to an empty one
    },

    /**
     *
     * @param content
     * @param callback function(err) if 'err' is defined then something went wrong. Using 'this' in this callback refers
     * to the current component instance
     */
    setUIContent: function (content, callback) {
        callback = callback.bind(this) || function () {};
        var self = this;

        if (this.ui.isReady()) {
            this.ui.setContent(content);
            return callback(null, this.ui.getRoot());

        } else {
            this.ui.initialize(this, this.kCore.getUICommand(), function (err) {
                if (err) return callback(err);

                self.ui.setContent(content);
                return callback(null, self.ui.getRoot());
            });
        }
    },

    getUIRoot: function () {
        return this.ui.getRoot();
    }
});

AbstractComponent.IN_PORT = 'in_';
AbstractComponent.OUT_PORT = 'out_';

module.exports = AbstractComponent;
},{"./KevoreeEntity":66,"./KevoreeUI":67,"./Port":68}],61:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity');

/**
 * AbstractGroup entity
 *
 * @class
 */
var AbstractGroup = KevoreeEntity.extend({
    toString: 'AbstractGroup',

    /**
     *
     * @param model
     */
    updateModel: function (model) {
        this.kCore.deploy(model);
    }
});

module.exports = AbstractGroup;
},{"./KevoreeEntity":66}],62:[function(require,module,exports){
var KevoreeEntity = require('./KevoreeEntity');

/**
 * AbstractNode entity
 *
 * @class
 */
var AbstractNode = KevoreeEntity.extend({
    toString: 'AbstractNode',

    /**
     * Compute a list of traces and return an ordered list of AdaptationPrimitive to execute in order to proceed
     * to the adaptation of the platform
     * @param {Object} diffSeq      Kotlin.List of diff traces generated by comparing current KevoreeCore model and given model
     * @param {Object} targetModel  Kevoree ContainerModel model object
     *                              that was used by KevoreeCore to generate the diffSeq traces against currentModel
     * @returns {Array}
     */
    processTraces: function (diffSeq, targetModel) {
        return [];
    },

    /**
     * Called when the host node has to start an hosted subNode
     * @param node the hosted subNode
     * @param done
     */
    startSubNode: function (node, done) {
        done();
    },

    /**
     * Called when the host node has to stop an hosted subNode
     * @param node the hosted subNode
     * @param done
     */
    stopSubNode: function (node, done) {
        done();
    },

    /**
     * Called when the host node has to remove an hosted subNode instance
     * @param node the hosted subNode
     * @param done
     */
    removeSubNode: function (node, done) {
        done();
    }
});

module.exports = AbstractNode;
},{"./KevoreeEntity":66}],63:[function(require,module,exports){
var Class   = require('pseudoclass');

/**
 * Abstract AdaptationPrimitive command
 *
 * @class
 */
var AdaptationPrimitive = Class({
    toString: 'AdaptationPrimitive',

    /**
     * Construct an AdaptationPrimitive object
     *
     * @param node AbstractNode platform
     * @param mapper ModelObjectMapper
     * @param model model to deploy (that triggers adaptations)
     * @param modelElement model element linked with this primitive
     *
     * @constructs
     */
    construct: function (node, mapper, model, modelElement) {
        this.node = node;
        this.mapper = mapper;
        this.adaptModel = model;
        this.modelElement = modelElement;
        this.log = this.node.getKevoreeCore().getLogger();
    },

    /**
     * Executes adaptation primitive logics
     * @param callback Function(err, [args]) if 'err' is defined => something went wrong
     */
    execute: function (callback) {
        if (typeof (callback) !== 'function') {
            throw new Error("Execute method need a callback function as last parameter");
        }
    },

    /**
     * Undo the process done by execute()
     */
    undo: function (callback) {
        if (typeof (callback) !== 'function') {
            throw new Error("Undo method need a callback function as last parameter");
        }
    }
});

module.exports = AdaptationPrimitive;
},{"pseudoclass":125}],64:[function(require,module,exports){
/**
 * DataType
 * Enum-like
 * @object
 */
var DataType = {
    STRING: 'string',
    BOOLEAN: 'boolean',
    INT: 'int',
    LONG: 'long',
    FLOAT: 'float',
    DOUBLE: 'double',
    BYTE: 'byte',
    SHORT: 'short',
    CHAR: 'char'
};

module.exports = DataType;
},{}],65:[function(require,module,exports){
var Class           = require('pseudoclass'),
    kevoree         = require('kevoree-library').org.kevoree,
    EventEmitter    = require('events').EventEmitter;

var factory = new kevoree.factory.DefaultKevoreeFactory();

/**
 * Dictionary class use to handle KevoreeEntities dictionary attributes
 * <br/>
 * Each KevoreeEntity can create a dictionary attribute by adding a new <strong>dic_field</strong> to their class:
 * <br/>
 * <pre>
 * dic_myAttr: {
 *   optional: true,
 *   defaultValue: 'foo',
 *   fragmentDependant: false
 * }
 * </pre>
 * Dictionary attribute API follows those guidelines:
 * <ul>
 *   <li>"defaultValue" attribute is <b>optional</b>, type is <b>string|boolean</b></li>
 *   <li>"optional" attribute is <b>optional</b>, type is <b>boolean</b> (default: true)</li>
 *   <li>"fragmentDependant" attribute is <b>optional</b>, type is <b>boolean</b> (default: false)</li>
 *   <li>"datatype" attribute is <b>optional</b>, type is <b>string|org.kevoree.Datatype</b></li>
 * </ul>
 *
 * Once your entity is started, you will be able to retrieve your attribute value by calling one of those methods:
 * <ul>
 *     <li>this.dictionary.getValue('myAttr')</li>
 *     <li>this.dictionary.getString('myAttr')</li>
 *     <li>this.dictionary.getNumber('myAttr')</li>
 *     <li>this.dictionary.getBoolean('myAttr')</li>
 * </ul>
 *
 * @class
 */
var Dictionary = Class({
    toString: 'Dictionary',

    /**
     * @param entity
     *
     * @constructs
     */
    construct: function (entity) {
        this.entity = entity;
        this.emitter = new EventEmitter();
        this.map = {};
    },

    /**
     * Adds a listener on dictionary changes or on a particular attribute changes
     * dictionary.on('myAttr', function (newVal, oldVal) { ... });
     *
     * @param attrName name of the attribute you want to add a listener on
     * @param callback function (attrNewValue, attrOldValue)
     */
    on: function (attrName, callback) {
        this.emitter.addListener(attrName, callback.bind(this.entity));
    },

    /**
     * Removes a listener
     * @param event
     * @param callback
     */
    off: function (event, callback) {
        this.emitter.removeListener(event, callback);
    },

    /**
     * Retrieve a value mapped by the key "name"
     * @param {String} name the key
     * @returns {*}
     */
    getValue: function (name) {
        return this.map[name];
    },

    /**
     * Returns a boolean for the given dictionary attribute name.
     * If no value is found and no defaultVal is given, it will return "false"
     * If a defaultVal is given, and no value is found in dictionary, then defaultVal is returned
     * @param name
     * @param [defaultVal] a default boolean to return if no value is found in the dictionary using the given name
     * @returns {Boolean}
     */
    getBoolean: function (name, defaultVal) {
        var val = this.map[name];
        if (val === 'true' || val === 'false') {
            return val === 'true';
        }

        if (typeof (defaultVal) === 'undefined') {
            defaultVal = false;
        }

        return defaultVal;
    },

    /**
     * Returns a string for the given dictionary attribute name.
     * If no value is found and no defaultVal is given, it will return "null"
     * (nb: it will also return "null" if the given defaultVal is not a string)
     * If a defaultVal is given, and no value is found in dictionary, then defaultVal is returned
     * @param name
     * @param [defaultVal] a default string to return if no value is found in the dictionary using the given name
     * @returns {String}
     */
    getString: function (name, defaultVal) {
        var val = this.map[name];

        if (typeof (val) === 'string') {
            return val;
        }

        if (typeof (defaultVal) !== 'string') {
            defaultVal = null;
        }

        return defaultVal;
    },

    /**
     * Returns a number for the given dictionary attribute name.
     * If no value is found and no defaultVal is given, it will return "null"
     * (nb: it will also return "null" if the given defaultVal is not a number)
     * If a defaultVal is given, and no value is found in dictionary, then defaultVal is returned
     * @param name
     * @param [defaultVal] a default number to return if no value is found in the dictionary using the given name
     * @returns {Number}
     */
    getNumber: function (name, defaultVal) {
        var val = this.map[name];

        if (!isNaN(Number(val))) {
            return val;
        }

        if (typeof (defaultVal) !== 'number') {
            defaultVal = null;
        }

        return defaultVal;
    },

    /**
     *
     * @param name
     * @param value
     */
    setValue: function (name, value) {
        var entity = this.entity.getModelEntity();
        if (!entity.dictionary) {
            entity.dictionary = factory.createDictionary();
        }
        value = entity.dictionary.findValuesByID(name);
        if (!value) {
            value = factory.createDictionaryValue();
            value.name = name;
            entity.dictionary.addValues(value);
        }
        value.value = value;
        this.setEntry(name, value);
    },

    /**
     * Called by the platform to update the state of the dictionary
     * Triggers a call to dic_<name>.update() and a call to on(<name>, function)
     * @param name attribute name
     * @param value new attribute value
     */
    setEntry: function (name, value) {
        var oldValue = this.map[name];
        this.map[name] = value;
        // emit update event with the name, oldValue and newValue
        if (this.entity.isStarted()) {
            if (this.entity['dic_'+name].update && (typeof this.entity['dic_'+name].update === 'function')) {
                this.entity['dic_'+name].update.bind(this.entity)(value, oldValue);
            }
            this.emitter.emit(name, value, oldValue);
        }
    },

    /**
     *
     * @param map
     */
    setMap: function (map) {
        var name;
        if (Object.keys(this.map).length > 0) {
            // current map is not empty
            for (var newName in map) {
                var alreadyAdded = false;

                for (name in this.map) {
                    if (newName == name) {
                        // oldMap and newMap both have this attribute : update needed ?
                        var oldValue = this.map[name];
                        if (oldValue != map[name]) {
                            // map[name] value is different from current value => update
                            this.map[name] = map[name];
                            this.emitter.emit(name, this.map[name], oldValue);
                        }
                        alreadyAdded = true;
                    }
                }

                if (!alreadyAdded) {
                    // newMap has a new attribute to add to currentMap : ADD event
                    this.map[newName] = map[newName];
                }
            }

        } else {
            // dictionary was empty : set it from scratch
            this.map = map;
        }
    },

    /**
     *
     * @returns {{}|*}
     */
    getMap: function () {
        return this.map;
    },

    /**
     * Returns this dictionary current cloned map
     * @returns {{}}
     */
    cloneMap: function () {
        var clonedMap = {};
        for (var name in this.map) {
            clonedMap[name] = this.map[name];
        }
        return clonedMap;
    }
});

module.exports = Dictionary;
},{"events":20,"kevoree-library":124,"pseudoclass":125}],66:[function(require,module,exports){
var Class       = require('pseudoclass'),
    Dictionary  = require('./Dictionary'),
    KevScript   = require('kevoree-kevscript');

/**
 * Abstract class: KevoreeEntity
 * <br/>
 * You are not supposed to instantiate this class manually. It makes no sense
 * <br/>
 * You should create your own Kevoree entity that extend one of the defined abstraction type:
 * <ul>
 *     <li>AbstractNode</li>
 *     <li>AbstractGroup</li>
 *     <li>AbstractChannel</li>
 *     <li>AbstractComponent</li>
 * </ul>
 * All this sub-classes extend KevoreeEntity in order to have the same basic prototype
 *
 * @class
 */
var KevoreeEntity = Class({
    toString: 'KevoreeEntity',

    /**
     * @constructs
     */
    construct: function () {
        this.kCore = null;
        this.dictionary = new Dictionary(this);
        this.name = null;
        this.path = null;
        this.nodeName = null;
        this.started = false;
        this.queue = [];
    },

    /**
     * Called when an entity has to start
     * @param done
     */
    start: function (done) {
        done();
    },

    /**
     * Called when an entity has to stop
     * @param done
     */
    stop: function (done) {
        done();
    },

    /**
     * Called when a attribute has been changed (this method is called after all attribute-specific update() method)
     * @param done
     */
    update: function (done) {
        done();
    },

    __start__: function (done) {
        this.log = this.kCore.getLogger();
        this.started = true;
        this.start(done);
    },

    __stop__: function (done) {
        this.started = false;
        this.stop(done);
    },

    __update__: function (done) {
        this.update(done);
    },

    setKevoreeCore: function (kCore) {
        this.kCore = kCore;
    },

    /**
     *
     * @returns {Object}
     */
    getKevoreeCore: function () {
        return this.kCore;
    },

    getDictionary: function () {
        return this.dictionary;
    },

    getName: function () {
        return this.name;
    },

    getNodeName: function () {
        return this.nodeName;
    },

    setName: function (name) {
        this.name = name;
    },

    setPath: function (path) {
        this.path = path;
    },

    getPath: function () {
        return this.path;
    },

    setNodeName: function (name) {
        this.nodeName = name;
    },

    /**
     * Tries to retrieve this Kevoree entity from deployModel first.
     * If deployModel is null (meaning that we are in a deployed-state and not in a deploying-state)
     * it tries to retrieve this Kevoree entity from currentModel.
     * @returns {*}
     */
    getModelEntity: function () {
        var model = this.kCore.getDeployModel();
        if (!model) {
            model = this.kCore.getCurrentModel();
        }
        return model.findByPath(this.path);
    },

    getNetworkInfos: function (nodeName) {
        var model = this.kCore.getDeployModel();
        if (!model) {
            this.kCore.getCurrentModel();
        }
        var node = model.findNodesByID(nodeName);
        if (node) {
            return node.networkInformation.iterator();
        } else {
            return null;
        }
    },

    isStarted: function () {
        return this.started;
    },

    /**
     * Executes script with current model context. If callback parameter is set,
     * it means something went wrong and the parameter is the error object.
     * NB: scripts submitted while in "deploying" state are queued and executed after.
     * @param script KevScript string
     * @param [callback] function (err)
     */
    submitScript: function (script, callback) {
        callback = callback || function () {};

        if (this.kCore.getDeployModel() === null) {
            // not in "deploying state"
            var kevs = new KevScript({
                resolvers: { npm: this.kCore.getBootstrapper().resolver } // refactor according to #26
            });
            kevs.parse(script, this.kCore.getCurrentModel(), function (err, model) {
                if (err) {
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    callback(e);
                    return;
                }

                var deployHandler, errHandler, adaptHandler;
                deployHandler = function () {
                    this.kCore.off('error', errHandler);
                    this.kCore.off('adaptationError', adaptHandler);
                    callback();
                }.bind(this);
                errHandler = function (err) {
                    this.kCore.off('deployed', deployHandler);
                    this.kCore.off('adaptationError', adaptHandler);
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    callback(e);
                }.bind(this);
                adaptHandler = function (err) {
                    this.kCore.off('error', errHandler);
                    this.kCore.off('deployed', deployHandler);
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    callback(e);
                }.bind(this);

                this.kCore.once('deployed', deployHandler);
                this.kCore.once('error', errHandler);
                this.kCore.once('adaptationError', adaptHandler);

                this.kCore.deploy(model);
            }.bind(this));
        } else {
            // in "deploying state" => need to queue request to process it afterwards
            this.queue.push({script: script, callback: callback});
            this.log.debug(this.toString(), 'Script added to queue..');
            //callback(new Error('KevScript submission failed (unable to submit script when a model is currently deployed)'));
        }
    },

    /**
     * Called when a model has been successfully deployed
     */
    onModelDeployed: function () {
        if (this.queue.length > 0) {
            // create a KevScript engine
            var kevs = new KevScript();

            // retrieve first queued script
            var item = this.queue[0];
            // remove first queued script from the queue
            this.queue.splice(0, 1);
            // execute first queued script
            kevs.parse(item.script, this.kCore.getCurrentModel(), function (err, model) {
                if (err) {
                    // queued script submission failed
                    var e = new Error('KevScript submission failed ('+err.message+')');
                    item.callback(e);

                } else {
                    // queued script submission succeed
                    var deployHandler, errHandler, adaptHandler;
                    deployHandler = function () {
                        this.kCore.off('error', errHandler);
                        this.kCore.off('adaptationError', adaptHandler);
                        item.callback();
                    }.bind(this);
                    errHandler = function (err) {
                        this.kCore.off('deployed', deployHandler);
                        this.kCore.off('adaptationError', adaptHandler);
                        var e = new Error('KevScript submission failed ('+err.message+')');
                        item.callback(e);
                    }.bind(this);
                    adaptHandler = function (err) {
                        this.kCore.off('error', errHandler);
                        this.kCore.off('deployed', deployHandler);
                        var e = new Error('KevScript submission failed ('+err.message+')');
                        item.callback(e);
                    }.bind(this);

                    this.kCore.once('deployed', deployHandler);
                    this.kCore.once('error', errHandler);
                    this.kCore.once('adaptationError', adaptHandler);

                    this.kCore.deploy(model);
                }
            }.bind(this));
        }
    }
});

KevoreeEntity.DIC = 'dic_';
module.exports = KevoreeEntity;
},{"./Dictionary":65,"kevoree-kevscript":70,"pseudoclass":125}],67:[function(require,module,exports){
var Class         = require('pseudoclass'),
    KevoreeLogger = require('kevoree-commons').KevoreeLogger,
    EventEmitter  = require('events').EventEmitter;

/**
 * KevoreeUI
 *
 * @class
 */
var KevoreeUI = Class({
    toString: 'KevoreeUI',

    /**
     * @param comp
     * @constructs
     */
    construct: function (comp) {
        this.comp = comp;
        this.root = null;
        this.log = new KevoreeLogger(this.toString());
        this.name = null;
        this.destroyCmd = null;
        this.emitter = new EventEmitter();
    },

    isReady: function () {
        return (this.root != null);
    },

    setRoot: function (root) {
        this.root = root;
    },

    getRoot: function () {
        return this.root;
    },

    initialize: function (comp, initCmd, callback) {
        var self = this;

        if (typeof(initCmd) !== 'function' || !initCmd) {
            return callback(new Error('KevoreeUI init command unset (or not a function) in KevoreeCore.'));
        }

        initCmd(this, function (err) {
            if (err) {
                self.log.error(err.message);
                self.root = null;
                return callback(err);
            }

            return callback();
        });
    },

    setContent: function (content) {
        this.root.innerHTML = content;
        this.emitter.emit('contentChanged', content);
    },

    destroy: function () {
        if (this.destroyCmd) this.destroyCmd();
        this.root = null;
    },

    setDestroyCmd: function (cmd) {
        this.destroyCmd = cmd;
    },

    getName: function () {
        return this.name;
    },

    setName: function (name) {
        this.name = name;
        this.emitter.emit('nameChanged', name);
    },

    on: function (event, callback) {
        this.emitter.addListener(event, callback);
    }
});

module.exports = KevoreeUI;
},{"events":20,"kevoree-commons":49,"pseudoclass":125}],68:[function(require,module,exports){
var Class = require('pseudoclass');

/**
 * Port
 * You are not supposed to create Port object (unless you are an AdaptationPrimitive)
 *
 * @class
 */
var Port = Class({
    toString: 'Port',

    /**
     *
     * @param name
     * @param path
     *
     * @constructs
     */
    construct: function (name, path) {
        this.name                = name;
        this.path                = path;
        this.component           = null;
        this.channel             = null;
        this.inputPortMethodName = null;
    },

    processSend: function (msg, callback) {
        this.channel.internalSend(this.path, msg, callback);
    },

    setInputPortMethodName: function (name) {
        this.inputPortMethodName = name;
    },

    getInputPortMethodName: function () {
        return this.inputPortMethodName;
    },

    getName: function () {
        return this.name;
    },

    getPath: function () {
        return this.path;
    },

    setComponent: function (comp) {
        this.component = comp;
    },

    getComponent: function () {
        return this.component;
    },

    setChannel: function (chan) {
        this.channel = chan;
    }
});

module.exports = Port;
},{"pseudoclass":125}],69:[function(require,module,exports){
function CacheManager() {
    this.cache = {};
}

CacheManager.prototype.get = function (key) {
    return this.cache[key];
};

CacheManager.prototype.add = CacheManager.prototype.put = function (key, value) {
    this.cache[key] = value;
};

CacheManager.prototype.remove = CacheManager.prototype.delete = function (key) {
    delete this.cache[key];
};

CacheManager.prototype.clear = function () {
    Object.keys(this.cache).forEach(function (key) {
        delete this.cache[key];
    }.bind(this));
    this.cache = {};
};

module.exports = CacheManager;
},{}],70:[function(require,module,exports){
var Class       = require('pseudoclass'),
    kevs        = require('./parser'),
    interpreter = require('./interpreter'),
    modelInterpreter = require('./model-interpreter'),
    CacheManager = require('./CacheManager');

var KevScript = Class({
    toString: 'KevScript',

    construct: function (cacheManager) {
        this.cacheManager = cacheManager || new CacheManager();
        interpreter.setCacheManager(this.cacheManager);
    },

    /**
     * Parses given KevScript source-code in parameter 'data' and returns a ContainerRoot.
     * @param {String} data string
     * @param {Object|Function} [ctxModel] a model to "start" on (in order not to create a model from scratch)
     * @param {Function} callback function (Error, ContainerRoot)
     * @throws Error on SyntaxError and on source code validity and such
     */
    parse: function (data, ctxModel, callback) {
        if (typeof(callback) === 'undefined') {
            callback = ctxModel;
            ctxModel = null;
        }

        var parser = new kevs.Parser();
        var ast = parser.parse(data);
        if (ast.type != 'kevScript') {
            callback(new Error(ast.toString()));
        } else {
            interpreter(ast, ctxModel, callback);
        }
    },

    /**
     * Parses a Kevoree model (ContainerRoot) and returns the equivalent KevScript string
     * @param model kevoree ContainerRoot model
     */
    parseModel: function (model) {
        return modelInterpreter(model);
    },

    getCacheManager: function () {
        return this.cacheManager;
    }
});

module.exports = KevScript;
},{"./CacheManager":69,"./interpreter":81,"./model-interpreter":83,"./parser":84,"pseudoclass":125}],71:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var grps = model.groups.iterator();

    var str = '';
    while (grps.hasNext()) {
        var grp = grps.next();
        if (grp.subNodes.size() > 0) {
            if (str.length !== 0) {
                str += '\n';
            }

            str += 'attach ';

            var subNodes = grp.subNodes.iterator();
            while (subNodes.hasNext()) {
                var subNode = subNodes.next();
                str += subNode.name;
                if (subNodes.hasNext()) {
                    str += ', ';
                }
            }

            str += ' '+grp.name;
        }
    }

    return str;
};
},{}],72:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var bindings = model.mBindings.iterator();

    var str = '';
    while (bindings.hasNext()) {
        var binding = bindings.next();
        if (str.length !== 0) {
            str += '\n';
        }

        str += 'bind ' +
            binding.port.eContainer().eContainer().name + '.' +
            binding.port.eContainer().name + '.' +
            binding.port.name + ' ' +
            binding.hub.name;
    }

    return str;
};
},{}],73:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var tdefs = model.typeDefinitions.iterator();
    var str = '';
    while (tdefs.hasNext()) {
        var du = tdefs.next().deployUnit;
        var type = 'mvn';
        if (du.type === 'npm') {
            type = 'npm';
        }

        var def = '';
        if (du.groupName) {
            def += du.groupName+':';
        }
        def += du.name+':';
        def += du.version;

        if (str.indexOf(def) === -1) {
            if (str.length !== 0) {
                str += '\n';
            }
            str += 'include '+type+':'+def;
        }
    }

    return str;
};
},{}],74:[function(require,module,exports){
var getFQN = require('../getFQN');

/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var str = '';

    function process(elems) {
        var map = {};
        while (elems.hasNext()) {
            var elem = elems.next();
            var fqn = getFQN(elem.typeDefinition);
            var list = map[fqn] || [];
            list.push(elem.name);
            map[fqn] = list;
        }

        for (var tdef in map) {
            if (map.hasOwnProperty(tdef)) {
                if (str.length !== 0) {
                    str += '\n';
                }
                str += 'add '+map[tdef].join(', ')+' : '+tdef;
            }
        }
    }

    function processRootNodes(elems) {
        var map = {};
        while (elems.hasNext()) {
            var elem = elems.next();
            var fqn = getFQN(elem.typeDefinition);
            var list = map[fqn] || [];

            if (!elem.host) {
                list.push(elem.name);
            }

            map[fqn] = list;
        }

        for (var tdef in map) {
            if (map.hasOwnProperty(tdef)) {
                if (map[tdef].length > 0) {
                    if (str.length !== 0) {
                        str += '\n';
                    }
                    str += 'add '+map[tdef].join(', ')+' : '+tdef;
                }
            }
        }
    }

    function processHostedNodesAndComps(elems) {
        var compsMap = {};
        var subnodesMap = {};
        var list;
        while (elems.hasNext()) {
            var elem = elems.next(), fqn;

            if (elem.host) {
                // elem is a subNode
                fqn = getFQN(elem.typeDefinition);
                list = subnodesMap[fqn] || [];
                list.push(elem.host.name+'.'+elem.name);
                subnodesMap[fqn] = list;
            }

            var comps = elem.components.iterator();
            while (comps.hasNext()) {
                var comp = comps.next();
                fqn = getFQN(comp.typeDefinition);
                list = compsMap[fqn] || [];
                list.push(elem.name+'.'+comp.name);
                compsMap[fqn] = list;
            }
        }

        var tdef;
        for (tdef in compsMap) {
            if (compsMap.hasOwnProperty(tdef)) {
                if (compsMap[tdef].length > 0) {
                    if (str.length !== 0) {
                        str += '\n';
                    }
                    str += 'add '+compsMap[tdef].join(', ')+' : '+tdef;
                }
            }
        }

        for (tdef in subnodesMap) {
            if (subnodesMap.hasOwnProperty(tdef)) {
                if (subnodesMap[tdef].length > 0) {
                    if (str.length !== 0) {
                        str += '\n';
                    }
                    str += 'add '+subnodesMap[tdef].join(', ')+' : '+tdef;
                }
            }
        }
    }

    processRootNodes(model.nodes.iterator());
    processHostedNodesAndComps(model.nodes.iterator());
    process(model.groups.iterator());
    process(model.hubs.iterator());

    return str.replace(/org\.kevoree\.library\./g, '');
};
},{"../getFQN":79}],75:[function(require,module,exports){
/**
 * Created by leiko on 20/06/14.
 */
module.exports = function (model) {
    var str = '';
    var toStop = [];

    function addElems(instances, host) {
        while (instances.hasNext()) {
            var instance = instances.next();
            if (!instance.started) {
                // instance is stopped => add to toStop array
                if (host) {
                    toStop.push(host.name+'.'+instance.name);
                } else {
                    toStop.push(instance.name);
                }
            }

            // if instance has components => check for their state too
            if (instance.components) {
                addElems(instance.components.iterator(), instance);
            }
            // if instance has hosts => check for their state too
            if (instance.hosts) {
                addElems(instance.hosts.iterator(), instance);
            }
        }
    }

    addElems(model.nodes.iterator());
    addElems(model.groups.iterator());
    addElems(model.hubs.iterator());

    // generate statement
    if (toStop.length > 0) {
        str = 'stop ' + toStop.join(', ');
    }

    return str;
};
},{}],76:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var str = '';

    var nodes = model.nodes.iterator();
    while (nodes.hasNext()) {
        var node = nodes.next();
        var nets = node.networkInformation.iterator();
        while (nets.hasNext()) {
            var net = nets.next();
            var values = net.values.iterator();
            while (values.hasNext()) {
                var val = values.next();
                if (str.length !== 0) {
                    str += '\n';
                }

                str += 'network '+node.name+'.'+net.name+'.'+val.name+' '+val.value;
            }
        }
    }

    return str;
};
},{}],77:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 * @param model
 * @returns {string}
 */
module.exports = function (model) {
    var str = '';

    var repos = model.repositories.iterator();
    while (repos.hasNext()) {
        var repo = repos.next();
        if (str.length !== 0) {
            str += '\n';
        }
        str += 'repo "'+repo.url+'"';
    }

    return str;
};
},{}],78:[function(require,module,exports){
/**
 * Created by leiko on 10/04/14.
 */
function lexValue(value) {
    if (value) {
        var escaped = false;
        for (var i=0; i < value.length; i++) {
            if (value[i] === '"' && !escaped) {
                return '\''+value+'\'';
            }

            if (value[i] === '\'' && !escaped) {
                return '"'+value+'"';
            }

            escaped = (value[i] === '\\');
        }
        return '\''+value+'\'';
    } else {
        return '\'\'';
    }
}

module.exports = function (model) {
    var str = '';

    function processDictionary(instanceName, values, fragName, dicType) {
        while (values.hasNext()) {
            var val = values.next();
            var attr = dicType.findAttributesByID(val.name);
            if (attr.defaultValue !== val.value) {
                if (str.length !== 0) {
                    str += '\n';
                }

                if (fragName) {
                    str += 'set '+instanceName+'.'+val.name+'/'+fragName+' = '+lexValue(val.value);
                } else {
                    str += 'set '+instanceName+'.'+val.name+' = '+lexValue(val.value);
                }
            }
        }
    }

    function processInstance(instance, host) {
        var instanceName = (host) ? (host+'.'+instance.name) : (instance.name);

        if (instance.dictionary) {
            processDictionary(instanceName, instance.dictionary.values.iterator(), null, instance.typeDefinition.dictionaryType);
        }

        var fDics = instance.fragmentDictionary.iterator();
        while (fDics.hasNext()) {
            var dic = fDics.next();
            if (dic) {
                processDictionary(instanceName, dic.values.iterator(), dic.name, instance.typeDefinition.dictionaryType);
            }
        }
    }

    var nodes = model.nodes.iterator();
    while (nodes.hasNext()) {
        var node = nodes.next();
        if (!node.host) {
            // only process nodes that are not hosted (hosted nodes will be processed as subNodes later)
            processInstance(node);
        }

        var subNodes = node.hosts.iterator();
        while (subNodes.hasNext()) {
            processInstance(subNodes.next(), node.name);
        }

        var comps = node.components.iterator();
        while (comps.hasNext()) {
            processInstance(comps.next(), node.name);
        }
    }

    var groups = model.groups.iterator();
    while (groups.hasNext()) {
        processInstance(groups.next());
    }

    var hubs = model.hubs.iterator();
    while (hubs.hasNext()) {
        processInstance(hubs.next());
    }

    return str;
};
},{}],79:[function(require,module,exports){
// Created by leiko on 16/09/14 17:18
module.exports = function getFQN(tdef) {
    var fqn = tdef.name+'/'+tdef.version;
    function walk(pkg) {
        if (pkg.eContainer()) {
            fqn = pkg.name + '.' + fqn;
            walk(pkg.eContainer());
        }
    }

    walk(tdef.eContainer());

    return fqn;
};
},{}],80:[function(require,module,exports){
/**
 * Created by leiko on 19/06/14.
 */
module.exports.resolve = function resolve(model, stmt) {
    var instances, i, nodes;

    switch (stmt.type) {
        case 'instancePath':
            var children = [];
            for (i=0; i < stmt.children.length; i++) {
                children.push(stmt.children[i].children.join(''));
            }
            if (children.length < 3) {
                if (children.length === 2) {
                    // instance path with two segments => components or subnodes
                    nodes = [];
                    var subs = [];
                    if (children[0] === '*') {
                        var kNodes = model.nodes.iterator();
                        while (kNodes.hasNext()) {
                            nodes.push(kNodes.next());
                        }
                    } else {
                        var kNode = model.findNodesByID(children[0]);
                        if (kNode) {
                            nodes.push(kNode);
                        }
                    }

                    if (nodes.length > 0) {
                        for (i=0; i < nodes.length; i++) {
                            var comps = nodes[i].components.iterator();
                            while (comps.hasNext()) {
                                subs.push(comps.next());
                            }
                            var hosts = nodes[i].hosts.iterator();
                            while (hosts.hasNext()) {
                                subs.push(hosts.next());
                            }
                        }

                        if (subs.length > 0) {
                            return subs;
                        } else {
                            throw new Error('Unable to find '+children[1]+' in '+children[0]);
                        }
                    } else {
                        throw new Error('Unable to find node '+children[0]);
                    }
                } else {
                    // instance path with one segment
                    instances = [];
                    if (children[0] === '*') {
                        nodes = model.nodes.iterator();
                        while (nodes.hasNext()) {
                            instances.push(nodes.next());
                        }
                        var groups = model.groups.iterator();
                        while (groups.hasNext()) {
                            instances.push(groups.next());
                        }
                        var hubs = model.hubs.iterator();
                        while (hubs.hasNext()) {
                            instances.push(hubs.next());
                        }

                    } else {
                        var instance = model.findNodesByID(children[0]);
                        if (!instance) {
                            instance = model.findGroupsByID(children[0]);
                        }
                        if (!instance) {
                            instance = model.findHubsByID(children[0]);
                        }
                        if (instance) {
                            instances.push(instance);
                        }
                    }

                    if (instances.length > 0) {
                        return instances;
                    } else {
                        throw new Error('Unable to find instance '+children[0]);
                    }
                }
            } else {
                throw new Error('Namespaces are not implemented yet ('+children.join('.')+')');
            }
            break;

        case 'nameList':
            instances = [];
            for (i=0; i < stmt.children.length; i++) {
                var resolved = resolve(model, stmt.children[i]);
                for (var j=0; j < resolved.length; j++) {
                    instances.push(resolved[j]);
                }
            }
            return instances;

        default:
            throw new Error('Unknown statement type '+stmt.type);
    }
};
},{}],81:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree,
    async   = require('async'),
    path    = require('path');

// retrieve statements processors
var statements = {
    addRepo:                require('./statements/addRepo'),
    add:                    require('./statements/add'),
    move:                   require('./statements/move'),
    attach:                 require('./statements/attach'),
    addBinding:             require('./statements/addBinding'),
    delBinding:             require('./statements/delBinding'),
    include:                require('./statements/include'),
    set:                    require('./statements/set'),
    network:                require('./statements/network'),
    remove:                 require('./statements/remove'),
    detach:                 require('./statements/detach'),
    typeDef:                require('./statements/typeDef'),
    typeFQN:                require('./statements/typeFQN'),
    nameList:               require('./statements/nameList'),
    instancePath:           require('./statements/instancePath'),
    namespace:              require('./statements/namespace'),
    wildcard:               require('./statements/wildcard'),
    string:                 require('./statements/string'),
    string2:                require('./statements/string2'),
    string3:                require('./statements/string3'),
    repoString:             require('./statements/repoString'),
    version:                require('./statements/version'),
    anything:               require('./statements/anything'),
    realString:             require('./statements/realString'),
    realStringNoNewLine:    require('./statements/realStringNoNewLine'),
    newLine:                require('./statements/newLine'),
    singleQuoteLine:        require('./statements/singleQuoteLine'),
    doubleQuoteLine:        require('./statements/doubleQuoteLine'),
    escaped:                require('./statements/escaped'),
    start:                  require('./statements/start'),
    stop:                   require('./statements/stop'),
    pause:                  require('./statements/pause')
};

var factory = new kevoree.factory.DefaultKevoreeFactory();
var cloner  = factory.createModelCloner();

/**
 *
 * @param ast
 * @param ctxModel
 * @param callback
 * @constructor
 */
function interpreter(ast, ctxModel, callback) {
    // output model
    var model = null;

    if (ctxModel) {
        // if we have a context model, clone it and use it has a base
        model = cloner.clone(ctxModel, false);
    } else {
        // otherwise start from a brand new model
        model = factory.createContainerRoot();
    }

    // this ContainerRoot is the root of the model
    factory.root(model);

    var options = { namespaces: {} };

    // process statements
    var tasks = [];
    ast.children.forEach(function (child0) {
        child0.children.forEach(function (stmt) {
            tasks.push(function (done) {
                if (typeof (statements[stmt.type]) === 'function') {
                    statements[stmt.type](model, statements, stmt, options, done);
                } else {
                    done(new Error('Unknown statement "'+stmt.type+'"'));
                }
            });
        });
    });

    // execute tasks
    async.series(tasks, function (err) {
        callback(err, model);
    });
}

module.exports = interpreter;
module.exports.clearCache = function () {
    statements['typeDef'].clearCache();
};
module.exports.setCacheManager = function (cacheMgr) {
    statements['typeDef'].setCacheManager(cacheMgr);
};

},{"./statements/add":85,"./statements/addBinding":86,"./statements/addRepo":87,"./statements/anything":88,"./statements/attach":89,"./statements/delBinding":90,"./statements/detach":91,"./statements/doubleQuoteLine":92,"./statements/escaped":93,"./statements/include":94,"./statements/instancePath":95,"./statements/move":96,"./statements/nameList":97,"./statements/namespace":98,"./statements/network":99,"./statements/newLine":100,"./statements/pause":101,"./statements/realString":102,"./statements/realStringNoNewLine":103,"./statements/remove":104,"./statements/repoString":105,"./statements/set":106,"./statements/singleQuoteLine":107,"./statements/start":108,"./statements/stop":109,"./statements/string":110,"./statements/string2":111,"./statements/string3":112,"./statements/typeDef":113,"./statements/typeFQN":114,"./statements/version":115,"./statements/wildcard":116,"async":14,"kevoree-library":124,"path":27}],82:[function(require,module,exports){
function findChanNodeGroupByName(model, name) {
  function findByName(elem) {
    var elems = (model[elem]) ? model[elem].iterator() : null;
    if (elems != null) {
      while (elems.hasNext()) {
        var entity = elems.next();
        if (entity.name === name) return entity;
      }
    }
    return null;
  }

  return findByName('nodes') || findByName('groups') || findByName('hubs') || null;
}

function findComponent(model, nodeName, compName) {
  var node = model.findNodesByID(nodeName);
  if (node) {
    return node.findComponentsByID(compName);
  } else return null;
}

module.exports = {
  findEntityByName: findChanNodeGroupByName,
  findComponentByName: findComponent
};
},{}],83:[function(require,module,exports){
var repos       = require('./elements/repositories'),
    includes    = require('./elements/includes'),
    instances   = require('./elements/instances'),
    attaches    = require('./elements/attaches'),
    lifecycles  = require('./elements/lifecycles'),
    bindings    = require('./elements/bindings'),
    sets        = require('./elements/sets'),
    networks    = require('./elements/networks');

/**
 * Created by leiko on 10/04/14.
 */
module.exports = function (model) {
    var blocks = [
        // order matters !
        repos(model),
//        includes(model),
        instances(model),
        lifecycles(model),
        attaches(model),
        bindings(model),
        sets(model),
        networks(model)
    ];

    var kevscript = '';
    for (var i in blocks) {
        if (blocks.hasOwnProperty(i)) {
            kevscript += blocks[i];
            if (blocks[i].length > 0) {
                kevscript += '\n\n';
            }
        }
    }

    return kevscript.replace(/^([\n\t\r])+/, '').replace(/([\n\t\r])+$/, '\n');
};
},{"./elements/attaches":71,"./elements/bindings":72,"./elements/includes":73,"./elements/instances":74,"./elements/lifecycles":75,"./elements/networks":76,"./elements/repositories":77,"./elements/sets":78}],84:[function(require,module,exports){
/*
 * Generated by the Waxeye Parser Generator - version 0.8.0
 * www.waxeye.org
 */

var waxeye = waxeye;
if (typeof module !== 'undefined') {
    // require from module system
    waxeye = require('waxeye');
}

var Parser = (function() {

    var parser = function() { return this; };
    parser.prototype = new waxeye.WaxeyeParser(0, true, [new waxeye.FA("kevScript", [new waxeye.State([new waxeye.Edge(50, 1, false)], false),
            new waxeye.State([new waxeye.Edge(1, 2, false),
                new waxeye.Edge(48, 3, true)], true),
            new waxeye.State([new waxeye.Edge(50, 1, false)], false),
            new waxeye.State([new waxeye.Edge(49, 2, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("statement", [new waxeye.State([new waxeye.Edge(2, 1, false),
                new waxeye.Edge(3, 1, false),
                new waxeye.Edge(4, 1, false),
                new waxeye.Edge(5, 1, false),
                new waxeye.Edge(6, 1, false),
                new waxeye.Edge(7, 1, false),
                new waxeye.Edge(9, 1, false),
                new waxeye.Edge(10, 1, false),
                new waxeye.Edge(12, 1, false),
                new waxeye.Edge(8, 1, false),
                new waxeye.Edge(11, 1, false),
                new waxeye.Edge(16, 1, false),
                new waxeye.Edge(17, 1, false),
                new waxeye.Edge(18, 1, false),
                new waxeye.Edge(19, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("add", [new waxeye.State([new waxeye.Edge(35, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(":", 5, true)], false),
            new waxeye.State([new waxeye.Edge(50, 6, false)], false),
            new waxeye.State([new waxeye.Edge(14, 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("remove", [new waxeye.State([new waxeye.Edge(36, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("move", [new waxeye.State([new waxeye.Edge(37, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("attach", [new waxeye.State([new waxeye.Edge(39, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("detach", [new waxeye.State([new waxeye.Edge(40, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("set", [new waxeye.State([new waxeye.Edge(38, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge("/", 4, true),
                new waxeye.Edge(50, 6, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([new waxeye.Edge(50, 6, false)], false),
            new waxeye.State([new waxeye.Edge("=", 7, true)], false),
            new waxeye.State([new waxeye.Edge(50, 8, false)], false),
            new waxeye.State([new waxeye.Edge(27, 9, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("network", [new waxeye.State([new waxeye.Edge(41, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(23, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("addBinding", [new waxeye.State([new waxeye.Edge(42, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("delBinding", [new waxeye.State([new waxeye.Edge(43, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(20, 3, false)], false),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("addRepo", [new waxeye.State([new waxeye.Edge(33, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(31, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("include", [new waxeye.State([new waxeye.Edge(34, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(22, 3, false)], false),
            new waxeye.State([new waxeye.Edge(":", 4, true)], false),
            new waxeye.State([new waxeye.Edge(23, 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("nameList", [new waxeye.State([new waxeye.Edge(20, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge([","], 3, true)], true),
            new waxeye.State([new waxeye.Edge(50, 4, false)], false),
            new waxeye.State([new waxeye.Edge(20, 2, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("typeDef", [new waxeye.State([new waxeye.Edge(15, 1, false)], false),
            new waxeye.State([new waxeye.Edge("/", 2, true)], true),
            new waxeye.State([new waxeye.Edge(25, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("typeFQN", [new waxeye.State([new waxeye.Edge(24, 1, false)], false),
            new waxeye.State([new waxeye.Edge(["."], 2, false)], true),
            new waxeye.State([new waxeye.Edge(24, 1, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("namespace", [new waxeye.State([new waxeye.Edge(44, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(22, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("start", [new waxeye.State([new waxeye.Edge(45, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("stop", [new waxeye.State([new waxeye.Edge(46, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("pause", [new waxeye.State([new waxeye.Edge(47, 1, false)], false),
            new waxeye.State([new waxeye.Edge(50, 2, false)], false),
            new waxeye.State([new waxeye.Edge(13, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("instancePath", [new waxeye.State([new waxeye.Edge(21, 1, false),
                new waxeye.Edge(22, 1, false)], false),
            new waxeye.State([new waxeye.Edge(["."], 2, true)], true),
            new waxeye.State([new waxeye.Edge(21, 1, false),
                new waxeye.Edge(22, 1, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("wildcard", [new waxeye.State([new waxeye.Edge("*", 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("string", [new waxeye.State([new waxeye.Edge(["-", [48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge(["-", [48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("string2", [new waxeye.State([new waxeye.Edge(["%", [45, 46], [48, 58], [64, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge(["%", [45, 46], [48, 58], [64, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("string3", [new waxeye.State([new waxeye.Edge([[48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge([[48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.PRUNE),
        new waxeye.FA("version", [new waxeye.State([new waxeye.Edge([[45, 46], [48, 57], [65, 90], "_", [97, 122]], 1, false)], false),
            new waxeye.State([new waxeye.Edge([[45, 46], [48, 57], [65, 90], "_", [97, 122]], 1, false)], true)], waxeye.FA.LEFT),
        new waxeye.FA("line", [new waxeye.State([new waxeye.Edge(52, 1, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 2, false)], false),
            new waxeye.State([new waxeye.Edge(51, 3, false)], true),
            new waxeye.State([new waxeye.Edge(-1, 2, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("realString", [new waxeye.State([new waxeye.Edge(["\'"], 1, true),
                new waxeye.Edge(["\""], 3, true)], false),
            new waxeye.State([new waxeye.Edge(32, 1, false),
                new waxeye.Edge(28, 1, false),
                new waxeye.Edge(29, 1, false),
                new waxeye.Edge(["\'"], 2, true)], false),
            new waxeye.State([], true),
            new waxeye.State([new waxeye.Edge(32, 3, false),
                new waxeye.Edge(28, 3, false),
                new waxeye.Edge(30, 3, false),
                new waxeye.Edge(["\""], 2, true)], false)], waxeye.FA.LEFT),
        new waxeye.FA("escaped", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([new waxeye.Edge(53, 2, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("singleQuoteLine", [new waxeye.State([new waxeye.Edge(59, 1, false)], false),
            new waxeye.State([new waxeye.Edge(58, 2, false)], false),
            new waxeye.State([new waxeye.Edge(57, 3, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false),
            new waxeye.State([new waxeye.Edge(56, 5, false)], true),
            new waxeye.State([new waxeye.Edge(55, 6, false)], false),
            new waxeye.State([new waxeye.Edge(54, 7, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("doubleQuoteLine", [new waxeye.State([new waxeye.Edge(65, 1, false)], false),
            new waxeye.State([new waxeye.Edge(64, 2, false)], false),
            new waxeye.State([new waxeye.Edge(63, 3, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false),
            new waxeye.State([new waxeye.Edge(62, 5, false)], true),
            new waxeye.State([new waxeye.Edge(61, 6, false)], false),
            new waxeye.State([new waxeye.Edge(60, 7, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 4, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("realStringNoNewLine", [new waxeye.State([new waxeye.Edge(["\'"], 1, true),
                new waxeye.Edge(["\""], 8, true)], false),
            new waxeye.State([new waxeye.Edge(["\\"], 2, false),
                new waxeye.Edge(69, 4, false),
                new waxeye.Edge(["\'"], 7, true)], false),
            new waxeye.State([new waxeye.Edge(66, 3, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 1, false)], false),
            new waxeye.State([new waxeye.Edge(68, 5, false)], false),
            new waxeye.State([new waxeye.Edge(67, 6, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 1, false)], false),
            new waxeye.State([], true),
            new waxeye.State([new waxeye.Edge(["\\"], 9, false),
                new waxeye.Edge(73, 11, false),
                new waxeye.Edge(["\""], 7, true)], false),
            new waxeye.State([new waxeye.Edge(70, 10, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 8, false)], false),
            new waxeye.State([new waxeye.Edge(72, 12, false)], false),
            new waxeye.State([new waxeye.Edge(71, 13, false)], false),
            new waxeye.State([new waxeye.Edge(-1, 8, false)], false)], waxeye.FA.LEFT),
        new waxeye.FA("newLine", [new waxeye.State([new waxeye.Edge("\r", 1, true),
                new waxeye.Edge("\n", 2, true),
                new waxeye.Edge("\r", 2, true)], false),
            new waxeye.State([new waxeye.Edge("\n", 2, true)], false),
            new waxeye.State([], true)], waxeye.FA.LEFT),
        new waxeye.FA("repoToken", [new waxeye.State([new waxeye.Edge("r", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("p", 3, false)], false),
            new waxeye.State([new waxeye.Edge("o", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("includeToken", [new waxeye.State([new waxeye.Edge("i", 1, false)], false),
            new waxeye.State([new waxeye.Edge("n", 2, false)], false),
            new waxeye.State([new waxeye.Edge("c", 3, false)], false),
            new waxeye.State([new waxeye.Edge("l", 4, false)], false),
            new waxeye.State([new waxeye.Edge("u", 5, false)], false),
            new waxeye.State([new waxeye.Edge("d", 6, false)], false),
            new waxeye.State([new waxeye.Edge("e", 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("addToken", [new waxeye.State([new waxeye.Edge("a", 1, false)], false),
            new waxeye.State([new waxeye.Edge("d", 2, false)], false),
            new waxeye.State([new waxeye.Edge("d", 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("removeToken", [new waxeye.State([new waxeye.Edge("r", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("m", 3, false)], false),
            new waxeye.State([new waxeye.Edge("o", 4, false)], false),
            new waxeye.State([new waxeye.Edge("v", 5, false)], false),
            new waxeye.State([new waxeye.Edge("e", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("moveToken", [new waxeye.State([new waxeye.Edge("m", 1, false)], false),
            new waxeye.State([new waxeye.Edge("o", 2, false)], false),
            new waxeye.State([new waxeye.Edge("v", 3, false)], false),
            new waxeye.State([new waxeye.Edge("e", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("setToken", [new waxeye.State([new waxeye.Edge("s", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("attachToken", [new waxeye.State([new waxeye.Edge("a", 1, false)], false),
            new waxeye.State([new waxeye.Edge("t", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("a", 4, false)], false),
            new waxeye.State([new waxeye.Edge("c", 5, false)], false),
            new waxeye.State([new waxeye.Edge("h", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("detachToken", [new waxeye.State([new waxeye.Edge("d", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("a", 4, false)], false),
            new waxeye.State([new waxeye.Edge("c", 5, false)], false),
            new waxeye.State([new waxeye.Edge("h", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("networkToken", [new waxeye.State([new waxeye.Edge("n", 1, false)], false),
            new waxeye.State([new waxeye.Edge("e", 2, false)], false),
            new waxeye.State([new waxeye.Edge("t", 3, false)], false),
            new waxeye.State([new waxeye.Edge("w", 4, false)], false),
            new waxeye.State([new waxeye.Edge("o", 5, false)], false),
            new waxeye.State([new waxeye.Edge("r", 6, false)], false),
            new waxeye.State([new waxeye.Edge("k", 7, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("bindToken", [new waxeye.State([new waxeye.Edge("b", 1, false)], false),
            new waxeye.State([new waxeye.Edge("i", 2, false)], false),
            new waxeye.State([new waxeye.Edge("n", 3, false)], false),
            new waxeye.State([new waxeye.Edge("d", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("unbindToken", [new waxeye.State([new waxeye.Edge("u", 1, false)], false),
            new waxeye.State([new waxeye.Edge("n", 2, false)], false),
            new waxeye.State([new waxeye.Edge("b", 3, false)], false),
            new waxeye.State([new waxeye.Edge("i", 4, false)], false),
            new waxeye.State([new waxeye.Edge("n", 5, false)], false),
            new waxeye.State([new waxeye.Edge("d", 6, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("namespaceToken", [new waxeye.State([new waxeye.Edge("n", 1, false)], false),
            new waxeye.State([new waxeye.Edge("a", 2, false)], false),
            new waxeye.State([new waxeye.Edge("m", 3, false)], false),
            new waxeye.State([new waxeye.Edge("e", 4, false)], false),
            new waxeye.State([new waxeye.Edge("s", 5, false)], false),
            new waxeye.State([new waxeye.Edge("p", 6, false)], false),
            new waxeye.State([new waxeye.Edge("a", 7, false)], false),
            new waxeye.State([new waxeye.Edge("c", 8, false)], false),
            new waxeye.State([new waxeye.Edge("e", 9, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("startToken", [new waxeye.State([new waxeye.Edge("s", 1, false)], false),
            new waxeye.State([new waxeye.Edge("t", 2, false)], false),
            new waxeye.State([new waxeye.Edge("a", 3, false)], false),
            new waxeye.State([new waxeye.Edge("r", 4, false)], false),
            new waxeye.State([new waxeye.Edge("t", 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("stopToken", [new waxeye.State([new waxeye.Edge("s", 1, false)], false),
            new waxeye.State([new waxeye.Edge("t", 2, false)], false),
            new waxeye.State([new waxeye.Edge("o", 3, false)], false),
            new waxeye.State([new waxeye.Edge("p", 4, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("pauseToken", [new waxeye.State([new waxeye.Edge("p", 1, false)], false),
            new waxeye.State([new waxeye.Edge("a", 2, false)], false),
            new waxeye.State([new waxeye.Edge("u", 3, false)], false),
            new waxeye.State([new waxeye.Edge("s", 4, false)], false),
            new waxeye.State([new waxeye.Edge("e", 5, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("comment", [new waxeye.State([new waxeye.Edge("/", 1, false)], false),
            new waxeye.State([new waxeye.Edge("/", 2, false)], false),
            new waxeye.State([new waxeye.Edge(26, 3, false)], true),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("eol", [new waxeye.State([new waxeye.Edge("\r", 1, false),
                new waxeye.Edge("\n", 2, false),
                new waxeye.Edge("\r", 2, false)], false),
            new waxeye.State([new waxeye.Edge("\n", 2, false)], false),
            new waxeye.State([], true)], waxeye.FA.VOID),
        new waxeye.FA("ws", [new waxeye.State([new waxeye.Edge(["\t", " "], 0, false),
                new waxeye.Edge(49, 0, false)], true)], waxeye.FA.VOID),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\'"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\'"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\""], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\""], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\'"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(49, 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\\"], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG),
        new waxeye.FA("", [new waxeye.State([new waxeye.Edge(["\""], 1, false)], false),
            new waxeye.State([], true)], waxeye.FA.NEG)]);
    return parser;
 
})();

// Add to module system
if (typeof module !== 'undefined') {
    module.exports.Parser = Parser;
}

},{"waxeye":121}],85:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();
var Kotlin  = require('kevoree-kotlin');
var getFQN  = require('../getFQN');

module.exports = function (model, statements, stmt, opts, done) {
    var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts);
    statements[stmt.children[1].type](model, statements, stmt.children[1], opts, function (err, tDef) {
        if (err) {
            done(err);
        } else {
            function inflateDictionary(instance) {
                var dicType = instance.typeDefinition.dictionaryType;
                if (dicType) {
                    var dic = factory.createDictionary();
                    var attrs = dicType.attributes.iterator();
                    while (attrs.hasNext()) {
                        var attr = attrs.next();
                        if (!attr.fragmentDependant && !attr.optional && typeof attr.defaultValue !== 'undefined') {
                            var val = factory.createValue();
                            val.name = attr.name;
                            val.value = attr.defaultValue;
                            dic.addValues(val);
                        }
                    }
                    if (dic.values.size() > 0) {
                        instance.dictionary = dic;
                    }
                }
            }

            // add node instance function
            function addNodeInstance(namespace, nodeName, parentNode) {
                if (nodeName !== '*') {
                    var node = factory.createContainerNode();
                    node.name = nodeName;
                    node.typeDefinition = model.findByPath(tDef.path());
                    node.started = true;
                    inflateDictionary(node);
                    model.addNodes(node);
                    if (parentNode) {
                        parentNode.addHosts(node);
                    }

                    if (namespace) {
                        if (opts.namespaces[namespace]) {
                            opts.namespaces[namespace][nodeName] = node;
                        } else {
                            done(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                        }
                    }
                } else {
                    done(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                }
            }

            // create proper entity according to the type
            if (Kotlin.isType(tDef, kevoree.NodeType)) {
                for (var i in nameList) {
                    nameList[i].expect(1, 3, function (err, namespace, parentName, childName) {
                        if (err) {
                            err.message += ' (add '+nameList[i].toString()+' : '+getFQN(tDef)+')';
                            done(err);
                            return;
                        }

                        if (namespace) {
                            // TODO handle namespaces
                            done(new Error('Namespaces are not handled yet'));
                        } else {
                            if (parentName) {
                                if (parentName === '*') {
                                    // parentName can't be '*' because each node name must be unique within a model so you can't
                                    // duplicate the same childName on each parentNode
                                    done(new Error('You can not refer to all node instances with \'*\' when adding child node instances. (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                } else {
                                    var parentNode = model.findNodesByID(parentName);
                                    if (parentNode) {
                                        addNodeInstance(namespace, childName, parentNode);

                                    } else {
                                        done(new Error('Unable to find parent node instance "'+parentName+'" in model. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                    }
                                }

                            } else {
                                addNodeInstance(namespace, childName);
                            }
                        }
                    });
                }

            } else if (Kotlin.isType(tDef, kevoree.GroupType)) {
                for (var i in nameList) {
                    nameList[i].expect(1, 2, function (err, namespace, instanceName) {
                        if (err) {
                            err.message += ' (add '+nameList[i].toString()+' : '+getFQN(tDef)+')';
                            done(err);
                            return;
                        }

                        if (instanceName !== '*') {
                            var group = factory.createGroup();
                            group.name = instanceName;
                            group.typeDefinition = model.findByPath(tDef.path());
                            group.started = true;
                            inflateDictionary(group);
                            model.addGroups(group);

                            if (namespace) {
                                if (opts.namespaces[namespace]) {
                                    opts.namespaces[namespace][instanceName] = group;
                                } else {
                                    done(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                }
                            }
                        } else {
                            done(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                        }
                    });
                }

            } else if (Kotlin.isType(tDef, kevoree.ChannelType)) {
                for (var i in nameList) {
                    nameList[i].expect(1, 2, function (err, namespace, instanceName) {
                        if (err) {
                            err.message += ' (add '+nameList[i].toString()+' : '+getFQN(tDef)+')';
                            done(err);
                            return;
                        }

                        if (instanceName !== '*') {
                            var chan = factory.createChannel();
                            chan.name = instanceName;
                            chan.typeDefinition = model.findByPath(tDef.path());
                            chan.started = true;
                            inflateDictionary(chan);
                            model.addHubs(chan);

                            if (namespace) {
                                if (opts.namespaces[namespace]) {
                                    opts.namespaces[namespace][instanceName] = chan;
                                } else {
                                    done(new Error('Unable to find "'+namespace+'" namespace. Did you create it? (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                }
                            }
                        } else {
                            done(new Error('You cannot name a node instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                        }
                    });
                }

            } else if (Kotlin.isType(tDef, kevoree.ComponentType)) {
                for (var i in nameList) {
                    nameList[i].expect(2, 3, function (err, namespace, nodeName, compName) {
                        if (err) {
                            done(new Error('Component instances must be added to Node instances (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                            return;
                        }

                        if (namespace) {
                            // TODO handle namespace
                            done(new Error('Namespaces are not handled yet :/ Sorry'));

                        } else if (compName === '*') {
                            done(new Error('You cannot name a component instance "*" (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));

                        } else {
                            var comp;
                            if (nodeName === '*') {
                                // add compName instance to all nodes in the model
                                var nodes = model.nodes.iterator();
                                while (nodes.hasNext()) {
                                    comp = factory.createComponentInstance();
                                    comp.name = compName;
                                    comp.typeDefinition = model.findByPath(tDef.path());;
                                    comp.started = true;
                                    inflateDictionary(comp);
                                    nodes.next().addComponents(comp);
                                }

                            } else {
                                var node = model.findNodesByID(nodeName);
                                if (node) {
                                    comp = factory.createComponentInstance();
                                    comp.name = compName;
                                    comp.typeDefinition = model.findByPath(tDef.path());;
                                    comp.started = true;
                                    inflateDictionary(comp);
                                    node.addComponents(comp);

                                } else {
                                    done(new Error('Unable to find container node "'+nodeName+'" in current model (add '+nameList[i].toString()+' : '+getFQN(tDef)+')'));
                                }
                            }
                        }
                    });
                }

            } else {
                done(new Error('TypeDefinition "'+tDef.name+'/'+tDef.version+'" doesn\'t exist in current model. (Maybe you should add an "include" for it?)'));
                return;
            }
            done();
        }
    });
};
},{"../getFQN":79,"kevoree-kotlin":122,"kevoree-library":124}],86:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
    var port = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var chan = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

    function addBinding2(portName, comp, node, chanInst) {
        // start with an undefined portInst
        var portInst;

        // now lets try to find a Port instance in this component provided ports
        portInst = comp.findProvidedByID(portName);
        if (!portInst) {
            // if we can't find it in provided ports, lets try in required
            portInst = comp.findRequiredByID(portName);
        }
        if (!portInst) {
            // reaching this point means that we were not able to find any port instance
            // matching this portName, so we have to create a brand new port instance
            portInst = factory.createPort();
            // lets try to find a PortTypeRef in the component TypeDefinition provided ports that matches portName
            var inputRefs = comp.typeDefinition.provided.iterator();
            while (inputRefs.hasNext()) {
                var inRef = inputRefs.next();
                if (inRef.name === portName) {
                    // bingo, add it the the comp instance
                    portInst.portTypeRef = inRef;
                    portInst.name = portName;
                    comp.addProvided(portInst);
                    break;
                }
            }
            if (!portInst.portTypeRef) {
                // well, it isn't a provided port obviously, so now lets try to find out if it is a required
                var outputRefs = comp.typeDefinition.required.iterator();
                while (outputRefs.hasNext()) {
                    var outRef = outputRefs.next();
                    if (outRef.name == portName) {
                        // bingo, add it to the comp instance
                        portInst.portTypeRef = outRef;
                        portInst.name = portName;
                        comp.addRequired(portInst);
                        break;
                    }
                }
            }
        }

        if (portInst && portInst.portTypeRef && portInst.name === portName) {
            var bindings = model.mBindings.iterator();
            var alreadyBound = false;
            while (bindings.hasNext()) {
                var binding = bindings.next();
                if (binding.hub.name === chanInst.name &&
                    binding.port.name === portName &&
                    binding.port.eContainer().name === comp.name &&
                    binding.port.eContainer().eContainer().name === node.name) {
                    alreadyBound = true;
                    break;
                }
            }

            if (!alreadyBound) {
                binding = factory.createMBinding();
                binding.port = portInst;
                binding.hub  = chanInst;
                model.addMBindings(binding);
            }
        } else {
            // seems like you are trying to connect a port that do not belong to the comp you referred to
            return cb(new Error('Unable to find port "'+portName+'" in component '+comp.typeDefinition.name+'['+comp.name+'] (bind '+port.toString()+' '+chan.toString()+')'));
        }
    }

    function addBinding1(portName, compName, node, chanInst) {
        var comp = node.findComponentsByID(compName);
        if (comp) {
            if (portName === '*') {
                var inputRefs = comp.typeDefinition.provided.iterator();
                while (inputRefs.hasNext()) {
                    addBinding2(inputRefs.next().name, comp, node, chanInst);
                }
                var outputRefs = comp.typeDefinition.required.iterator();
                while (outputRefs.hasNext()) {
                    addBinding2(outputRefs.next().name, comp, node, chanInst);
                }

            } else {
                addBinding2(portName, comp, node, chanInst);
            }
        } else {
            return cb(new Error('Unable to find component instance "'+compName+'" in node "'+node.name+'" (bind '+port.toString()+' '+chan.toString()+')'));
        }
    }

    function addBinding0(portName, compName, nodeName, chanInst) {
        var node = model.findNodesByID(nodeName);
        if (node) {
            if (compName === '*') {
                var compz = node.components.iterator();
                while (compz.hasNext()) {
                    addBinding1(portName, compz.next().name, node, chanInst);
                }

            } else {
                addBinding1(portName, compName, node, chanInst);
            }
        } else {
            return cb(new Error('Unable to find node instance "'+nodeName+'" in model (bind '+port.toString()+' '+chan.toString()+')'));
        }
    }

    function bindPortToChan(chanInst) {
        port.expect(3, 4, function (err, namespace, nodeName, compName, portName) {
            if (err) {
                err.message += ' (bind '+port.toString()+' '+chan.toString()+')';
                return cb(err);
            }

            if (namespace) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (bind '+port.toString()+' '+chan.toString()+')'));

            } else {
                if (nodeName === '*') {
                    var nodes = model.nodes.iterator();
                    while (nodes.hasNext()) {
                        addBinding0(portName, compName, nodes.next().name, chanInst);
                    }

                } else {
                    addBinding0(portName, compName, nodeName, chanInst);
                }
            }
        });
    }

    chan.expect(1, 2, function (err, namespace, name) {
        if (err) {
            err.message += ' (bind '+port.toString()+' '+chan.toString()+')';
            return cb(err);
        }

        if (namespace) {
            // TODO
            return cb(new Error('Namespaces are not handled yet :/ Sorry (bind '+port.toString()+' '+chan.toString()+')'));

        } else {
            if (name === '*') {
                var chanz = model.hubs.iterator();
                while (chanz.hasNext()) {
                    bindPortToChan(chanz.next());
                }

            } else {
                var chanInst = model.findHubsByID(name);
                if (chanInst) {
                    bindPortToChan(chanInst);

                } else {
                    return cb(new Error('Unable to find target channel instance "'+name+'" (bind '+port.toString()+' '+chan.toString()+')'));
                }
            }
        }
    });

    cb();
};
},{"kevoree-library":124}],87:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
    var url = statements[stmt.children[0].type](model, statements, stmt, opts, cb);

    // create repository & add it to model
    var repo = factory.createRepository();
    repo.url = url;
    model.addRepositories(repo);

    cb();
};
},{"kevoree-library":124}],88:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
  return stmt.children.join('');
}
},{}],89:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  var target   = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function addNodeToGroup(group) {
    for (var i=0; i < nameList.length; i++) {
      nameList[i].expect(1, 2, function (err, namespace, nodeName) {
        if (err) {
          err.message += ' (attach '+nameList.toString()+' '+target.toString()+')';
          return cb(err);
        }

        if (namespace) {
          // TODO
          return cb(new Error('Namespaces are not handled yet :/ Sorry (attach '+nameList.toString()+' '+target.toString()+')'));

        } else {
          if (nodeName === '*') {
            // attach all nodes to group
            var nodes = model.nodes.iterator();
            while (nodes.hasNext()) group.addSubNodes(nodes.next());

          } else {
            var node = model.findNodesByID(nodeName);
            if (node) {
              group.addSubNodes(node);
            } else {
              return cb(new Error('Unable to find node "'+nodeName+'" in model (attach '+nameList.toString()+' '+target.toString()+')'));
            }
          }
        }
      });
    }
  }

  target.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (attach '+nameList.toString()+' '+target.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (attach '+nameList.toString()+' '+target.toString()+')'));

    } else {
      if (name === '*') {
        var groups = model.groups.iterator();
        while (groups.hasNext()) addNodeToGroup(groups.next());

      } else {
        var group = model.findGroupsByID(name);
        if (group) {
          addNodeToGroup(group);

        } else {
          return cb(new Error('Unable to find group "'+name+'" in model (attach '+nameList.toString()+' '+target.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{}],90:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
    var port = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var chan = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

    function unbindPortFromChan2(portName, comp, node, chanName) {
        var bindings = model.mBindings.iterator();
        while (bindings.hasNext()) {
            var binding = bindings.next();
            if (binding.port.portTypeRef.name === portName &&                // binding's port matches portName
                binding.port.eContainer().name === comp.name &&              // port's component matches comp.name
                binding.port.eContainer().eContainer().name === node.name && // component's container matches node.name
                binding.hub.name === chanName) {                             // binding's hub name matches chanName

                if (binding.port) binding.port.removeBindings(binding);
                if (binding.hub)  binding.hub.removeBindings(binding);
                model.removeMBindings(binding);
            }
        }
    }

    function unbindPortFromChan1(portName, comp, node, chanName) {
        if (portName === '*') {
            var inputRefs = comp.typeDefinition.provided.iterator();
            var outputRefs = comp.typeDefinition.required.iterator();

            while (inputRefs.hasNext()) {
                unbindPortFromChan2(inputRefs.next().name, comp, node, chanName);
            }

            while (outputRefs.hasNext()) {
                unbindPortFromChan2(outputRefs.next().name, comp, node, chanName);
            }

        } else {
            unbindPortFromChan2(portName, comp, node, chanName);
        }
    }

    function unbindPortFromChan0(portName, compName, node, chanName) {
        if (compName === '*') {
            var compz = node.components.iterator();
            while (compz.hasNext()) {
                unbindPortFromChan1(portName, compz.next(), node, chanName);
            }

        } else {
            var comp = node.findComponentsByID(compName);
            if (comp) {
                unbindPortFromChan1(portName, comp, node, chanName);
            } else {
                return cb(new Error('Unable to find component instance "'+compName+'" in node instance "'+node.name+'" (unbind '+port.toString()+' '+chan.toString()+')'));
            }
        }
    }

    function preUnbindProcess(chanInst) {
        port.expect(3, 4, function (err, namespace, nodeName, compName, portName) {
            if (err) {
                err.message += ' (unbind '+port.toString()+' '+chan.toString()+')';
                return cb(err);
            }

            if (namespace) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (unbind '+port.toString()+' '+chan.toString()+')'));

            } else {
                if (nodeName === '*') {
                    var nodes = model.nodes.iterator();
                    while (nodes.hasNext()) {
                        unbindPortFromChan0(portName, compName, nodes.next(), chanInst.name);
                    }

                } else {
                    var node = model.findNodesByID(nodeName);
                    if (node) {
                        unbindPortFromChan0(portName, compName, node, chanInst.name);
                    } else {
                        return cb(new Error('Unable to find node instance "'+nodeName+'" in model (unbind '+port.toString()+' '+chan.toString()+')'));
                    }
                }
            }
        });
    }

    chan.expect(1, 2, function (err, namespace, name) {
        if (err) {
            err.message += ' (unbind '+port.toString()+' '+chan.toString()+')';
            return cb(err);
        }

        if (namespace) {
            // TODO
            return cb(new Error('Namespaces are not handled yet :/ Sorry (unbind '+port.toString()+' '+chan.toString()+')'));

        } else {
            if (name === '*') {
                var chanz = model.hubs.iterator();
                while (chanz.hasNext()) {
                    preUnbindProcess(chanz.next());
                }

            } else {
                var chanInst = model.findHubsByID(name);
                if (chanInst) {
                    preUnbindProcess(chanInst);
                } else {
                    return cb(new Error('Unable to find channel instance "'+name+'" in model (unbind '+port.toString()+' '+chan.toString()+')'));
                }
            }
        }
    });

    cb();
}
},{}],91:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
    var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts);
    var groupName = statements[stmt.children[1].type](model, statements, stmt.children[1], opts);

    if (groupName.raw.length === 1) {
        groupName = groupName.toString();
        var group = model.findGroupsByID(groupName);
        if (group) {
            for (var i=0; i < nameList.length; i++) {
                if (nameList[i].raw.length === 1) {
                    var nodeName = nameList[i].toString();
                    var node = model.findNodesByID(nodeName);
                    if (node) {
                        node.removeGroups(group);
                        group.removeSubNodes(node);
                    } else {
                        cb(new Error('Unable to find node instance "'+nodeName+'" '+printLine(nameList, groupName)));
                        break;
                    }
                } else {
                    cb(new Error('Namespaces are not implemented yet '+printLine(nameList, groupName)));
                }
            }
            cb();
        } else {
            cb(new Error('Unable to find group instance "'+groupName+'" '+printLine(nameList, groupName)));
        }
    } else {
        cb(new Error('Namespaces are not implemented yet '+printLine(nameList, groupName)));
    }
};

function printLine(nameList, groupName) {
    return '(detach '+display(nameList)+' '+groupName.toString()+')';
}

function display(nameList) {
    return nameList.map(function (instancePath) {
        return instancePath.toString();
    }).join(', ');
}
},{}],92:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
  return stmt.children.join('');
}
},{}],93:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
  return stmt.children.join('');
};
},{}],94:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var path = require('path');

var factory = new kevoree.factory.DefaultKevoreeFactory();
var compare = factory.createModelCompare();

module.exports = function (model, statements, stmt, opts, cb) {
    console.log('"include" statement is deprecated since kevoree-kevscript@>=2.0.0');
    cb();
//    if (!cb) {
//        // if "cb" is undefined, then  there is no "opts" parameter given, so no resolver, so :/
//        return opts(new Error('You must give resolvers as options to "include.js" statement processor'));
//    }
//
//    if (!opts.resolvers) return cb(new Error('Unable to process include. No resolver given'));
//
//    var du = factory.createDeployUnit();
//    var type = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
//    var mergeDef = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
//
//    if (opts.resolvers[type]) {
//        var colons = mergeDef.split(':');
//        var arobas = mergeDef.split('@');
//        if (colons.length === 1 && arobas.length === 1) {
//            // mergeDef looks like: foo
//            du.name = mergeDef;
//
//        } else if (colons.length === 1 && arobas.length === 2) {
//            // mergeDef looks like: foo@version
//            du.name = arobas[0];
//            du.version = arobas[1];
//
//        } else if (colons.length === 2 && arobas.length === 1) {
//            // mergeDef looks like: foo:version
//            du.name = colons[0];
//            du.version = colons[1];
//
//        } else if (colons.length === 3 && arobas.length === 1) {
//            // mergeDef looks like: foo:bar:version
//            du.groupName = colons[0];
//            du.name = colons[1];
//            du.version = colons[2];
//
//        } else if (colons.length === 2 && arobas.length === 2) {
//            // mergeDef looks like: foo:bar@version
//            var subSplit = arobas[0].split(':');
//            du.groupName = subSplit[0];
//            du.name = subSplit[1];
//            du.version = arobas[1];
//        }
//
//        opts.resolvers[type].resolve(du, function (err, Clazz, duModel) {
//            if (err) return cb(err);
//
//            var loader = factory.createJSONLoader();
//            var serializer = factory.createJSONSerializer();
//
//            var tmp = loader.loadModelFromString(serializer.serialize(duModel)).get(0);
//            var mergeSeq = compare.merge(model, tmp);
//            mergeSeq.applyOn(model);
//            return cb();
//        });
//
//    } else {
//        // no resolver set for include statements with "type"
//        return cb(new Error('Error: include '+type+':'+mergeDef+' (Unable to handle "'+type+'" include type. Did you add a resolver for that?)'));
//    }
};
},{"kevoree-library":124,"path":27}],95:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
    var instancePath = [];
    for (var i in stmt.children) {
        instancePath.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts));
    }

    return {
        raw: instancePath,
        /**
         * 'a.b.c' with expect(2, 4, function (err, one, two, three, four) {
         *   if (err) {
         *     // something went wrong with instancePath.expect parsing
         *   }
         *
         *   // when parsing 'a.b.c' with expect(2, 4, ...) you get:
         *   // one   === null
         *   // two   === 'a'
         *   // three === 'b'
         *   // four  === 'c'
         * }
         * @param min minimum expected values in instancePath (ex: a.b.c with "min" = 4 will return an error in callback)
         * @param max maximum expected values in instancePath (same as minimum but for maximum :D )
         * @param callback function (err, [arg0, arg1, ...])
         * @returns {*}
         */
        expect: function (min, max, callback) {
            if (instancePath.length > max || instancePath.length < min) {
                var err = new Error('InstancePath does not match requirements (path: '+instancePath.join('.')+', length: '+instancePath.length+', min: '+min+', max: '+max+')');
                err.pathLength = instancePath.length;
                err.expectedMin = min;
                err.expectedMax = max;
                return callback(err);
            }

            instancePath.unshift(null); // prepend null error value to params array
            // nullify missing value in path (ex: 'a.b.c' with expect(2, 4, function (err, one, two, three, four) { }
            // will nullify 'one' and shift values so you get two => a, three => b and four => c
            for (var i=instancePath.length-1; i < max; i++) instancePath.unshift(null);
            return callback.apply(null, instancePath);
        },

        toString: function () {
            // remove useless dots
            return instancePath.join('.').replace(/^\.*/g, '');
        }
    };
};
},{}],96:[function(require,module,exports){
var Kotlin = require('kevoree-kotlin');
var kevoree = require('kevoree-library').org.kevoree;

module.exports = function (model, statements, stmt, opts, cb) {
  // instances to move
  var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  // target node to move instances to
  var target   = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

  function processNameList(targetNode) {
    for (var i in nameList) {
      nameList[i].expect(2, 3, function (err, namespace, nodeName, compName) {
        if (err) {
          err.message += ' (move '+nameList.toString()+' '+target.toString()+')';
          return cb(err);
        }

        if (namespace) {
          // TODO
          return cb(new Error('Namespaces are not handled yet :/ Sorry (move '+nameList.toString()+' '+target.toString()+')'));

        } else {
          if (nodeName === '*') {
            if (compName === '*') {
              // move *.* fooNode
              var nodes = model.nodes.iterator();
              while (nodes.hasNext()) {
                var fromNode = nodes.next();
                var comps = fromNode.components.iterator();
                while (comps.hasNext()) {
                  var comp = comps.next();
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }
              }

            } else {
              // move *.fooComp fooNode
              var nodes = model.nodes.iterator();
              while (nodes.hasNext()) {
                var fromNode = nodes.next();
                var comp = fromNode.findComponentsByID(compName);
                if (comp) {
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }
              }
            }

          } else {
            if (compName === '*') {
              // move fooNode.* barNode
              var fromNode = model.findNodesByID(nodeName);
              if (fromNode) {
                var comps = fromNode.components.iterator();
                while (comps.hasNext()) {
                  var comp = comps.next();
                  fromNode.removeComponents(comp);
                  targetNode.addComponents(comp);
                }

              } else {
                return cb(new Error('Unable to find node "'+nodeName+'" in model (move '+nameList.toString()+' '+target.toString()+')'));
              }

            } else {
              // move fooNode.fooComp barNode
              var node = model.findNodesByID(nodeName);
              if (node) {
                var comp = node.findComponentsByID(compName);
                if (comp) {
                  node.removeComponents(comp);
                  targetNode.addComponents(comp);
                }

              } else {
                return cb(new Error('Unable to find node "'+nodeName+'" in model (move '+nameList.toString()+' '+target.toString()+')'));
              }
            }
          }
        }
      });
    }
  }

  // process target instancePath
  target.expect(1, 2, function (err, namespace, name) {
    if (err) {
      err.message += ' (move '+nameList.toString()+' '+target.toString()+')';
      return cb(err);
    }

    if (namespace) {
      // TODO
      return cb(new Error('Namespaces are not handled yet :/ Sorry (move '+nameList.toString()+' '+target.toString()+')'));
//      if (opts.namespaces[namespace]) {
//        var instance = opts.namespaces[namespace][name];
//        if (Kotlin.isType(instance.typeDefinition, kevoree.impl.NodeTypeImpl)) {
//          // target node exists
//          processNameList(instance);
//
//        } else {
//          return cb(new Error('Matched entity in namespace "'+[namespace, name].join('.')+'" must be a NodeType.'));
//        }
//
//      } else {
//        return cb(new Error('Unable to find namespace "'+namespace+'"'));
//      }

    } else {
      if (name === '*') {
        return cb(new Error('You must specify one and only node target (move '+nameList.toString()+' '+target.toString()+')'));

      } else {
        // check if the target exists
        var targetNode = model.findNodesByID(name);
        if (targetNode) {
          // target node exists
          processNameList(targetNode);

        } else {
          // node does not exist in current model
          return cb(new Error('Unable to find target node "'+target.toString()+'" in current model (move '+nameList.toString()+' '+target.toString()+')'));
        }
      }
    }
  });

  cb();
}
},{"kevoree-kotlin":122,"kevoree-library":124}],97:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
    var ret = [];
    for (var i in stmt.children) {
        ret.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts));
    }
    return ret;
};
},{}],98:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  opts.namespaces = opts.namespaces || {};
  var name = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
  opts.namespaces[name] = [];
}
},{}],99:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();

module.exports = function (model, statements, stmt, opts, cb) {
    var networkPath  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var value = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

    networkPath.expect(3, 4, function (err, namespace, nodeName, netName, propName) {
        if (err) {
            err.message += ' (network '+networkPath.toString()+' '+value+')';
            return cb(err);
        }

        function addProp(net, propName) {
            if (propName === '*') {
                var props = net.values.iterator();
                while (props.hasNext()) {
                    props.next().value = value;
                }

            } else {
                var prop = net.findValuesByID(propName);
                if (prop) {
                    prop.value = value;
                } else {
                    prop = factory.createValue();
                    prop.name = propName;
                    prop.value = value;
                    net.addValues(prop);
                }
            }
        }

        function addNet(node, netName, propName) {
            if (netName === '*') {
                var nets = node.networkInformation.iterator();
                while (nets.hasNext()) addProp(nets.next(), propName);

            } else {
                var net = node.findNetworkInformationByID(netName);
                if (net) {
                    addProp(net, propName);
                } else {
                    net = factory.createNetworkInfo();
                    net.name = netName;
                    node.addNetworkInformation(net);
                    addProp(net, propName);
                }
            }
        }

        if (namespace) {
            // TODO
            return cb(new Error('Namespaces are not handled yet :/ Sorry (network '+networkPath.toString()+' '+value+')'));

        } else {
            // networkPath looks like "network node.foo.bar 0.0.0.0"
            if (nodeName === '*') {
                var nodes = model.nodes.iterator();
                while (nodes.hasNext()) addNet(nodes.next(), netName, propName);

            } else {
                var node = model.findNodesByID(nodeName);
                if (node) {
                    addNet(node, netName, propName);
                } else {
                    return cb(new Error('Unable to find node instance "'+nodeName+'" (network '+networkPath.toString()+' '+value+')'));
                }
            }
        }
    });

    cb();
};
},{"kevoree-library":124}],100:[function(require,module,exports){
module.exports = function () {
    return '\n';
};
},{}],101:[function(require,module,exports){
/**
 * Created by leiko on 19/06/14.
 */
module.exports = function (model, statements, stmt, opts, cb) {
    cb(new Error('Pause statement is not implemented yet'));
};
},{}],102:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts) {
    var str = '';
    for (var i in stmt.children) {
        if (typeof (stmt.children[i]) === 'string') {
            str += stmt.children[i];
        } else if (stmt.children[i] instanceof Object) {
            str += statements[stmt.children[i].type](model, statements, stmt.children[i], opts);
        }
    }
    return str;
};
},{}],103:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
    return stmt.children[0].children.join('');
};
},{}],104:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var Kotlin = require('kevoree-kotlin');
var factory = kevoree.factory.DefaultKevoreeFactory();
var helper = require('../model-helper');

module.exports = function (model, statements, stmt, opts, cb) {
    var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);

    function doRemove1(nodeName, third) {
        var node = model.findNodesByID(nodeName);
        if (node) {
            if (third === '*') {
                // remove all components within this node
                var compz = node.components.iterator();
                while (compz.hasNext()) doRemove(compz.next());

            } else {
                var comp = node.findComponentsByID(third);
                if (comp) {
                    doRemove(comp);
                } else {
                    return cb(new Error('Unable to find component instance "'+third+'" in node instance "'+nodeName+'" in model (remove '+nameList.toString()+')'));
                }
            }
        } else {
            return cb(new Error('Unable to find node instance "'+nodeName+'" in model (remove '+nameList.toString()+')'));
        }
    }

    function doRemove(instance) {
        if (Kotlin.isType(instance, kevoree.ContainerNode)) {
            // remove groups fragment dictionary related to this node
            var groups = model.groups.iterator();
            while (groups.hasNext()) {
                var grp = groups.next();
                var dic = grp.findFragmentDictionaryByID(instance.name);
                if (dic) grp.removeFragmentDictionary(dic);
            }

            // remove channels fragment dictionary related to this node
            var hubs = model.hubs.iterator();
            while (hubs.hasNext()) {
                var hub = hubs.next();
                var dic = hub.findFragmentDictionaryByID(instance.name);
                if (dic) hub.removeFragmentDictionary(dic);
            }

            // remove bindings related to this node
            var comps = instance.components.iterator();
            while (comps.hasNext()) {
                var comp = comps.next();
                var provided = comp.provided.iterator();
                while (provided.hasNext()) {
                    var pPort = provided.next();
                    var bindings = pPort.bindings.iterator();
                    while (bindings.hasNext()) {
                        var binding = bindings.next();
                        binding.hub.removeBindings(binding);
                        model.removeMBindings(binding);
                    }
                }
                var required = comp.required.iterator();
                while (required.hasNext()) {
                    var rPort = required.next();
                    var bindings = rPort.bindings.iterator();
                    while (bindings.hasNext()) {
                        var binding = bindings.next();
                        binding.hub.removeBindings(binding);
                        model.removeMBindings(binding);
                    }
                }
            }

            // delete links with groups
            var groups = instance.groups.iterator();
            while (groups.hasNext()) groups.next().removeSubNodes(instance);

            // remove node itself
            if (instance.host) instance.host.removeHosts(instance);
            model.removeNodes(instance);

        } else if (Kotlin.isType(instance, kevoree.Group)) {
            // remove link between this group and nodes
            var nodes = instance.subNodes.iterator();
            while (nodes.hasNext()) nodes.next().removeGroups(instance);
            // remove group
            model.removeGroups(instance);

        } else if (Kotlin.isType(instance, kevoree.Channel)) {
            var bindings = model.mBindings.iterator();
            while (bindings.hasNext()) {
                var binding = bindings.next();
                if (binding.hub.name === instance.name) {
                    if (binding.port) binding.port.removeBindings(binding);
                    if (binding.hub)  binding.hub.removeBindings(binding);
                    model.removeMBindings(binding);
                }
            }
            model.removeHubs(instance);

        } else if (Kotlin.isType(instance, kevoree.ComponentInstance)) {
            function deleteBindings(ports) {
                while (ports.hasNext()) {
                    var bindings = ports.next().bindings.iterator();
                    while (bindings.hasNext()) {
                        var binding = bindings.next();
                        if (binding.port) binding.port.removeBindings(binding);
                        if (binding.hub)  binding.hub.removeBindings(binding);
                        model.removeMBindings(binding);
                    }
                }
            }

            deleteBindings(instance.provided.iterator());
            deleteBindings(instance.required.iterator());
            instance.eContainer().removeComponents(instance);

        } else {
            return cb(new Error('Unable to remove instance "'+names[i]+'" from current model. (Are you sure it is a node, group, chan, component?)'));
        }
    }

    for (var i in nameList) {
        nameList[i].expect(1, 3, function (err, first, second, third) {
            if (err) {
                err.message = ' (remove '+nameList.toString()+')';
                return cb(err);
            }

            if (first) {
                // TODO there is at least 3 parts in path so it must refer to a namespace 'first.second.third'
                return cb(new Error('Namespaces are not handled yet :/ Sorry (remove '+nameList.toString()+')'));

            } else {
                if (second) {
                    // two parts path: 'second.third'
                    if (second === '*') {
                        var nodes = model.nodes.iterator();
                        while (nodes.hasNext()) doRemove1(nodes.next().name, third);
                    } else {
                        doRemove1(second, third);
                    }
                } else {
                    // one part path: 'third'
                    if (third === '*') {
                        var nodes = model.nodes.iterator();
                        var groups = model.groups.iterator();
                        var hubs = model.hubs.iterator();

                        while (nodes.hasNext())  doRemove(nodes.next());
                        while (groups.hasNext()) doRemove(groups.next());
                        while (hubs.hasNext())   doRemove(hubs.next());

                    } else {
                        var instance = helper.findEntityByName(model, third);
                        if (instance)
                            doRemove(instance);
                        else
                            return cb(new Error('Unable to find instance "'+third+'" in model (remove '+nameList.toString()+')'));
                    }
                }
            }
        });
    }

    var names = [];

    if (stmt.children[0].type == 'nameList') {
        for (var i in stmt.children[0].children) {
            names.push(stmt.children[0].children[i].children.join(''));
        }
    } else {
        names.push(stmt.children[0].children.join(''));
    }

    for (var i in names) {
        var entity = helper.findEntityByName(model, names[i]);
        if (entity != null) {
            if (Kotlin.isType(entity, kevoree.ContainerNode)) {
                var groups = (model.groups) ? model.groups.iterator() : null;
                if (groups != null) {
                    while (groups.hasNext()) {
                        var group = groups.next();
                        var subNodes = group.subNodes.iterator();
                        while (subNodes.hasNext()) {
                            if (subNodes.next().name == entity.name) group.removeSubNodes(entity);
                        }
                        var values = group.dictionary.values.iterator();
                        while (values.hasNext()) {
                            var val = values.next();
                            if (val.targetNode.name == entity.name) group.dictionary.removeValues(val);
                        }
                    }
                }
                model.removeNodes(entity);

            } else if (Kotlin.isType(entity, kevoree.Group)) {
                model.removeGroups(entity);
            } else if (Kotlin.isType(entity, kevoree.Channel)) {
                model.removeHubs(entity);
            } else if (Kotlin.isType(entity, kevoree.ComponentInstance)) {
                entity.eContainer().removeComponents(entity);
            } else {
                return cb(new Error('Unable to remove instance "'+names[i]+'" from current model. (Are you sure it is a node, group, chan, component?)'));
            }
        }
    }

    cb();
};
},{"../model-helper":82,"kevoree-kotlin":122,"kevoree-library":124}],105:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
  return stmt.children.join('');
};
},{}],106:[function(require,module,exports){
var kevoree = require('kevoree-library').org.kevoree;
var factory = new kevoree.factory.DefaultKevoreeFactory();
var helper  = require('../model-helper');

module.exports = function (model, statements, stmt, opts, cb) {
    var attr  = null,
        node  = null,
        value = null;

    function processAttribute(dic, attrName) {
        var dicValue = dic.findValuesByID(attrName);
        if (dicValue) {
            // update value
            dicValue.value = value;
        } else {
            // dictionary value for attribute named attrName does not exist yet: create it and add it if possible
            var kAttr = dic.eContainer().typeDefinition.dictionaryType.findAttributesByID(attrName);
            if (kAttr) {
                dicValue = factory.createValue();
                dicValue.name = attrName;
                dicValue.value = value;
                dic.addValues(dicValue);
            } else {
                cb(new Error('Unknown attribute "'+attrName+'" in '+dic.eContainer().path()+' (set '+attr.toString()+' = "'+value+'")'));
            }
        }
    }

    function processNodeAndHostsAttribute(node, hostName, attrName) {
        if (hostName === '*') {
            var comps = node.components.iterator();
            while (comps.hasNext()) processInstanceAttribute(comps.next(), attrName);

        } else {
            var host = node.findComponentsByID(hostName);
            if (!host) {
                host = node.findHostsByID(hostName);
                if (!host) {
                    return cb(new Error('Unable to find instance "'+hostName+'" in "'+node.name+'" model (set '+attr.toString()+' = "'+value+'")'));
                }
            }
            processInstanceAttribute(host, attrName);
        }
    }

    function processInstanceAttribute(instance, attrName) {
        if (node) {
            // fragment dependant attribute
            var dic = instance.findFragmentDictionaryByID(node.toString());
            if (!dic) {
                // there is no fragmentDependant dictionary for this instance and fragment yet: create one
                dic = factory.createFragmentDictionary();
                dic.name = node.toString();
                instance.addFragmentDictionary(dic);
            }
            processAttribute(dic, attrName);

        } else {
            // non-fragment dependant attribute
            if (!instance.dictionary) instance.dictionary = factory.createDictionary();
            processAttribute(instance.dictionary, attrName);
        }
    }

    if (stmt.children.length === 2) {
        // set statement looks like: set an.instance.path = 'aValue'
        attr  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        value = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);

        attr.expect(2, 4, function (err, ns, two, three, four) {
            if (err) {
                err.message += ' (set '+attr.toString()+' = "'+value+'")';
                return cb(err);
            }

            if (ns) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+' = "'+value+'")'));

            } else {
                if (two) {
                    // statement looks like foo.bar.baz = '42'
                    if (two === '*') {
                        // TODO handle namespaces too when using '*' ?
                        var nodes = model.nodes.iterator();
                        while (nodes.hasNext()) processNodeAndHostsAttribute(nodes.next(), three, four);

                    } else {
                        // check whether "two" is a namespace or a node name
                        var nodeInstance = model.findNodesByID(two);
                        if (nodeInstance) {
                            processNodeAndHostsAttribute(nodeInstance, three, four);

                        } else {
                            // TODO
                            return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+' = "'+value+'")'));
                        }
                    }

                } else {
                    // statement looks like foo.bar = '42'
                    var instance = helper.findEntityByName(model, three);
                    if (instance) {
                        processInstanceAttribute(instance, four);

                    } else {
                        return cb(new Error('Unable to find instance "'+two+'" in model (set '+attr.toString()+' = "'+value+'")'));
                    }
                }
            }
        });

    } else if (stmt.children.length === 3) {
        // set statement looks like: set an.instance.path/aNode = 'aValue'
        attr  = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        node  = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
        value = statements[stmt.children[2].type](model, statements, stmt.children[2], opts, cb);

        attr.expect(2, 3, function (err, ns, instanceName, attrName) {
            if (err) {
                err.message += ' (set '+attr.toString()+'/'+node.toString()+' = "'+value+'")';
                return cb(err);
            }

            if (ns) {
                // TODO
                return cb(new Error('Namespaces are not handled yet :/ Sorry (set '+attr.toString()+'/'+node.toString()+' = "'+value+'")'));

            } else {
                if (instanceName === '*') {
                    var groups = model.groups.iterator();
                    while (groups.hasNext()) processInstanceAttribute(groups.next(), attrName);
                    var hubs = model.hubs.iterator();
                    while (hubs.hasNext()) processInstanceAttribute(hubs.next(), attrName);

                } else {
                    // instance is whether a group or a channel
                    var groups = model.groups.iterator();
                    while (groups.hasNext()) {
                        var grp = groups.next();
                        if (grp.name === instanceName) {
                            return processInstanceAttribute(grp, attrName);
                        }
                    }

                    var chans = model.hubs.iterator();
                    while (chans.hasNext()) {
                        var hub = chans.next();
                        if (hub.name === instanceName) {
                            return processInstanceAttribute(hub, attrName);
                        }
                    }
                }
            }
        });
    }

    cb();
};
},{"../model-helper":82,"kevoree-library":124}],107:[function(require,module,exports){
arguments[4][92][0].apply(exports,arguments)
},{"dup":92}],108:[function(require,module,exports){
var resolver = require('../instance-resolver');

/**
 * Created by leiko on 19/06/14.
 */
module.exports = function (model, statements, stmt, opts, cb) {
    var error = null;
    try {
        var instances = resolver.resolve(model, stmt.children[0]);
        for (var i=0; i < instances.length; i++) {
            instances[i].started = true;
        }
    } catch (err) {
        var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        err.message += ' ('+stmt.type+' '+nameList.join(', ')+')';
        error = err;
    } finally {
        cb(error);
    }
};
},{"../instance-resolver":80}],109:[function(require,module,exports){
var resolver = require('../instance-resolver');

/**
 * Created by leiko on 19/06/14.
 */
module.exports = function (model, statements, stmt, opts, cb) {
    var error = null;
    try {
        var instances = resolver.resolve(model, stmt.children[0]);
        for (var i=0; i < instances.length; i++) {
            instances[i].started = false;
        }
    } catch (err) {
        var nameList = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
        err.message += ' ('+stmt.type+' '+nameList.join(', ')+')';
        error = err;
    } finally {
        cb(error);
    }
};
},{"../instance-resolver":80}],110:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],111:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],112:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"dup":93}],113:[function(require,module,exports){
var SemVer = require('semver');
var registry = require('kevoree-registry-client');
var kevoree = require('kevoree-library').org.kevoree;
var getFqn = require('../getFQN');

var factory = new kevoree.factory.DefaultKevoreeFactory();
var loader = factory.createJSONLoader();
var compare = factory.createModelCompare();

var cache = null;

module.exports = function typeDef(model, statements, stmt, opts, cb) {
    var tdef;
    var fqn = statements[stmt.children[0].type](model, statements, stmt.children[0], opts, cb);
    var version;

    if (stmt.children[1]) {
        version = statements[stmt.children[1].type](model, statements, stmt.children[1], opts, cb);
    }

    if (fqn.split('.').length === 1) {
        // default package to 'org.kevoree.library' for fqn-less TypeDefinitions (ie: add node: JavascriptNode)
        fqn = 'org.kevoree.library.'+fqn;
    }

    if (version) {
        fqn += '/' + version;
    }

    var path = getModelPath(fqn);
    var tdefs = model.select(path).array;
    if (tdefs.length === 0) {
        // typeDef not in current model

        function firstHandler(err, tdefModelStr) {
            if (err) {
                var errMsg = 'Unable to find "'+fqn+'" in current model nor on Kevoree registry.';
                if (err.code === 'ENOTFOUND') {
                    errMsg += ' (Might it be a connectivity issue?)';
                }
                cb(new Error(errMsg));

            } else {
                var tdefModel = loader.loadModelFromString(tdefModelStr).get(0);

                tdefs = tdefModel.select(path).array;
                if (tdefs.length === 0) {
                    cb(new Error('Unable to find "'+fqn+'" on Kevoree registry.'));

                } else {
                    if (tdefs.length === 1) {
                        // there is only one TypeDefinition found, we can merge
                        var mergeSeq = compare.merge(model, tdefModel);
                        mergeSeq.applyOn(model);
                        // ...and answer with the newly added TypeDefinition from the registry
                        cache.add(fqn, tdefModelStr);
                        cb(null, tdefs[0]);
                    } else {
                        // there are more than one TypeDefinition that matches the given fqn on the registry
                        // so lets take the greater version
                        tdef = getBestVersion(tdefs);
                        // ask registry again for a model with this specific TypeDefinition only
                        var fqnForBestVers = getFqn(tdef);
                        if (cache.get(fqnForBestVers)) {
                            secondHandler(null, cache.get(fqnForBestVers));
                        } else {
                            registry.get({ fqns : [fqnForBestVers] }, secondHandler);
                        }
                    }
                }
            }
        }

        function secondHandler(err, tdefModelStr) {
            if (err) {
                cb(new Error('Unable to find "'+fqn+'" on Kevoree registry.'));
            } else {
                var tdefModel = loader.loadModelFromString(tdefModelStr).get(0);
                var mergeSeq = compare.merge(model, tdefModel);
                mergeSeq.applyOn(model);
                cache.add(fqn, tdefModelStr);
                cb(null, tdef);
            }
        }

        // try to hit cache first
        if (cache.get(fqn)) {
            // cached tdef found
            firstHandler(null, cache.get(fqn));
        } else {
            // no cache found, hit registry
            registry.get({ fqns: [fqn] }, firstHandler);
        }

    } else if (tdefs.length === 1) {
        // there is 1 availability for that TDef
        cb(null, tdefs[0]);
    } else {
        // there are multiple versions of this TDef: take the greater version
        cb(null, getBestVersion(tdefs));
    }
};

module.exports.clearCache = function () {
    cache.clean();
};

module.exports.setCacheManager = function (cacheMgr) {
    cache = cacheMgr;
};

function getModelPath(fqn) {
    // check for version
    fqn = fqn.split('/');
    var vers;
    if (fqn.length === 2) {
        vers = fqn.pop();
    }

    fqn = fqn[0].split('.');
    var last = fqn.pop();
    fqn = 'packages[' + fqn.join(']/packages[') + ']/typeDefinitions[name=' + last;

    if (vers) {
        fqn += ',version=' + vers;
    }

    fqn += ']';

    return fqn;
}

/**
 * Tries to find the greater version (snapshot excluded), if none found, tries to find the greater version
 * snapshots included
 * @param tdefs
 * @returns {*}
 */
function getBestVersion(tdefs) {
    var onlyReleases = tdefs.filter(function (tdef) {
        var v = new SemVer(tdef.version);
        if (v.prerelease.length === 0) {
            return tdef;
        }
    });

    function getGreater(tdefs) {
        var tdef = tdefs[0];
        for (var i=0; i < tdefs.length; i++) {
            if (SemVer.gt(tdefs[i].version, tdef.version)) {
                tdef = tdefs[i];
            }
        }
        return tdef;
    }

    return getGreater((onlyReleases.length === 0) ? tdefs : onlyReleases);
}
},{"../getFQN":79,"kevoree-library":124,"kevoree-registry-client":117,"semver":120}],114:[function(require,module,exports){
// Created by leiko on 27/08/14 15:15
module.exports = function (model, statements, stmt, opts, cb) {
    var typeFqn = [];
    for (var i in stmt.children) {
        if (typeof (stmt.children[i]) === 'string') {
            typeFqn.push(stmt.children[i]);
        } else {
            typeFqn.push(statements[stmt.children[i].type](model, statements, stmt.children[i], opts, cb));
        }
    }
    return typeFqn.join('');
};
},{}],115:[function(require,module,exports){
module.exports = function (model, statements, stmt) {
    return stmt.children.join('');
};
},{}],116:[function(require,module,exports){
module.exports = function (model, statements, stmt, opts, cb) {
  return stmt.children.join('');
}
},{}],117:[function(require,module,exports){
// Created by leiko on 09/09/14 15:23
module.exports.get = require('./lib/get');
module.exports.post = require('./lib/post');
},{"./lib/get":118,"./lib/post":119}],118:[function(require,module,exports){
// Created by leiko on 09/09/14 15:23
var http = require('http');

/**
 *
 * @param {Object}   options    - fqns:      Fully Qualified Names of Packages/DeployUnits/TypeDefinitions
 *                                           (e.g 'org.kevoree.library.js.JavascriptNode')
 *                              - [version]: TypeDefinition version (if version is not given, then '*' will be used)
 *                              - [type]:    Retrieved model type (default to 'json', but you can ask for 'xmi'
 *                                           or 'trace')
 *                              - [parse]:   If set to true, it will parse the last part of the fqn to get the
 *                                           TypeDefinition name from it (default: true)
 *                              - [kevPath]: Boolean to tell whether or not the fqns should be parsed or if they are
 *                                           already Kevoree model paths (default: false).
 *                                           e.g  options.kevPath = true
 *                                                => fqns array is supposed to contain real Kevoree model paths
 *                              - [host]:    Hostname of the request (default: 'registry.kevoree.org')
 *                              - [port]:    Port of the request (default: 80)
 * @param {Function} callback
 */
function fromFQN(options, callback) {
    options.type     = options.type  || 'json';
    options.host     = options.host  || 'registry.kevoree.org';
    options.port     = options.port  || 80;
    options.protocol = options.protocol || 'http:';

    var reqOpts = {
        hostname: options.host,
        port: options.port,
        protocol: options.protocol,
        headers: {},
        withCredentials: false
    };

    var fqn, fqns = [];
    if (options.kevPath) {
        fqns = JSON.stringify(options.fqns);
        reqOpts.method = 'POST';
        reqOpts.path = '/';
        reqOpts.headers['Content-Type'] = 'text/plain';
        reqOpts.headers['Content-Length'] = fqns.length;
    } else {
        if (options.fqns.length === 1) {
            // using GET method
            fqn = getUrlPath(options.fqns[0]);

            reqOpts.method = 'GET';
            reqOpts.path = '/' + fqn;
            reqOpts.headers.Accept = (function () {
                switch (options.type) {
                    default:
                    case 'json':
                        return 'application/json';

                    case 'xmi':
                        return 'application/vnd.xmi+xml';

                    case 'trace':
                        return 'text/plain';
                }
            })();
        } else {
            // multiple FQN => need to use POST method
            fqns = JSON.stringify(options.fqns.map(function (fqn) {
                return getModelPath(fqn);
            }));

            reqOpts.method = 'POST';
            reqOpts.path = '/';
            reqOpts.headers['Content-Type'] = 'text/plain';
            reqOpts.headers['Content-Length'] = fqns.length;
        }
    }

    var req = http.request(reqOpts, function (res) {
        switch (res.statusCode) {
            case 200:
                var data = '';
                res.on('data', function (chunk) { data += chunk; });
                res.on('end', function () {
                    switch (res.headers['content-type']) {
                        case 'application/json':
                            callback(null, data);
                            break;

                        case 'application/vnd.xmi+xml':
                        case 'text/plain':
                            callback(null, data);
                            break;

                        default:
                            callback(new Error('Response content MIME Type should be "'+reqOpts.headers.Accept+'" ' +
                                '(and not "'+res.headers['content-type']+'")'));
                            break;
                    }
                });
                break;

            case 404:
                callback(new Error('Unable to find "'+options.fqns+'" on Kevoree registry'));
                break;

            default:
            case 500:
                callback(new Error('Server error'));
                break;
        }
    }).on('error', function (err) {
        callback(err);
    });

    if (fqns.length > 1) {
        req.write(fqns);
    }

    req.end();
}

function getModelPath(fqn) {
    // check for version
    fqn = fqn.split('/');
    var vers;
    if (fqn.length === 2) {
        vers = fqn.pop();
    }

    fqn = fqn[0].split('.');
    var last = fqn.pop();
    fqn = 'packages[' + fqn.join(']/packages[') + ']/*[name=' + last;

    if (vers) {
        fqn += ',version=' + vers;
    }

    fqn += ']';

    return fqn;
}

function getUrlPath(fqn) {
    // check for version
    fqn = fqn.split('/');
    var vers;
    if (fqn.length === 2) {
        vers = fqn.pop();
    }

    fqn = fqn[0].split('.');
    var last = fqn.pop();
    fqn = fqn.join('/');
    fqn += '/name=' + last;

    if (vers) {
        fqn += ',version=' + vers;
    }

    return fqn;
}

module.exports = fromFQN;
},{"http":21}],119:[function(require,module,exports){
// Created by leiko on 09/09/14 15:24
var http = require('http');

/**
 *
 * @param {Object}   options    - model   String representation of the model to push (JSON, xmi or trace)
 *                              - [type]  String for the Content-Type of your model (default: json)
 *                                        This "type" can be [json, xmi, trace]
 *                              - [host]  Hostname of the request (default: 'registry.kevoree.org')
 *                              - [port]  Port of the request (default: 80)
 * @param {Function} callback
 */
function pushModel(options, callback) {
    options.type = options.type || 'json';
    options.host = options.host || 'registry.kevoree.org';
    options.port = options.port || 80;
    options.protocol = options.protocol || 'http:';


    var reqOpts = {
        hostname: options.host,
        port: options.port,
        protocol: options.protocol,
        path: '/deploy',
        method: 'POST',
        headers: {
            'Content-Type': (function () {
                switch (options.type) {
                    default:
                    case 'json':
                        return 'application/json';
                    case 'xmi':
                        return 'application/vnd.xmi+xml';
                    case 'trace':
                        return 'text/plain';
                }
            })(),
            'Content-Length': options.model.length
        }
    };

    var req = http.request(reqOpts, function (res) {
        switch (res.statusCode) {
            case 201:
                callback(null);
                break;

            case 406:
                callback(new Error('Unable to process model type "'+reqOpts.headers['Content-Type']+'" on registry'));
                break;

            default:
            case 500:
                callback(new Error('Server error'));
                break;
        }
    }).on('error', function (err) {
        callback(err);
    });

    req.write(options.model);
    req.end();
}

module.exports = pushModel;
},{"http":21}],120:[function(require,module,exports){
;(function(exports) {

// export the class if we are in a Node-like system.
if (typeof module === 'object' && module.exports === exports)
  exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  ;
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, loose) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, loose);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, loose) {
  var v = parse(version, loose);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, loose) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, loose) {
  if (version instanceof SemVer) {
    if (version.loose === loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, loose);

  ;
  this.loose = loose;
  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.inspect = function() {
  return '<SemVer "' + this + '">';
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  ;
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.loose);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    ;
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(b);
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, loose) {
  if (comp instanceof Comparator) {
    if (comp.loose === loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, loose);

  ;
  this.loose = loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  ;
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.loose);
};

Comparator.prototype.inspect = function() {
  return '<SemVer Comparator "' + this + '">';
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  ;

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  return cmp(version, this.operator, this.semver, this.loose);
};


exports.Range = Range;
function Range(range, loose) {
  if ((range instanceof Range) && range.loose === loose)
    return range;

  if (!(this instanceof Range))
    return new Range(range, loose);

  this.loose = loose;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.inspect = function() {
  return '<SemVer Range "' + this.range + '">';
};

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.loose;
  range = range.trim();
  ;
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  ;
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  ;

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, loose);
  }).join(' ').split(/\s+/);
  if (this.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, loose);
  });

  return set;
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, loose) {
  return new Range(range, loose).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, loose) {
  ;
  comp = replaceCarets(comp, loose);
  ;
  comp = replaceTildes(comp, loose);
  ;
  comp = replaceXRanges(comp, loose);
  ;
  comp = replaceStars(comp, loose);
  ;
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, loose);
  }).join(' ');
}

function replaceTilde(comp, loose) {
  var r = loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    ;
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0- <1.3.0-
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      ;
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    ;
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, loose) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, loose);
  }).join(' ');
}

function replaceCaret(comp, loose) {
  ;
  var r = loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    ;
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      ;
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      ;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    ;
    return ret;
  });
}

function replaceXRanges(comp, loose) {
  ;
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, loose);
  }).join(' ');
}

function replaceXRange(comp, loose) {
  comp = comp.trim();
  var r = loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    ;
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm)
          M = +M + 1
        else
          m = +m + 1
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    ;

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, loose) {
  ;
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.loose);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version))
      return true;
  }
  return false;
};

function testSet(set, version) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (version.prerelease.length) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      ;
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, loose) {
  try {
    range = new Range(range, loose);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, loose) {
  return versions.filter(function(version) {
    return satisfies(version, range, loose);
  }).sort(function(a, b) {
    return rcompare(a, b, loose);
  })[0] || null;
}

exports.validRange = validRange;
function validRange(range, loose) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, loose).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, loose) {
  return outside(version, range, '<', loose);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, loose) {
  return outside(version, range, '>', loose);
}

exports.outside = outside;
function outside(version, range, hilo, loose) {
  version = new SemVer(version, loose);
  range = new Range(range, loose);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, loose)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, loose)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, loose)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

// Use the define() function if we're in AMD land
if (typeof define === 'function' && define.amd)
  define(exports);

})(
  typeof exports === 'object' ? exports :
  typeof define === 'function' && define.amd ? {} :
  semver = {}
);

},{}],121:[function(require,module,exports){
var waxeye;
/*
# Waxeye Parser Generator
# www.waxeye.org
# Copyright (C) 2008-2010 Orlando Hill
# Licensed under the MIT license. See 'LICENSE' for details.
*/
waxeye = (function() {
  var AST, Edge, FA, InnerParser, ParseError, State, WaxeyeParser, namespace;
  Edge = function(_a, _b, _c) {
    this.voided = _c;
    this.state = _b;
    this.trans = _a;
    return this;
  };
  State = function(_a, _b) {
    this.match = _b;
    this.edges = _a;
    return this;
  };
  FA = function(_a, _b, _c) {
    this.mode = _c;
    this.states = _b;
    this.type = _a;
    return this;
  };
  FA.VOID = 0;
  FA.PRUNE = 1;
  FA.LEFT = 2;
  FA.POS = 3;
  FA.NEG = 4;
  ParseError = function(_a, _b, _c, _d) {
    this.nt = _d;
    this.col = _c;
    this.line = _b;
    this.pos = _a;
    return this;
  };
  ParseError.prototype.toString = function() {
    return "parse error: failed to match '" + this.nt + "' at line=" + this.line + ", col=" + this.col + ", pos=" + this.pos;
  };
  AST = function(_a, _b, _c) {
    this.pos = _c;
    this.children = _b;
    this.type = _a;
    return this;
  };
  AST.prototype.toString = function() {
    var acc, indent, toStringIter;
    acc = "";
    indent = 0;
    toStringIter = function(ast) {
      var _a, _b, _c, a, i;
      i = 0;
      while (i < indent - 1) {
        acc += '    ';
        i++;
      }
      indent > 0 ? acc += '->  ' : null;
      acc += ast.type;
      indent++;
      _b = ast.children;
      for (_a = 0, _c = _b.length; _a < _c; _a++) {
        a = _b[_a];
        acc += '\n';
        if ((typeof a) === 'string') {
          i = 0;
          while (i < indent - 1) {
            acc += '    ';
            i++;
          }
          indent > 0 ? acc += '|   ' : null;
          acc += a;
        } else {
          toStringIter(a);
        }
      }
      indent--;
      return acc;
    };
    return toStringIter(this);
  };
  WaxeyeParser = function(_a, _b, _c) {
    this.automata = _c;
    this.eofCheck = _b;
    this.start = _a;
    return this;
  };
  WaxeyeParser.prototype.parse = function(input) {
    return new InnerParser(this.start, this.eofCheck, this.automata, input).parse();
  };
  InnerParser = function(_a, _b, _c, input) {
    this.automata = _c;
    this.eofCheck = _b;
    this.start = _a;
    this.input = input;
    this.inputLen = input.length;
    this.inputPos = 0;
    this.line = 1;
    this.column = 0;
    this.lastCR = false;
    this.errorPos = 0;
    this.errorLine = 1;
    this.errorCol = 0;
    this.errorNT = this.automata[this.start].type;
    this.faStack = [];
    this.cache = {};
    return this;
  };
  InnerParser.prototype.parse = function() {
    return this.doEOFCheck(this.matchAutomaton(this.start));
  };
  InnerParser.prototype.matchAutomaton = function(index) {
    var _a, automaton, cached, key, mode, res, startCR, startCol, startLine, startPos, type, value;
    startPos = this.inputPos;
    key = ("" + index + "," + startPos);
    cached = this.cache[key];
    if (typeof cached !== "undefined" && cached !== null) {
      this.restorePos(cached[1], cached[2], cached[3], cached[4]);
      return cached[0];
    }
    startLine = this.line;
    startCol = this.column;
    startCR = this.lastCR;
    automaton = this.automata[index];
    type = automaton.type;
    mode = automaton.mode;
    this.faStack.push(automaton);
    res = this.matchState(0);
    this.faStack.pop();
    value = (function() {
      if (mode === FA.POS) {
        this.restorePos(startPos, startLine, startCol, startCR);
        if (res) {
          return true;
        } else {
          this.updateError();
          return false;
        }
      } else if (mode === FA.NEG) {
        this.restorePos(startPos, startLine, startCol, startCR);
        if (res) {
          this.updateError();
          return false;
        } else {
          return true;
        }
      } else {
        if (res) {
          if (mode === FA.VOID) {
            return true;
          } else if (mode === FA.PRUNE) {
            if ((_a = res.length) === 0) {
              return true;
            } else if (_a === 1) {
              return res[0];
            } else {
              return new AST(type, res, [startPos, this.inputPos]);
            }
          } else {
            return new AST(type, res, [startPos, this.inputPos]);
          }
        } else {
          return this.updateError();
        }
      }
    }).call(this);
    this.cache[key] = [value, this.inputPos, this.line, this.column, this.lastCR];
    return value;
  };
  InnerParser.prototype.matchState = function(index) {
    var res, state;
    state = this.faStack[this.faStack.length - 1].states[index];
    res = this.matchEdges(state.edges, 0);
    return res ? res : state.match && [];
  };
  InnerParser.prototype.matchEdges = function(edges, index) {
    var res;
    if (index === edges.length) {
      return false;
    } else {
      res = this.matchEdge(edges[index]);
      return res ? res : this.matchEdges(edges, (index + 1));
    }
  };
  InnerParser.prototype.matchEdge = function(edge) {
    var res, startCR, startCol, startLine, startPos, t, tranRes;
    startPos = this.inputPos;
    startLine = this.line;
    startCol = this.column;
    startCR = this.lastCR;
    t = edge.trans;
    res = t === -1 ? this.inputPos < this.inputLen ? this.mv() : this.updateError() : typeof t === 'string' ? this.inputPos < this.inputLen && t === this.input[this.inputPos] ? this.mv() : this.updateError() : t instanceof Array ? this.inputPos < this.inputLen && this.withinSet(t, 0, (this.input[this.inputPos].charCodeAt(0))) ? this.mv() : this.updateError() : typeof t === 'number' ? this.matchAutomaton(t) : false;
    if (res) {
      tranRes = this.matchState(edge.state);
      if (tranRes) {
        return edge.voided || res === true ? tranRes : [res].concat(tranRes);
      } else {
        this.restorePos(startPos, startLine, startCol, startCR);
        return false;
      }
    } else {
      return false;
    }
  };
  InnerParser.prototype.restorePos = function(pos, line, col, cr) {
    this.inputPos = pos;
    this.line = line;
    this.column = col;
    return (this.lastCR = cr);
  };
  InnerParser.prototype.updateError = function() {
    if (this.errorPos < this.inputPos) {
      this.errorPos = this.inputPos;
      this.errorLine = this.line;
      this.errorCol = this.column;
      this.errorNT = this.faStack[this.faStack.length - 1].type;
    }
    return false;
  };
  InnerParser.prototype.mv = function() {
    var ch;
    ch = this.input[this.inputPos];
    this.inputPos++;
    if (ch === '\r') {
      this.line++;
      this.column = 0;
      this.lastCR = true;
    } else {
      if (ch === '\n') {
        if (!this.lastCR) {
          this.line++;
          this.column = 0;
        }
      } else {
        this.column++;
      }
      this.lastCR = false;
    }
    return ch;
  };
  InnerParser.prototype.doEOFCheck = function(res) {
    return res ? this.eofCheck && this.inputPos < this.inputLen ? new ParseError(this.errorPos, this.errorLine, this.errorCol, this.errorNT) : res : new ParseError(this.errorPos, this.errorLine, this.errorCol, this.errorNT);
  };
  InnerParser.prototype.withinSet = function(set, index, c) {
    var aa;
    if (index === set.length) {
      return false;
    } else {
      aa = set[index];
      return typeof aa === 'string' ? (aa.charCodeAt(0)) === c ? true : (aa.charCodeAt(0)) < c ? this.withinSet(set, index + 1, c) : false : c >= aa[0] && c <= aa[1] ? true : c > aa[1] ? this.withinSet(set, index + 1, c) : false;
    }
  };
  namespace = {
    Edge: Edge,
    State: State,
    FA: FA,
    ParseError: ParseError,
    AST: AST,
    WaxeyeParser: WaxeyeParser
  };
  return namespace;
})();
if (typeof module !== "undefined" && module !== null) {
  module.exports.AST = waxeye.AST;
  module.exports.Edge = waxeye.Edge;
  module.exports.FA = waxeye.FA;
  module.exports.ParseError = waxeye.ParseError;
  module.exports.State = waxeye.State;
  module.exports.WaxeyeParser = waxeye.WaxeyeParser;
}
},{}],122:[function(require,module,exports){
module.exports = require('./lib/kotlin');

},{"./lib/kotlin":123}],123:[function(require,module,exports){
'use strict';var Kotlin = {};
(function() {
  function g(a, b) {
    if (null != a && null != b) {
      for (var c in b) {
        b.hasOwnProperty(c) && (a[c] = b[c]);
      }
    }
  }
  function h(a) {
    for (var b = 0;b < a.length;b++) {
      if (null != a[b] && null == a[b].$metadata$ || a[b].$metadata$.type === Kotlin.TYPE.CLASS) {
        return a[b];
      }
    }
    return null;
  }
  function e(a, b, c) {
    for (var f = 0;f < b.length;f++) {
      if (null == b[f] || null != b[f].$metadata$) {
        var d = c(b[f]), k;
        for (k in d) {
          d.hasOwnProperty(k) && (!a.hasOwnProperty(k) || a[k].$classIndex$ < d[k].$classIndex$) && (a[k] = d[k]);
        }
      }
    }
  }
  function d(a, b) {
    var c = {};
    c.baseClasses = null == a ? [] : Array.isArray(a) ? a : [a];
    c.baseClass = h(c.baseClasses);
    c.classIndex = Kotlin.newClassIndex();
    c.functions = {};
    c.properties = {};
    if (null != b) {
      for (var f in b) {
        if (b.hasOwnProperty(f)) {
          var d = b[f];
          d.$classIndex$ = c.classIndex;
          "function" === typeof d ? c.functions[f] = d : c.properties[f] = d;
        }
      }
    }
    e(c.functions, c.baseClasses, function(a) {
      return a.$metadata$.functions;
    });
    e(c.properties, c.baseClasses, function(a) {
      return a.$metadata$.properties;
    });
    return c;
  }
  function a() {
    var a = this.object_initializer$();
    Object.defineProperty(this, "object", {value:a});
    return a;
  }
  function b(a) {
    return "function" === typeof a ? a() : a;
  }
  function c(a, b) {
    if (null != a && null == a.$metadata$ || a.$metadata$.classIndex < b.$metadata$.classIndex) {
      return!1;
    }
    var f = a.$metadata$.baseClasses, d;
    for (d = 0;d < f.length;d++) {
      if (f[d] === b) {
        return!0;
      }
    }
    for (d = 0;d < f.length;d++) {
      if (c(f[d], b)) {
        return!0;
      }
    }
    return!1;
  }
  function f(a, b) {
    return function() {
      if (null !== b) {
        var c = b;
        b = null;
        c.call(a);
      }
      return a;
    };
  }
  function m(a) {
    var b = {};
    if (null == a) {
      return b;
    }
    for (var c in a) {
      a.hasOwnProperty(c) && ("function" === typeof a[c] ? a[c].type === Kotlin.TYPE.INIT_FUN ? (a[c].className = c, Object.defineProperty(b, c, {get:a[c], configurable:!0})) : b[c] = a[c] : Object.defineProperty(b, c, a[c]));
    }
    return b;
  }
  var l = function() {
    return function() {
    };
  };
  Kotlin.TYPE = {CLASS:"class", TRAIT:"trait", OBJECT:"object", INIT_FUN:"init fun"};
  Kotlin.classCount = 0;
  Kotlin.newClassIndex = function() {
    var a = Kotlin.classCount;
    Kotlin.classCount++;
    return a;
  };
  Kotlin.createClassNow = function(b, c, f, e) {
    null == c && (c = l());
    g(c, e);
    b = d(b, f);
    b.type = Kotlin.TYPE.CLASS;
    f = null !== b.baseClass ? Object.create(b.baseClass.prototype) : {};
    Object.defineProperties(f, b.properties);
    g(f, b.functions);
    f.constructor = c;
    null != b.baseClass && (c.baseInitializer = b.baseClass);
    c.$metadata$ = b;
    c.prototype = f;
    Object.defineProperty(c, "object", {get:a, configurable:!0});
    return c;
  };
  Kotlin.createObjectNow = function(a, b, c) {
    a = new (Kotlin.createClassNow(a, b, c));
    a.$metadata$ = {type:Kotlin.TYPE.OBJECT};
    return a;
  };
  Kotlin.createTraitNow = function(b, c, f) {
    var e = function() {
    };
    g(e, f);
    e.$metadata$ = d(b, c);
    e.$metadata$.type = Kotlin.TYPE.TRAIT;
    e.prototype = {};
    Object.defineProperties(e.prototype, e.$metadata$.properties);
    g(e.prototype, e.$metadata$.functions);
    Object.defineProperty(e, "object", {get:a, configurable:!0});
    return e;
  };
  Kotlin.createClass = function(a, c, f, d) {
    function e() {
      var k = Kotlin.createClassNow(b(a), c, f, d);
      Object.defineProperty(this, e.className, {value:k});
      return k;
    }
    e.type = Kotlin.TYPE.INIT_FUN;
    return e;
  };
  Kotlin.createTrait = function(a, c, f) {
    function d() {
      var e = Kotlin.createTraitNow(b(a), c, f);
      Object.defineProperty(this, d.className, {value:e});
      return e;
    }
    d.type = Kotlin.TYPE.INIT_FUN;
    return d;
  };
  Kotlin.createObject = function(a, c, f) {
    return Kotlin.createObjectNow(b(a), c, f);
  };
  Kotlin.callGetter = function(a, b, c) {
    return b.$metadata$.properties[c].get.call(a);
  };
  Kotlin.callSetter = function(a, b, c, f) {
    b.$metadata$.properties[c].set.call(a, f);
  };
  Kotlin.isType = function(a, b) {
    return null == a || null == b ? !1 : a instanceof b ? !0 : null != b && null == b.$metadata$ || b.$metadata$.type == Kotlin.TYPE.CLASS ? !1 : c(a.constructor, b);
  };
  Kotlin.modules = {};
  Kotlin.definePackage = function(a, b) {
    var c = m(b);
    return null === a ? {value:c} : {get:f(c, a)};
  };
  Kotlin.defineRootPackage = function(a, b) {
    var c = m(b);
    c.$initializer$ = null === a ? l() : a;
    return c;
  };
  Kotlin.defineModule = function(a, b) {
    if (a in Kotlin.modules) {
      throw Error("Module " + a + " is already defined");
    }
    b.$initializer$.call(b);
    Object.defineProperty(Kotlin.modules, a, {value:b});
  };
})();
(function() {
  function g(a) {
    return function() {
      throw new TypeError(void 0 !== a ? "Function " + a + " is abstract" : "Function is abstract");
    };
  }
  String.prototype.startsWith = function(a) {
    return 0 === this.indexOf(a);
  };
  String.prototype.endsWith = function(a) {
    return-1 !== this.indexOf(a, this.length - a.length);
  };
  String.prototype.contains = function(a) {
    return-1 !== this.indexOf(a);
  };
  Kotlin.equals = function(a, b) {
    return null == a ? null == b : Array.isArray(a) ? Kotlin.arrayEquals(a, b) : "object" == typeof a && void 0 !== a.equals_za3rmp$ ? a.equals_za3rmp$(b) : a === b;
  };
  Kotlin.toString = function(a) {
    return null == a ? "null" : Array.isArray(a) ? Kotlin.arrayToString(a) : a.toString();
  };
  Kotlin.arrayToString = function(a) {
    return "[" + a.join(", ") + "]";
  };
  Kotlin.intUpto = function(a, b) {
    return new Kotlin.NumberRange(a, b);
  };
  Kotlin.intDownto = function(a, b) {
    return new Kotlin.Progression(a, b, -1);
  };
  Kotlin.RuntimeException = Kotlin.createClassNow();
  Kotlin.NullPointerException = Kotlin.createClassNow();
  Kotlin.NoSuchElementException = Kotlin.createClassNow();
  Kotlin.IllegalArgumentException = Kotlin.createClassNow();
  Kotlin.IllegalStateException = Kotlin.createClassNow();
  Kotlin.UnsupportedOperationException = Kotlin.createClassNow();
  Kotlin.IOException = Kotlin.createClassNow();
  Kotlin.throwNPE = function() {
    throw new Kotlin.NullPointerException;
  };
  Kotlin.Iterator = Kotlin.createClassNow(null, null, {next:g("Iterator#next"), hasNext:g("Iterator#hasNext")});
  var h = Kotlin.createClassNow(Kotlin.Iterator, function(a) {
    this.array = a;
    this.index = 0;
  }, {next:function() {
    return this.array[this.index++];
  }, hasNext:function() {
    return this.index < this.array.length;
  }, remove:function() {
    if (0 > this.index || this.index > this.array.length) {
      throw new RangeError;
    }
    this.index--;
    this.array.splice(this.index, 1);
  }}), e = Kotlin.createClassNow(h, function(a) {
    this.list = a;
    this.size = a.size();
    this.index = 0;
  }, {next:function() {
    return this.list.get(this.index++);
  }});
  Kotlin.Collection = Kotlin.createClassNow();
  Kotlin.Enum = Kotlin.createClassNow(null, function() {
    this.ordinal$ = this.name$ = void 0;
  }, {name:function() {
    return this.name$;
  }, ordinal:function() {
    return this.ordinal$;
  }, toString:function() {
    return this.name();
  }});
  (function() {
    function a(a) {
      return this[a];
    }
    function b() {
      return this.values$;
    }
    Kotlin.createEnumEntries = function(c) {
      var f = 0, d = [], e;
      for (e in c) {
        if (c.hasOwnProperty(e)) {
          var g = c[e];
          d[f] = g;
          g.ordinal$ = f;
          g.name$ = e;
          f++;
        }
      }
      c.values$ = d;
      c.valueOf_61zpoe$ = c.valueOf = a; // FIX because Enum.valueOf() is called instead of valueOf_61zpoe$()
      c.values = b;
      return c;
    };
  })();
  Kotlin.PropertyMetadata = Kotlin.createClassNow(null, function(a) {
    this.name = a;
  });
  Kotlin.AbstractCollection = Kotlin.createClassNow(Kotlin.Collection, null, {addAll_xeylzf$:function(a) {
    var b = !1;
    for (a = a.iterator();a.hasNext();) {
      this.add_za3rmp$(a.next()) && (b = !0);
    }
    return b;
  }, removeAll_xeylzf$:function(a) {
    for (var b = !1, c = this.iterator();c.hasNext();) {
      a.contains_za3rmp$(c.next()) && (c.remove(), b = !0);
    }
    return b;
  }, retainAll_xeylzf$:function(a) {
    for (var b = !1, c = this.iterator();c.hasNext();) {
      a.contains_za3rmp$(c.next()) || (c.remove(), b = !0);
    }
    return b;
  }, containsAll_xeylzf$:function(a) {
    for (a = a.iterator();a.hasNext();) {
      if (!this.contains_za3rmp$(a.next())) {
        return!1;
      }
    }
    return!0;
  }, isEmpty:function() {
    return 0 === this.size();
  }, iterator:function() {
    return new h(this.toArray());
  }, equals_za3rmp$:function(a) {
    if (this.size() !== a.size()) {
      return!1;
    }
    var b = this.iterator();
    a = a.iterator();
    for (var c = this.size();0 < c--;) {
      if (!Kotlin.equals(b.next(), a.next())) {
        return!1;
      }
    }
    return!0;
  }, toString:function() {
    for (var a = "[", b = this.iterator(), c = !0, f = this.size();0 < f--;) {
      c ? c = !1 : a += ", ", a += b.next();
    }
    return a + "]";
  }, toJSON:function() {
    return this.toArray();
  }});
  Kotlin.AbstractList = Kotlin.createClassNow(Kotlin.AbstractCollection, null, {iterator:function() {
    return new e(this);
  }, remove_za3rmp$:function(a) {
    a = this.indexOf_za3rmp$(a);
    return-1 !== a ? (this.remove_za3lpa$(a), !0) : !1;
  }, contains_za3rmp$:function(a) {
    return-1 !== this.indexOf_za3rmp$(a);
  }});
  Kotlin.ArrayList = Kotlin.createClassNow(Kotlin.AbstractList, function() {
    this.array = [];
  }, {get_za3lpa$:function(a) {
    this.checkRange(a);
    return this.array[a];
  },get:function(a){return this.get_za3lpa$(a);}
   , set_vux3hl$:function(a, b) {
    this.checkRange(a);
    this.array[a] = b;
  }, size:function() {
    return this.array.length;
  }, iterator:function() {
    return Kotlin.arrayIterator(this.array);
  }, add_za3rmp$:function(a) {
    this.array.push(a);
    return!0;
  }, add_vux3hl$:function(a, b) {
    this.array.splice(a, 0, b);
  }, addAll_xeylzf$:function(a) {
    var b = a.iterator(), c = this.array.length;
    for (a = a.size();0 < a--;) {
      this.array[c++] = b.next();
    }
  }, remove_za3lpa$:function(a) {
    this.checkRange(a);
    return this.array.splice(a, 1)[0];
  }, clear:function() {
    this.array.length = 0;
  }, indexOf_za3rmp$:function(a) {
    for (var b = 0;b < this.array.length;b++) {
      if (Kotlin.equals(this.array[b], a)) {
        return b;
      }
    }
    return-1;
  }, lastIndexOf_za3rmp$:function(a) {
    for (var b = this.array.length - 1;0 <= b;b--) {
      if (Kotlin.equals(this.array[b], a)) {
        return b;
      }
    }
    return-1;
  }, toArray:function() {
    return this.array.slice(0);
  }, toString:function() {
    return "[" + this.array.join(", ") + "]";
  }, toJSON:function() {
    return this.array;
  }, checkRange:function(a) {
    if (0 > a || a >= this.array.length) {
      throw new RangeError;
    }
  }});
  Kotlin.Runnable = Kotlin.createClassNow(null, null, {run:g("Runnable#run")});
  Kotlin.Comparable = Kotlin.createClassNow(null, null, {compareTo:g("Comparable#compareTo")});
  Kotlin.Appendable = Kotlin.createClassNow(null, null, {append:g("Appendable#append")});
  Kotlin.Closeable = Kotlin.createClassNow(null, null, {close:g("Closeable#close")});
  Kotlin.safeParseInt = function(a) {
    a = parseInt(a, 10);
    return isNaN(a) ? null : a;
  };
  Kotlin.safeParseDouble = function(a) {
    a = parseFloat(a);
    return isNaN(a) ? null : a;
  };
  Kotlin.arrayEquals = function(a, b) {
    if (a === b) {
      return!0;
    }
    if (!Array.isArray(b) || a.length !== b.length) {
      return!1;
    }
    for (var c = 0, f = a.length;c < f;c++) {
      if (!Kotlin.equals(a[c], b[c])) {
        return!1;
      }
    }
    return!0;
  };
  Kotlin.System = function() {
    var a = "", b = function(b) {
      void 0 !== b && (a = null === b || "object" !== typeof b ? a + b : a + b.toString());
    }, c = function(b) {
      this.print(b);
      a += "\n";
    };
    return{out:function() {
      return{print:b, println:c};
    }, output:function() {
      return a;
    }, flush:function() {
      a = "";
    }};
  }();
  Kotlin.println = function(a) {
    Kotlin.System.out().println(a);
  };
  Kotlin.print = function(a) {
    Kotlin.System.out().print(a);
  };
  Kotlin.RangeIterator = Kotlin.createClassNow(Kotlin.Iterator, function(a, b, c) {
    this.start = a;
    this.end = b;
    this.increment = c;
    this.i = a;
  }, {next:function() {
    var a = this.i;
    this.i += this.increment;
    return a;
  }, hasNext:function() {
    return this.i <= this.end;
  }});
  Kotlin.NumberRange = Kotlin.createClassNow(null, function(a, b) {
    this.start = a;
    this.end = b;
    this.increment = 1;
  }, {contains:function(a) {
    return this.start <= a && a <= this.end;
  }, iterator:function() {
    return new Kotlin.RangeIterator(this.start, this.end);
  }});
  Kotlin.Progression = Kotlin.createClassNow(null, function(a, b, c) {
    this.start = a;
    this.end = b;
    this.increment = c;
  }, {iterator:function() {
    return new Kotlin.RangeIterator(this.start, this.end, this.increment);
  }});
  Kotlin.Comparator = Kotlin.createClassNow(null, null, {compare:g("Comparator#compare")});
  var d = Kotlin.createClassNow(Kotlin.Comparator, function(a) {
    this.compare = a;
  });
  Kotlin.comparator = function(a) {
    return new d(a);
  };
  Kotlin.collectionsMax = function(a, b) {
    if (a.isEmpty()) {
      throw Error();
    }
    for (var c = a.iterator(), f = c.next();c.hasNext();) {
      var d = c.next();
      0 > b.compare(f, d) && (f = d);
    }
    return f;
  };
  Kotlin.collectionsSort = function(a, b) {
    var c = void 0;
    void 0 !== b && (c = b.compare.bind(b));
    a instanceof Array && a.sort(c);
    for (var f = [], d = a.iterator();d.hasNext();) {
      f.push(d.next());
    }
    f.sort(c);
    c = 0;
    for (d = f.length;c < d;c++) {
      a.set_vux3hl$(c, f[c]);
    }
  };
  Kotlin.copyToArray = function(a) {
    var b = [];
    for (a = a.iterator();a.hasNext();) {
      b.push(a.next());
    }
    return b;
  };
  Kotlin.StringBuilder = Kotlin.createClassNow(null, function() {
    this.string = "";
  }, {append:function(a) {
    this.string += a.toString();
    return this;
  }, toString:function() {
    return this.string;
  }});
  Kotlin.splitString = function(a, b, c) {
    return a.split(RegExp(b), c);
  };
  Kotlin.nullArray = function(a) {
    for (var b = [];0 < a;) {
      b[--a] = null;
    }
    return b;
  };
  Kotlin.numberArrayOfSize = function(a) {
    return Kotlin.arrayFromFun(a, function() {
      return 0;
    });
  };
  Kotlin.charArrayOfSize = function(a) {
    return Kotlin.arrayFromFun(a, function() {
      return "\x00";
    });
  };
  Kotlin.booleanArrayOfSize = function(a) {
    return Kotlin.arrayFromFun(a, function() {
      return!1;
    });
  };
  Kotlin.arrayFromFun = function(a, b) {
    for (var c = Array(a), d = 0;d < a;d++) {
      c[d] = b(d);
    }
    return c;
  };
  Kotlin.arrayIndices = function(a) {
    return new Kotlin.NumberRange(0, a.length - 1);
  };
  Kotlin.arrayIterator = function(a) {
    return new h(a);
  };
  Kotlin.jsonFromTuples = function(a) {
    for (var b = a.length, c = {};0 < b;) {
      --b, c[a[b][0]] = a[b][1];
    }
    return c;
  };
  Kotlin.jsonAddProperties = function(a, b) {
    for (var c in b) {
      b.hasOwnProperty(c) && (a[c] = b[c]);
    }
    return a;
  };
})();
(function() {
  function g(a) {
    if ("string" == typeof a) {
      return a;
    }
    if ("function" == typeof a.hashCode) {
      return a = a.hashCode(), "string" == typeof a ? a : g(a);
    }
    if ("function" == typeof a.toString) {
      return a.toString();
    }
    try {
      return String(a);
    } catch (b) {
      return Object.prototype.toString.call(a);
    }
  }
  function h(a, b) {
    return a.equals(b);
  }
  function e(a, b) {
    return "function" == typeof b.equals ? b.equals(a) : a === b;
  }
  function d(a) {
    return function(b) {
      if (null === b) {
        throw Error("null is not a valid " + a);
      }
      if ("undefined" == typeof b) {
        throw Error(a + " must not be undefined");
      }
    };
  }
  function a(a, b, c, d) {
    this[0] = a;
    this.entries = [];
    this.addEntry(b, c);
    null !== d && (this.getEqualityFunction = function() {
      return d;
    });
  }
  function b(a) {
    return function(b) {
      for (var c = this.entries.length, d, f = this.getEqualityFunction(b);c--;) {
        if (d = this.entries[c], f(b, d[0])) {
          switch(a) {
            case n:
              return!0;
            case s:
              return d;
            case t:
              return[c, d[1]];
          }
        }
      }
      return!1;
    };
  }
  function c(a) {
    return function(b) {
      for (var c = b.length, d = 0, f = this.entries.length;d < f;++d) {
        b[c + d] = this.entries[d][a];
      }
    };
  }
  function f(b, c) {
    var d = b[c];
    return d && d instanceof a ? d : null;
  }
  var m = "function" == typeof Array.prototype.splice ? function(a, b) {
    a.splice(b, 1);
  } : function(a, b) {
    var c, d, f;
    if (b === a.length - 1) {
      a.length = b;
    } else {
      for (c = a.slice(b + 1), a.length = b, d = 0, f = c.length;d < f;++d) {
        a[b + d] = c[d];
      }
    }
  }, l = d("key"), r = d("value"), n = 0, s = 1, t = 2;
  a.prototype = {getEqualityFunction:function(a) {
    return "function" == typeof a.equals ? h : e;
  }, getEntryForKey:b(s), getEntryAndIndexForKey:b(t), removeEntryForKey:function(a) {
    return(a = this.getEntryAndIndexForKey(a)) ? (m(this.entries, a[0]), a[1]) : null;
  }, addEntry:function(a, b) {
    this.entries[this.entries.length] = [a, b];
  }, keys:c(0), values:c(1), getEntries:function(a) {
    for (var b = a.length, c = 0, d = this.entries.length;c < d;++c) {
      a[b + c] = this.entries[c].slice(0);
    }
  }, containsKey_za3rmp$:b(n), containsValue_za3rmp$:function(a) {
    for (var b = this.entries.length;b--;) {
      if (a === this.entries[b][1]) {
        return!0;
      }
    }
    return!1;
  }};
  var u = function(b, c) {
    var d = this, e = [], h = {}, p = "function" == typeof b ? b : g, n = "function" == typeof c ? c : null;
    this.put_wn2jw4$ = function(b, c) {
      l(b);
      r(c);
      var d = p(b), g, k = null;
      (g = f(h, d)) ? (d = g.getEntryForKey(b)) ? (k = d[1], d[1] = c) : g.addEntry(b, c) : (g = new a(d, b, c, n), e[e.length] = g, h[d] = g);
      return k;
    };
    this.get_za3rmp$ = function(a) {
      l(a);
      var b = p(a);
      if (b = f(h, b)) {
        if (a = b.getEntryForKey(a)) {
          return a[1];
        }
      }
      return null;
    };
    this.containsKey_za3rmp$ = function(a) {
      l(a);
      var b = p(a);
      return(b = f(h, b)) ? b.containsKey_za3rmp$(a) : !1;
    };
    this.containsValue_za3rmp$ = function(a) {
      r(a);
      for (var b = e.length;b--;) {
        if (e[b].containsValue_za3rmp$(a)) {
          return!0;
        }
      }
      return!1;
    };
    this.clear = function() {
      e.length = 0;
      h = {};
    };
    this.isEmpty = function() {
      return!e.length;
    };
    var q = function(a) {
      return function() {
        for (var b = [], c = e.length;c--;) {
          e[c][a](b);
        }
        return b;
      };
    };
    this._keys = q("keys");
    this._values = q("values");
    this._entries = q("getEntries");
    this.values = function() {
      for (var a = this._values(), b = a.length, c = new Kotlin.ArrayList;b--;) {
        c.add_za3rmp$(a[b]);
      }
      return c;
    };
    this.remove_za3rmp$ = function(a) {
      l(a);
      var b = p(a), c = null, d = f(h, b);
      if (d && (c = d.removeEntryForKey(a), null !== c && !d.entries.length)) {
        a: {
          for (a = e.length;a--;) {
            if (d = e[a], b === d[0]) {
              break a;
            }
          }
          a = null;
        }
        m(e, a);
        delete h[b];
      }
      return c;
    };
    this.size = function() {
      for (var a = 0, b = e.length;b--;) {
        a += e[b].entries.length;
      }
      return a;
    };
    this.each = function(a) {
      for (var b = d._entries(), c = b.length, e;c--;) {
        e = b[c], a(e[0], e[1]);
      }
    };
    this.putAll_za3j1t$ = function(a, b) {
      for (var c = a._entries(), e, f, g, h = c.length, k = "function" == typeof b;h--;) {
        e = c[h], f = e[0], e = e[1], k && (g = d.get(f)) && (e = b(f, g, e)), d.put_wn2jw4$(f, e);
      }
    };
    this.clone = function() {
      var a = new u(b, c);
      a.putAll_za3j1t$(d);
      return a;
    };
    this.keySet = function() {
      for (var a = new Kotlin.ComplexHashSet, b = this._keys(), c = b.length;c--;) {
        a.add_za3rmp$(b[c]);
      }
      return a;
    };
  };
  Kotlin.HashTable = u;
})();
Kotlin.Map = Kotlin.createClassNow();
Kotlin.HashMap = Kotlin.createClassNow(Kotlin.Map, function() {
  Kotlin.HashTable.call(this);
});
Kotlin.ComplexHashMap = Kotlin.HashMap;
(function() {
  var g = Kotlin.createClassNow(Kotlin.Iterator, function(e, d) {
    this.map = e;
    this.keys = d;
    this.size = d.length;
    this.index = 0;
  }, {next:function() {
    return this.map[this.keys[this.index++]];
  }, hasNext:function() {
    return this.index < this.size;
  }}), h = Kotlin.createClassNow(Kotlin.Collection, function(e) {
    this.map = e;
  }, {iterator:function() {
    return new g(this.map.map, Object.keys(this.map.map));
  }, isEmpty:function() {
    return 0 === this.map.$size;
  }, contains:function(e) {
    return this.map.containsValue_za3rmp$(e);
  }});
  Kotlin.PrimitiveHashMap = Kotlin.createClassNow(Kotlin.Map, function() {
    this.$size = 0;
    this.map = {};
  }, {size:function() {
    return this.$size;
  }, isEmpty:function() {
    return 0 === this.$size;
  }, containsKey_za3rmp$:function(e) {
    return void 0 !== this.map[e];
  }, containsValue_za3rmp$:function(e) {
    var d = this.map, a;
    for (a in d) {
      if (d.hasOwnProperty(a) && d[a] === e) {
        return!0;
      }
    }
    return!1;
  }, get_za3rmp$:function(e) {
    return this.map[e];
  }, put_wn2jw4$:function(e, d) {
    var a = this.map[e];
    this.map[e] = void 0 === d ? null : d;
    void 0 === a && this.$size++;
    return a;
  }, remove_za3rmp$:function(e) {
    var d = this.map[e];
    void 0 !== d && (delete this.map[e], this.$size--);
    return d;
  }, clear:function() {
    this.$size = 0;
    this.map = {};
  }, putAll_za3j1t$:function(e) {
    e = e.map;
    for (var d in e) {
      e.hasOwnProperty(d) && (this.map[d] = e[d], this.$size++);
    }
  }, keySet:function() {
    var e = new Kotlin.PrimitiveHashSet, d = this.map, a;
    for (a in d) {
      d.hasOwnProperty(a) && e.add_za3rmp$(a);
    }
    return e;
  }, values:function() {
    return new h(this);
  }, toJSON:function() {
    return this.map;
  }});
})();
Kotlin.Set = Kotlin.createClassNow(Kotlin.Collection);
var SetIterator = Kotlin.createClassNow(Kotlin.Iterator, function(g) {
  this.set = g;
  this.keys = g.toArray();
  this.index = 0;
}, {next:function() {
  return this.keys[this.index++];
}, hasNext:function() {
  return this.index < this.keys.length;
}, remove:function() {
  this.set.remove_za3rmp$(this.keys[this.index - 1]);
}});
Kotlin.PrimitiveHashSet = Kotlin.createClassNow(Kotlin.AbstractCollection, function() {
  this.$size = 0;
  this.map = {};
}, {contains_s9cetl$:function(g) {
  return!0 === this.map[g];
}, iterator:function() {
  return new SetIterator(this);
}, size:function() {
    return this.$size;
}, add_za3rmp$:function(g) {
  var h = this.map[g];
  this.map[g] = !0;
  if (!0 === h) {
    return!1;
  }
  this.$size++;
  return!0;
}, remove_za3rmp$:function(g) {
  return!0 === this.map[g] ? (delete this.map[g], this.$size--, !0) : !1;
}, clear:function() {
  this.$size = 0;
  this.map = {};
}, toArray:function() {
  return Object.keys(this.map);
}});
(function() {
  function g(h, e) {
    var d = new Kotlin.HashTable(h, e);
    this.addAll_xeylzf$ = Kotlin.AbstractCollection.prototype.addAll_xeylzf$;
    this.removeAll_xeylzf$ = Kotlin.AbstractCollection.prototype.removeAll_xeylzf$;
    this.retainAll_xeylzf$ = Kotlin.AbstractCollection.prototype.retainAll_xeylzf$;
    this.containsAll_xeylzf$ = Kotlin.AbstractCollection.prototype.containsAll_xeylzf$;
    this.add_za3rmp$ = function(a) {
      return!d.put_wn2jw4$(a, !0);
    };
    this.toArray = function() {
      return d._keys();
    };
    this.iterator = function() {
      return new SetIterator(this);
    };
    this.remove_za3rmp$ = function(a) {
      return null != d.remove_za3rmp$(a);
    };
    this.contains_za3rmp$ = function(a) {
      return d.containsKey_za3rmp$(a);
    };
    this.clear = function() {
      d.clear();
    };
    this.size = function() {
      return d.size();
    };
    this.isEmpty = function() {
      return d.isEmpty();
    };
    this.clone = function() {
      var a = new g(h, e);
      a.addAll_xeylzf$(d.keys());
      return a;
    };
    this.equals = function(a) {
      if (null === a || void 0 === a) {
        return!1;
      }
      if (this.size() === a.size()) {
        var b = this.iterator();
        for (a = a.iterator();;) {
          var c = b.hasNext(), d = a.hasNext();
          if (c != d) {
            break;
          }
          if (d) {
            if (c = b.next(), d = a.next(), !Kotlin.equals(c, d)) {
              break;
            }
          } else {
            return!0;
          }
        }
      }
      return!1;
    };
    this.toString = function() {
      for (var a = "[", b = this.iterator(), c = !0;b.hasNext();) {
        c ? c = !1 : a += ", ", a += b.next();
      }
      return a + "]";
    };
    this.intersection = function(a) {
      var b = new g(h, e);
      a = a.values();
      for (var c = a.length, f;c--;) {
        f = a[c], d.containsKey_za3rmp$(f) && b.add_za3rmp$(f);
      }
      return b;
    };
    this.union = function(a) {
      var b = this.clone();
      a = a.values();
      for (var c = a.length, e;c--;) {
        e = a[c], d.containsKey_za3rmp$(e) || b.add_za3rmp$(e);
      }
      return b;
    };
    this.isSubsetOf = function(a) {
      for (var b = d.keys(), c = b.length;c--;) {
        if (!a.contains_za3rmp$(b[c])) {
          return!1;
        }
      }
      return!0;
    };
  }
  Kotlin.HashSet = Kotlin.createClassNow(Kotlin.Set, function() {
    g.call(this);
  });
  Kotlin.ComplexHashSet = Kotlin.HashSet;
})();
module.exports = Kotlin;
},{}],124:[function(require,module,exports){
(function (global){
if (!global.Kotlin) {
    global.Kotlin = require('kevoree-kotlin');
}
var Kotlin = global.Kotlin;

if (!Kotlin.modules['kevoree']) {
  var _ = Kotlin.defineRootPackage(null, /** @lends _ */ {
    org: Kotlin.definePackage(null, /** @lends _.org */ {
      kevoree: Kotlin.definePackage(null, /** @lends _.org.kevoree */ {
        DataType: Kotlin.createClass(function () {
          return [Kotlin.Enum];
        }, function $fun() {
          $fun.baseInitializer.call(this);
        }, null, /** @lends _.org.kevoree.DataType */ {
          object_initializer$: function () {
            return Kotlin.createEnumEntries({
              BYTE: new _.org.kevoree.DataType(),
              SHORT: new _.org.kevoree.DataType(),
              INT: new _.org.kevoree.DataType(),
              LONG: new _.org.kevoree.DataType(),
              FLOAT: new _.org.kevoree.DataType(),
              DOUBLE: new _.org.kevoree.DataType(),
              BOOLEAN: new _.org.kevoree.DataType(),
              CHAR: new _.org.kevoree.DataType(),
              STRING: new _.org.kevoree.DataType()
            });
          }
        }),
        ComponentInstance: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ComponentInstance.prototype */ {
          provided: {
            get: function () {
              return this.$provided_2hpw3s$;
            },
            set: function (tmp$0) {
              this.$provided_2hpw3s$ = tmp$0;
            }
          },
          required: {
            get: function () {
              return this.$required_7c57n8$;
            },
            set: function (tmp$0) {
              this.$required_7c57n8$ = tmp$0;
            }
          }
        }),
        Instance: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Instance.prototype */ {
          started: {
            get: function () {
              return this.$started_sh883l$;
            },
            set: function (tmp$0) {
              this.$started_sh883l$ = tmp$0;
            }
          },
          typeDefinition: {
            get: function () {
              return this.$typeDefinition_ezyus3$;
            },
            set: function (tmp$0) {
              this.$typeDefinition_ezyus3$ = tmp$0;
            }
          },
          dictionary: {
            get: function () {
              return this.$dictionary_pt7ca2$;
            },
            set: function (tmp$0) {
              this.$dictionary_pt7ca2$ = tmp$0;
            }
          },
          fragmentDictionary: {
            get: function () {
              return this.$fragmentDictionary_6cu6ii$;
            },
            set: function (tmp$0) {
              this.$fragmentDictionary_6cu6ii$ = tmp$0;
            }
          },
          metaData: {
            get: function () {
              return this.$metaData_18932n$;
            },
            set: function (tmp$0) {
              this.$metaData_18932n$ = tmp$0;
            }
          }
        }),
        Port: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Port.prototype */ {
          bindings: {
            get: function () {
              return this.$bindings_5hhece$;
            },
            set: function (tmp$0) {
              this.$bindings_5hhece$ = tmp$0;
            }
          },
          portTypeRef: {
            get: function () {
              return this.$portTypeRef_mhir4s$;
            },
            set: function (tmp$0) {
              this.$portTypeRef_mhir4s$ = tmp$0;
            }
          }
        }),
        ComponentType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ComponentType.prototype */ {
          required: {
            get: function () {
              return this.$required_oda9db$;
            },
            set: function (tmp$0) {
              this.$required_oda9db$ = tmp$0;
            }
          },
          provided: {
            get: function () {
              return this.$provided_ejf5mb$;
            },
            set: function (tmp$0) {
              this.$provided_ejf5mb$ = tmp$0;
            }
          }
        }),
        TypeDefinition: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.TypeDefinition.prototype */ {
          version: {
            get: function () {
              return this.$version_tm0unk$;
            },
            set: function (tmp$0) {
              this.$version_tm0unk$ = tmp$0;
            }
          },
          abstract: {
            get: function () {
              return this.$abstract_ez9r92$;
            },
            set: function (tmp$0) {
              this.$abstract_ez9r92$ = tmp$0;
            }
          },
          deployUnits: {
            get: function () {
              return this.$deployUnits_y68grk$;
            },
            set: function (tmp$0) {
              this.$deployUnits_y68grk$ = tmp$0;
            }
          },
          superTypes: {
            get: function () {
              return this.$superTypes_dv6lpi$;
            },
            set: function (tmp$0) {
              this.$superTypes_dv6lpi$ = tmp$0;
            }
          },
          dictionaryType: {
            get: function () {
              return this.$dictionaryType_vkfvko$;
            },
            set: function (tmp$0) {
              this.$dictionaryType_vkfvko$ = tmp$0;
            }
          },
          metaData: {
            get: function () {
              return this.$metaData_jxmodz$;
            },
            set: function (tmp$0) {
              this.$metaData_jxmodz$ = tmp$0;
            }
          }
        }),
        PortTypeRef: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.PortTypeRef.prototype */ {
          optional: {
            get: function () {
              return this.$optional_x07kgh$;
            },
            set: function (tmp$0) {
              this.$optional_x07kgh$ = tmp$0;
            }
          },
          noDependency: {
            get: function () {
              return this.$noDependency_t9zxol$;
            },
            set: function (tmp$0) {
              this.$noDependency_t9zxol$ = tmp$0;
            }
          },
          ref: {
            get: function () {
              return this.$ref_yibe1w$;
            },
            set: function (tmp$0) {
              this.$ref_yibe1w$ = tmp$0;
            }
          },
          mappings: {
            get: function () {
              return this.$mappings_sheb7w$;
            },
            set: function (tmp$0) {
              this.$mappings_sheb7w$ = tmp$0;
            }
          }
        }),
        ContainerNode: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ContainerNode.prototype */ {
          components: {
            get: function () {
              return this.$components_easq5i$;
            },
            set: function (tmp$0) {
              this.$components_easq5i$ = tmp$0;
            }
          },
          hosts: {
            get: function () {
              return this.$hosts_f0e4hl$;
            },
            set: function (tmp$0) {
              this.$hosts_f0e4hl$ = tmp$0;
            }
          },
          host: {
            get: function () {
              return this.$host_fjzar0$;
            },
            set: function (tmp$0) {
              this.$host_fjzar0$ = tmp$0;
            }
          },
          groups: {
            get: function () {
              return this.$groups_vg5qvs$;
            },
            set: function (tmp$0) {
              this.$groups_vg5qvs$ = tmp$0;
            }
          },
          networkInformation: {
            get: function () {
              return this.$networkInformation_nv4882$;
            },
            set: function (tmp$0) {
              this.$networkInformation_nv4882$ = tmp$0;
            }
          }
        }),
        Group: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Group.prototype */ {
          subNodes: {
            get: function () {
              return this.$subNodes_lc0dmh$;
            },
            set: function (tmp$0) {
              this.$subNodes_lc0dmh$ = tmp$0;
            }
          }
        }),
        NetworkInfo: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.NetworkInfo.prototype */ {
          values: {
            get: function () {
              return this.$values_itr2zx$;
            },
            set: function (tmp$0) {
              this.$values_itr2zx$ = tmp$0;
            }
          }
        }),
        ContainerRoot: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ContainerRoot.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_ejvotm$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_ejvotm$ = tmp$0;
            }
          },
          nodes: {
            get: function () {
              return this.$nodes_c2xjm5$;
            },
            set: function (tmp$0) {
              this.$nodes_c2xjm5$ = tmp$0;
            }
          },
          repositories: {
            get: function () {
              return this.$repositories_z79tl8$;
            },
            set: function (tmp$0) {
              this.$repositories_z79tl8$ = tmp$0;
            }
          },
          hubs: {
            get: function () {
              return this.$hubs_6hj9z2$;
            },
            set: function (tmp$0) {
              this.$hubs_6hj9z2$ = tmp$0;
            }
          },
          mBindings: {
            get: function () {
              return this.$mBindings_gns4jb$;
            },
            set: function (tmp$0) {
              this.$mBindings_gns4jb$ = tmp$0;
            }
          },
          groups: {
            get: function () {
              return this.$groups_g3uzy0$;
            },
            set: function (tmp$0) {
              this.$groups_g3uzy0$ = tmp$0;
            }
          },
          packages: {
            get: function () {
              return this.$packages_1mi63z$;
            },
            set: function (tmp$0) {
              this.$packages_1mi63z$ = tmp$0;
            }
          }
        }),
        Repository: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Repository.prototype */ {
          url: {
            get: function () {
              return this.$url_htkyl8$;
            },
            set: function (tmp$0) {
              this.$url_htkyl8$ = tmp$0;
            }
          }
        }),
        Channel: Kotlin.createTrait(function () {
          return [_.org.kevoree.Instance, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Channel.prototype */ {
          bindings: {
            get: function () {
              return this.$bindings_ty2776$;
            },
            set: function (tmp$0) {
              this.$bindings_ty2776$ = tmp$0;
            }
          }
        }),
        MBinding: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.MBinding.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_fziggz$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_fziggz$ = tmp$0;
            }
          },
          port: {
            get: function () {
              return this.$port_6otxb6$;
            },
            set: function (tmp$0) {
              this.$port_6otxb6$ = tmp$0;
            }
          },
          hub: {
            get: function () {
              return this.$hub_ijo8js$;
            },
            set: function (tmp$0) {
              this.$hub_ijo8js$ = tmp$0;
            }
          }
        }),
        Package: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Package.prototype */ {
          packages: {
            get: function () {
              return this.$packages_v2u0ry$;
            },
            set: function (tmp$0) {
              this.$packages_v2u0ry$ = tmp$0;
            }
          },
          typeDefinitions: {
            get: function () {
              return this.$typeDefinitions_exad6t$;
            },
            set: function (tmp$0) {
              this.$typeDefinitions_exad6t$ = tmp$0;
            }
          },
          deployUnits: {
            get: function () {
              return this.$deployUnits_xu9pd3$;
            },
            set: function (tmp$0) {
              this.$deployUnits_xu9pd3$ = tmp$0;
            }
          }
        }),
        NamedElement: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.NamedElement.prototype */ {
          name: {
            get: function () {
              return this.$name_mc5v37$;
            },
            set: function (tmp$0) {
              this.$name_mc5v37$ = tmp$0;
            }
          }
        }),
        DeployUnit: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.DeployUnit.prototype */ {
          version: {
            get: function () {
              return this.$version_m3ipvy$;
            },
            set: function (tmp$0) {
              this.$version_m3ipvy$ = tmp$0;
            }
          },
          hashcode: {
            get: function () {
              return this.$hashcode_a0cemd$;
            },
            set: function (tmp$0) {
              this.$hashcode_a0cemd$ = tmp$0;
            }
          },
          url: {
            get: function () {
              return this.$url_i45wyt$;
            },
            set: function (tmp$0) {
              this.$url_i45wyt$ = tmp$0;
            }
          },
          filters: {
            get: function () {
              return this.$filters_25emcx$;
            },
            set: function (tmp$0) {
              this.$filters_25emcx$ = tmp$0;
            }
          },
          requiredLibs: {
            get: function () {
              return this.$requiredLibs_vqdz55$;
            },
            set: function (tmp$0) {
              this.$requiredLibs_vqdz55$ = tmp$0;
            }
          }
        }),
        PortType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.PortType.prototype */ {
          synchrone: {
            get: function () {
              return this.$synchrone_81cijd$;
            },
            set: function (tmp$0) {
              this.$synchrone_81cijd$ = tmp$0;
            }
          }
        }),
        Dictionary: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Dictionary.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_4n99az$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_4n99az$ = tmp$0;
            }
          },
          values: {
            get: function () {
              return this.$values_relsch$;
            },
            set: function (tmp$0) {
              this.$values_relsch$ = tmp$0;
            }
          }
        }),
        Value: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Value.prototype */ {
          value: {
            get: function () {
              return this.$value_mehebp$;
            },
            set: function (tmp$0) {
              this.$value_mehebp$ = tmp$0;
            }
          }
        }),
        FragmentDictionary: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.Dictionary, _.org.kevoree.modeling.api.KMFContainer];
        }),
        DictionaryType: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.DictionaryType.prototype */ {
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_i5cet1$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_i5cet1$ = tmp$0;
            }
          },
          attributes: {
            get: function () {
              return this.$attributes_ajawmc$;
            },
            set: function (tmp$0) {
              this.$attributes_ajawmc$ = tmp$0;
            }
          }
        }),
        DictionaryAttribute: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.DictionaryAttribute.prototype */ {
          optional: {
            get: function () {
              return this.$optional_q3pn27$;
            },
            set: function (tmp$0) {
              this.$optional_q3pn27$ = tmp$0;
            }
          },
          state: {
            get: function () {
              return this.$state_o1zrsg$;
            },
            set: function (tmp$0) {
              this.$state_o1zrsg$ = tmp$0;
            }
          },
          datatype: {
            get: function () {
              return this.$datatype_4t2ef9$;
            },
            set: function (tmp$0) {
              this.$datatype_4t2ef9$ = tmp$0;
            }
          },
          fragmentDependant: {
            get: function () {
              return this.$fragmentDependant_tefpca$;
            },
            set: function (tmp$0) {
              this.$fragmentDependant_tefpca$ = tmp$0;
            }
          },
          defaultValue: {
            get: function () {
              return this.$defaultValue_5tt7f5$;
            },
            set: function (tmp$0) {
              this.$defaultValue_5tt7f5$ = tmp$0;
            }
          }
        }),
        TypedElement: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.TypedElement.prototype */ {
          genericTypes: {
            get: function () {
              return this.$genericTypes_32ol0l$;
            },
            set: function (tmp$0) {
              this.$genericTypes_32ol0l$ = tmp$0;
            }
          }
        }),
        PortTypeMapping: Kotlin.createTrait(function () {
          return [_.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.PortTypeMapping.prototype */ {
          beanMethodName: {
            get: function () {
              return this.$beanMethodName_sgmp8w$;
            },
            set: function (tmp$0) {
              this.$beanMethodName_sgmp8w$ = tmp$0;
            }
          },
          serviceMethodName: {
            get: function () {
              return this.$serviceMethodName_kdedgt$;
            },
            set: function (tmp$0) {
              this.$serviceMethodName_kdedgt$ = tmp$0;
            }
          },
          paramTypes: {
            get: function () {
              return this.$paramTypes_fy6jxc$;
            },
            set: function (tmp$0) {
              this.$paramTypes_fy6jxc$ = tmp$0;
            }
          },
          generated_KMF_ID: {
            get: function () {
              return this.$generated_KMF_ID_690oqi$;
            },
            set: function (tmp$0) {
              this.$generated_KMF_ID_690oqi$ = tmp$0;
            }
          }
        }),
        ServicePortType: Kotlin.createTrait(function () {
          return [_.org.kevoree.PortType, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ServicePortType.prototype */ {
          interface: {
            get: function () {
              return this.$interface_wlgea$;
            },
            set: function (tmp$0) {
              this.$interface_wlgea$ = tmp$0;
            }
          },
          operations: {
            get: function () {
              return this.$operations_ggf0fx$;
            },
            set: function (tmp$0) {
              this.$operations_ggf0fx$ = tmp$0;
            }
          }
        }),
        Operation: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Operation.prototype */ {
          parameters: {
            get: function () {
              return this.$parameters_nryb4m$;
            },
            set: function (tmp$0) {
              this.$parameters_nryb4m$ = tmp$0;
            }
          },
          returnType: {
            get: function () {
              return this.$returnType_98xmpi$;
            },
            set: function (tmp$0) {
              this.$returnType_98xmpi$ = tmp$0;
            }
          }
        }),
        Parameter: Kotlin.createTrait(function () {
          return [_.org.kevoree.NamedElement, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.Parameter.prototype */ {
          order: {
            get: function () {
              return this.$order_tm5icw$;
            },
            set: function (tmp$0) {
              this.$order_tm5icw$ = tmp$0;
            }
          },
          type: {
            get: function () {
              return this.$type_3moby0$;
            },
            set: function (tmp$0) {
              this.$type_3moby0$ = tmp$0;
            }
          }
        }),
        MessagePortType: Kotlin.createTrait(function () {
          return [_.org.kevoree.PortType, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.MessagePortType.prototype */ {
          filters: {
            get: function () {
              return this.$filters_a0gt4a$;
            },
            set: function (tmp$0) {
              this.$filters_a0gt4a$ = tmp$0;
            }
          }
        }),
        ChannelType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }, /** @lends _.org.kevoree.ChannelType.prototype */ {
          lowerBindings: {
            get: function () {
              return this.$lowerBindings_8zhvff$;
            },
            set: function (tmp$0) {
              this.$lowerBindings_8zhvff$ = tmp$0;
            }
          },
          upperBindings: {
            get: function () {
              return this.$upperBindings_ffz8ee$;
            },
            set: function (tmp$0) {
              this.$upperBindings_ffz8ee$ = tmp$0;
            }
          },
          lowerFragments: {
            get: function () {
              return this.$lowerFragments_r3d52k$;
            },
            set: function (tmp$0) {
              this.$lowerFragments_r3d52k$ = tmp$0;
            }
          },
          upperFragments: {
            get: function () {
              return this.$upperFragments_32uu0b$;
            },
            set: function (tmp$0) {
              this.$upperFragments_32uu0b$ = tmp$0;
            }
          }
        }),
        GroupType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }),
        NodeType: Kotlin.createTrait(function () {
          return [_.org.kevoree.TypeDefinition, _.org.kevoree.modeling.api.KMFContainer];
        }),
        log: Kotlin.definePackage(function () {
          this.Log = Kotlin.createObject(null, function () {
            this.LEVEL_NONE = 6;
            this.LEVEL_ERROR = 5;
            this.LEVEL_WARN = 4;
            this.LEVEL_INFO = 3;
            this.LEVEL_DEBUG = 2;
            this.LEVEL_TRACE = 1;
            this.$level_qhmnt5$ = this.LEVEL_INFO;
            this._ERROR_oj0992$ = this.level <= this.LEVEL_ERROR;
            this._WARN_qp2148$ = this.level <= this.LEVEL_WARN;
            this._INFO_qpapkw$ = this.level <= this.LEVEL_INFO;
            this._DEBUG_oi7u3l$ = this.level <= this.LEVEL_DEBUG;
            this._TRACE_or8t8z$ = this.level <= this.LEVEL_TRACE;
            this.logger = new _.org.kevoree.log.Logger();
            this.beginParam = '{';
            this.endParam = '}';
          }, {
            level: {
              get: function () {
                return this.$level_qhmnt5$;
              },
              set: function (newLevel) {
                this.$level_qhmnt5$ = newLevel;
                this._ERROR_oj0992$ = newLevel <= this.LEVEL_ERROR;
                this._WARN_qp2148$ = newLevel <= this.LEVEL_WARN;
                this._INFO_qpapkw$ = newLevel <= this.LEVEL_INFO;
                this._DEBUG_oi7u3l$ = newLevel <= this.LEVEL_DEBUG;
                this._TRACE_or8t8z$ = newLevel <= this.LEVEL_TRACE;
              }
            },
            NONE: function () {
              this.level = this.LEVEL_NONE;
            },
            ERROR: function () {
              this.level = this.LEVEL_ERROR;
            },
            WARN: function () {
              this.level = this.LEVEL_WARN;
            },
            INFO: function () {
              this.level = this.LEVEL_INFO;
            },
            DEBUG: function () {
              this.level = this.LEVEL_DEBUG;
            },
            TRACE: function () {
              this.level = this.LEVEL_TRACE;
            },
            processMessage: function (message, p1, p2, p3, p4, p5) {
              if (p1 == null) {
                return message;
              }
              var buffer = new Kotlin.StringBuilder();
              var previousCharfound = false;
              var param = 0;
              var i = 0;
              while (i < message.length) {
                var currentChar = message.charAt(i);
                if (previousCharfound) {
                  if (currentChar === this.endParam) {
                    param++;
                    {
                      if (param === 1) {
                        buffer = new Kotlin.StringBuilder();
                        buffer.append(message.substring(0, i - 1));
                        buffer.append((p1 != null ? p1 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 2) {
                        buffer.append((p2 != null ? p2 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 3) {
                        buffer.append((p3 != null ? p3 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 4) {
                        buffer.append((p4 != null ? p4 : Kotlin.throwNPE()).toString());
                      }
                       else if (param === 5) {
                        buffer.append((p5 != null ? p5 : Kotlin.throwNPE()).toString());
                      }
                       else {
                      }
                    }
                    previousCharfound = false;
                  }
                   else {
                    if (buffer != null) {
                      message.charAt(i - 1);
                      buffer.append(currentChar);
                    }
                    previousCharfound = false;
                  }
                }
                 else {
                  if (currentChar === this.beginParam) {
                    previousCharfound = true;
                  }
                   else {
                    if (buffer != null) {
                      buffer.append(currentChar);
                    }
                  }
                }
                i = i + 1;
              }
              if (buffer != null) {
                return buffer.toString();
              }
               else {
                return message;
              }
            },
            error_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._ERROR_oj0992$) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            error: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._ERROR_oj0992$) {
                this.internal_error(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_error: function (message, ex) {
              this.logger.log(this.LEVEL_ERROR, message, ex);
            },
            warn_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._WARN_qp2148$) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            warn: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._WARN_qp2148$) {
                this.internal_warn(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_warn: function (message, ex) {
              this.logger.log(this.LEVEL_WARN, message, ex);
            },
            info_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._INFO_qpapkw$) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            info: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._INFO_qpapkw$) {
                this.internal_info(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_info: function (message, ex) {
              this.logger.log(this.LEVEL_INFO, message, ex);
            },
            debug_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._DEBUG_oi7u3l$) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            debug: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._DEBUG_oi7u3l$) {
                this.internal_debug(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_debug: function (message, ex) {
              this.logger.log(this.LEVEL_DEBUG, message, ex);
            },
            trace_1: function (message, ex, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._TRACE_or8t8z$) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), ex);
              }
            },
            trace: function (message, p1, p2, p3, p4, p5) {
              if (p1 === void 0)
                p1 = null;
              if (p2 === void 0)
                p2 = null;
              if (p3 === void 0)
                p3 = null;
              if (p4 === void 0)
                p4 = null;
              if (p5 === void 0)
                p5 = null;
              if (this._TRACE_or8t8z$) {
                this.internal_trace(this.processMessage(message, p1, p2, p3, p4, p5), null);
              }
            },
            internal_trace: function (message, ex) {
              this.logger.log(this.LEVEL_TRACE, message, ex);
            }
          });
        }, /** @lends _.org.kevoree.log */ {
          Logger: Kotlin.createClass(null, function () {
            this.firstLogTime = (new Date()).getTime();
            this.error_msg = ' ERROR: ';
            this.warn_msg = ' WARN: ';
            this.info_msg = ' INFO: ';
            this.debug_msg = ' DEBUG: ';
            this.trace_msg = ' TRACE: ';
            this.category = null;
          }, /** @lends _.org.kevoree.log.Logger.prototype */ {
            setCategory: function (category) {
              this.category = category;
            },
            log: function (level, message, ex) {
              var builder = new Kotlin.StringBuilder();
              var time = (new Date()).getTime() - this.firstLogTime;
              var minutes = time / (1000 * 60) | 0;
              var seconds = (time / 1000 | 0) % 60;
              if (minutes <= 9)
                builder.append('0');
              builder.append(minutes.toString());
              builder.append(':');
              if (seconds <= 9)
                builder.append('0');
              builder.append(seconds.toString());
              {
                if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                  builder.append(this.error_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                  builder.append(this.warn_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                  builder.append(this.info_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                  builder.append(this.debug_msg);
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                  builder.append(this.trace_msg);
                }
                 else {
                }
              }
              if (this.category != null) {
                builder.append('[');
                var tmp$0;
                builder.append(((tmp$0 = this.category) != null ? tmp$0 : Kotlin.throwNPE()).toString());
                builder.append('] ');
              }
              builder.append(message);
              if (ex != null) {
                builder.append(Kotlin.toString(ex.getMessage()));
              }
              {
                if (level === _.org.kevoree.log.Log.LEVEL_ERROR) {
                  console.error(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_WARN) {
                  console.warn(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_INFO) {
                  console.info(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_DEBUG) {
                  console.log(builder.toString());
                }
                 else if (level === _.org.kevoree.log.Log.LEVEL_TRACE) {
                  console.log(builder.toString());
                }
                 else {
                }
              }
            }
          })
        }),
        container: Kotlin.definePackage(function () {
          this.cleanCacheVisitor = Kotlin.createObject(function () {
            return [_.org.kevoree.modeling.api.util.ModelVisitor];
          }, function $fun() {
            $fun.baseInitializer.call(this);
          }, {
            visit: function (elem, refNameInParent, parent) {
            },
            endVisitElem: function (elem) {
              elem.path_cache = null;
            }
          });
        }, /** @lends _.org.kevoree.container */ {
          KMFContainerImpl: Kotlin.createTrait(function () {
            return [_.org.kevoree.modeling.api.util.InboundRefAware, _.org.kevoree.modeling.api.KMFContainer];
          }, /** @lends _.org.kevoree.container.KMFContainerImpl.prototype */ {
            internal_hashcode_fdnqaa$: {
              get: function () {
                return this.$internal_hashcode_fdnqaa$;
              },
              set: function (tmp$0) {
                this.$internal_hashcode_fdnqaa$ = tmp$0;
              }
            },
            hashCode: function () {
              if (this.internal_hashcode_fdnqaa$ == null) {
                this.internal_hashcode_fdnqaa$ = Math.floor(Math.random() * 10000000) + (new Date()).getTime();
              }
              var tmp$0;
              return (tmp$0 = this.internal_hashcode_fdnqaa$) != null ? tmp$0 : Kotlin.throwNPE();
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_xvryed$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_xvryed$ = tmp$0;
              }
            },
            isDeleted: function () {
              return this.internal_is_deleted;
            },
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_v316j1$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_v316j1$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_clnprc$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_clnprc$ = tmp$0;
              }
            },
            eContainer: function () {
              return this.internal_eContainer;
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_2rxjyb$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_2rxjyb$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_bdx8q0$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_bdx8q0$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_uv4k8b$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_uv4k8b$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_czt5qs$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_czt5qs$ = tmp$0;
              }
            },
            addInboundReference: function (path, refName) {
              if (!this.internal_deleteInProgress) {
                _.kotlin.getOrPut_ynyybx$(this.internal_inboundReferences, path, _.org.kevoree.container.KMFContainerImpl.addInboundReference$f).add_za3rmp$(refName);
              }
            },
            removeInboundReference: function (path, refName) {
              if (!this.internal_deleteInProgress) {
                var refs = this.internal_inboundReferences.get_za3rmp$(path);
                if (refs != null) {
                  if (refs.size() > 1) {
                    refs.remove_za3rmp$(refName);
                  }
                   else {
                    this.internal_inboundReferences.remove_za3rmp$(path);
                  }
                }
              }
            },
            advertiseInboundRefs: function (action, value) {
              {
                var tmp$0 = this.internal_inboundReferences.keySet().iterator();
                while (tmp$0.hasNext()) {
                  var inboundElem = tmp$0.next();
                  if (!inboundElem.isDeleted()) {
                    var tmp$1;
                    var refList = (tmp$1 = this.internal_inboundReferences.get_za3rmp$(inboundElem)) != null ? tmp$1 : Kotlin.throwNPE();
                    {
                      var tmp$2 = refList.iterator();
                      while (tmp$2.hasNext()) {
                        var ref = tmp$2.next();
                        inboundElem.reflexiveMutator(action, ref, value, false, true);
                      }
                    }
                  }
                }
              }
            },
            setRecursiveReadOnly: function () {
              if (Kotlin.equals(this.internal_recursive_readOnlyElem, true)) {
                return;
              }
              this.setInternalRecursiveReadOnly();
              var recVisitor = _.org.kevoree.container.KMFContainerImpl.setRecursiveReadOnly$f();
              this.visit(recVisitor, true, true, true);
              this.setInternalReadOnly();
            },
            setInternalReadOnly: function () {
              this.internal_readOnlyElem = true;
            },
            setInternalRecursiveReadOnly: function () {
              this.internal_recursive_readOnlyElem = true;
            },
            getRefInParent: function () {
              return this.internal_containmentRefName;
            },
            isReadOnly: function () {
              return this.internal_readOnlyElem;
            },
            isRecursiveReadOnly: function () {
              return this.internal_recursive_readOnlyElem;
            },
            setEContainer: function (container, unsetCmd, refNameInParent) {
              if (this.internal_readOnlyElem) {
                return;
              }
              if (Kotlin.equals(this.eContainer(), container)) {
                return;
              }
              this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              var tempUnsetCmd = this.internal_unsetCmd;
              this.internal_unsetCmd = null;
              if (tempUnsetCmd != null) {
                tempUnsetCmd.run();
              }
              this.internal_eContainer = container;
              this.internal_unsetCmd = unsetCmd;
              this.internal_containmentRefName = refNameInParent;
              this.path_cache = null;
            },
            select: function (query) {
              if (Kotlin.equals(this.path(), '/') && query.startsWith('/')) {
                return _.org.kevoree.modeling.api.util.Selector.select(this, query.substring(1));
              }
               else {
                return _.org.kevoree.modeling.api.util.Selector.select(this, query);
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_dtvvyj$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_dtvvyj$ = tmp$0;
              }
            },
            fireModelEvent: function (evt) {
              if (this.internal_modelElementListeners != null) {
                var tmp$0;
                {
                  var tmp$1 = ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var lst = tmp$1.next();
                    lst.elementChanged(evt);
                  }
                }
              }
              this.fireModelEventOnTree(evt);
            },
            addModelElementListener: function (lst) {
              if (this.internal_modelElementListeners == null) {
                this.internal_modelElementListeners = new Kotlin.ArrayList();
              }
              var tmp$0;
              ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$(lst);
            },
            removeModelElementListener: function (lst) {
              if (this.internal_modelElementListeners != null) {
                var tmp$0, tmp$1;
                ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove_za3rmp$(lst);
                if (((tmp$1 = this.internal_modelElementListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
                  this.internal_modelElementListeners = null;
                }
              }
            },
            removeAllModelElementListeners: function () {
              if (this.internal_modelElementListeners != null) {
                var tmp$0;
                ((tmp$0 = this.internal_modelElementListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
                this.internal_modelElementListeners = null;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_uom9b$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_uom9b$ = tmp$0;
              }
            },
            fireModelEventOnTree: function (evt) {
              if (this.internal_modelTreeListeners != null) {
                var tmp$0;
                {
                  var tmp$1 = ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).iterator();
                  while (tmp$1.hasNext()) {
                    var lst = tmp$1.next();
                    lst.elementChanged(evt);
                  }
                }
              }
              if (this.eContainer() != null) {
                var tmp$2;
                ((tmp$2 = this.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).fireModelEventOnTree(evt);
              }
            },
            addModelTreeListener: function (lst) {
              if (this.internal_modelTreeListeners == null) {
                this.internal_modelTreeListeners = new Kotlin.ArrayList();
              }
              var tmp$0;
              ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$(lst);
            },
            removeModelTreeListener: function (lst) {
              if (this.internal_modelTreeListeners != null) {
                var tmp$0, tmp$1;
                ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).remove_za3rmp$(lst);
                if (((tmp$1 = this.internal_modelTreeListeners) != null ? tmp$1 : Kotlin.throwNPE()).isEmpty()) {
                  this.internal_modelTreeListeners = null;
                }
              }
            },
            removeAllModelTreeListeners: function () {
              if (this.internal_modelTreeListeners != null) {
                var tmp$0;
                ((tmp$0 = this.internal_modelTreeListeners) != null ? tmp$0 : Kotlin.throwNPE()).clear();
                this.internal_modelElementListeners = null;
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
            },
            visitAttributes: function (visitor) {
            },
            internal_visit: function (visitor, internalElem, recursive, containedReference, nonContainedReference, refName) {
              if (internalElem != null) {
                if (nonContainedReference && recursive) {
                  var elemPath = internalElem.path();
                  var tmp$0, tmp$1;
                  if (visitor.alreadyVisited != null && ((tmp$0 = visitor.alreadyVisited) != null ? tmp$0 : Kotlin.throwNPE()).containsKey_za3rmp$(elemPath)) {
                    return;
                  }
                  if (visitor.alreadyVisited == null) {
                    visitor.alreadyVisited = new Kotlin.PrimitiveHashMap();
                  }
                  ((tmp$1 = visitor.alreadyVisited) != null ? tmp$1 : Kotlin.throwNPE()).put_wn2jw4$(elemPath, internalElem);
                }
                visitor.visit(internalElem, refName, this);
                if (!visitor.visitStopped) {
                  if (recursive && (visitor.visitChildren || visitor.visitReferences)) {
                    var visitSubReferences = nonContainedReference && visitor.visitReferences;
                    var visitSubChilds = containedReference && visitor.visitChildren;
                    internalElem.visit(visitor, recursive, visitSubChilds, visitSubReferences);
                  }
                  visitor.visitChildren = true;
                  visitor.visitReferences = true;
                }
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_5gbaib$;
              },
              set: function (tmp$0) {
                this.$path_cache_5gbaib$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_vns4l3$;
              },
              set: function (tmp$0) {
                this.$key_cache_vns4l3$ = tmp$0;
              }
            },
            isRoot: function () {
              return this.is_root;
            },
            is_root: {
              get: function () {
                return this.$is_root_v4yqtw$;
              },
              set: function (tmp$0) {
                this.$is_root_v4yqtw$ = tmp$0;
              }
            },
            path: function () {
              if (this.path_cache != null) {
                var tmp$0;
                return (tmp$0 = this.path_cache) != null ? tmp$0 : Kotlin.throwNPE();
              }
              var container = this.eContainer();
              if (container != null) {
                var parentPath = container.path();
                if (Kotlin.equals(parentPath, '')) {
                  var tmp$1;
                  this.path_cache = ((tmp$1 = this.internal_containmentRefName) != null ? tmp$1 : Kotlin.throwNPE()) + '[' + this.internalGetKey() + ']';
                }
                 else if (Kotlin.equals(parentPath, '/')) {
                  var tmp$2;
                  this.path_cache = parentPath + ((tmp$2 = this.internal_containmentRefName) != null ? tmp$2 : Kotlin.throwNPE()) + '[' + this.internalGetKey() + ']';
                }
                 else {
                  var tmp$3;
                  this.path_cache = parentPath + '/' + ((tmp$3 = this.internal_containmentRefName) != null ? tmp$3 : Kotlin.throwNPE()) + '[' + this.internalGetKey() + ']';
                }
              }
               else {
                if (this.is_root) {
                  this.path_cache = '/';
                }
                 else {
                  this.path_cache = '';
                }
              }
              var tmp$4;
              return (tmp$4 = this.path_cache) != null ? tmp$4 : Kotlin.throwNPE();
            },
            modelEquals: function (similarObj) {
              if (similarObj == null) {
                return false;
              }
              if (Kotlin.equals(this, similarObj)) {
                return true;
              }
              if (!Kotlin.equals(similarObj.metaClassName(), this.metaClassName())) {
                return false;
              }
              var values = new Kotlin.PrimitiveHashMap();
              var attVisitor = _.org.kevoree.container.KMFContainerImpl.modelEquals$f(values);
              this.visitAttributes(attVisitor);
              similarObj.visitAttributes(attVisitor);
              if (!values.isEmpty()) {
                return false;
              }
              var payload = '';
              var refVisitor = _.org.kevoree.container.KMFContainerImpl.modelEquals$f_0(values, payload);
              this.visit(refVisitor, false, false, true);
              similarObj.visit(refVisitor, false, false, true);
              if (!values.isEmpty()) {
                return false;
              }
              return true;
            },
            deepModelEquals: function (similarObj) {
              if (!this.modelEquals(similarObj)) {
                return false;
              }
              var similarRoot = similarObj != null ? similarObj : Kotlin.throwNPE();
              while (similarRoot.eContainer() != null) {
                var tmp$0;
                similarRoot = (tmp$0 = similarRoot.eContainer()) != null ? tmp$0 : Kotlin.throwNPE();
              }
              var resultTest = {v: true};
              var finalRoot = similarRoot;
              var objVisitor = _.org.kevoree.container.KMFContainerImpl.deepModelEquals$f(finalRoot, resultTest);
              this.visit(objVisitor, true, true, false);
              return resultTest.v;
            },
            findByPath: function (query) {
              if (Kotlin.equals(query, this.path())) {
                return this;
              }
              if (Kotlin.equals(this.path(), '/') && query.startsWith('/')) {
                return this.findByPath(query.substring(1));
              }
              var firstSepIndex = _.js.indexOf_960177$(query, '[');
              if (firstSepIndex === -1) {
                if (query.length === 0) {
                  return this;
                }
                 else {
                  return null;
                }
              }
              var queryID = '';
              var extraReadChar = 2;
              var relationName = query.substring(0, _.js.indexOf_960177$(query, '['));
              if (_.js.indexOf_960177$(query, '{') === firstSepIndex + 1) {
                queryID = query.substring(_.js.indexOf_960177$(query, '{') + 1, _.js.indexOf_960177$(query, '}'));
                extraReadChar = extraReadChar + 2;
              }
               else {
                var indexFirstClose = _.js.indexOf_960177$(query, ']');
                while (indexFirstClose + 1 < query.length && query.charAt(indexFirstClose + 1) !== '/') {
                  indexFirstClose = _.js.indexOf_orzsrp$(query, ']', indexFirstClose + 1);
                  if (indexFirstClose === -1) {
                    return null;
                  }
                }
                queryID = query.substring(_.js.indexOf_960177$(query, '[') + 1, indexFirstClose);
              }
              var subquery = query.substring(relationName.length + queryID.length + extraReadChar, query.length);
              if (_.js.indexOf_960177$(subquery, '/') !== -1) {
                subquery = subquery.substring(_.js.indexOf_960177$(subquery, '/') + 1, subquery.length);
              }
              var objFound = this.findByID(relationName, queryID);
              if (!Kotlin.equals(subquery, '') && objFound != null) {
                return objFound.findByPath(subquery);
              }
               else {
                return objFound;
              }
            },
            createTraces: function (similarObj, isInter, isMerge, onlyReferences, onlyAttributes) {
              var traces = new Kotlin.ArrayList();
              var values = new Kotlin.PrimitiveHashMap();
              if (onlyAttributes) {
                var attVisitorFill = _.org.kevoree.container.KMFContainerImpl.createTraces$f(values);
                this.visitAttributes(attVisitorFill);
                var attVisitor = _.org.kevoree.container.KMFContainerImpl.createTraces$f_0(values, isInter, traces, this);
                if (similarObj != null) {
                  similarObj.visitAttributes(attVisitor);
                }
                if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
                  {
                    var tmp$0 = values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var hashLoopRes = tmp$0.next();
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this.path(), hashLoopRes, null, null, null));
                    }
                  }
                }
              }
              if (onlyReferences) {
                var payload = '';
                var refVisitorFill = _.org.kevoree.container.KMFContainerImpl.createTraces$f_1(values, payload);
                this.visit(refVisitorFill, false, false, true);
                var refVisitor = _.org.kevoree.container.KMFContainerImpl.createTraces$f_2(values, isInter, traces, this);
                if (similarObj != null) {
                  similarObj.visit(refVisitor, false, false, true);
                }
                if (!isInter && !isMerge && _.kotlin.get_size(values) !== 0) {
                  {
                    var tmp$1 = values.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var hashLoopRes_0 = tmp$1.next();
                      var splittedVal = Kotlin.splitString(hashLoopRes_0, '_');
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(this.path(), splittedVal[0], splittedVal[1]));
                    }
                  }
                }
              }
              return traces;
            },
            toTraces: function (attributes, references) {
              var traces = new Kotlin.ArrayList();
              if (attributes) {
                var attVisitorFill = _.org.kevoree.container.KMFContainerImpl.toTraces$f(traces, this);
                this.visitAttributes(attVisitorFill);
              }
              if (references) {
                var refVisitorFill = _.org.kevoree.container.KMFContainerImpl.toTraces$f_0(traces, this);
                this.visit(refVisitorFill, false, true, true);
              }
              return traces;
            },
            visitNotContained: function (visitor) {
              this.visit(visitor, false, false, true);
            },
            visitContained: function (visitor) {
              this.visit(visitor, false, true, false);
            },
            visitReferences: function (visitor) {
              this.visit(visitor, false, true, true);
            },
            deepVisitNotContained: function (visitor) {
              this.visit(visitor, true, false, true);
            },
            deepVisitContained: function (visitor) {
              this.visit(visitor, true, true, false);
            },
            deepVisitReferences: function (visitor) {
              this.visit(visitor, true, true, true);
            }
          }, /** @lends _.org.kevoree.container.KMFContainerImpl */ {
            addInboundReference$f: function () {
              return new Kotlin.PrimitiveHashSet();
            },
            setRecursiveReadOnly$f: function () {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  if (elem.isRecursiveReadOnly()) {
                    this.noChildrenVisit();
                  }
                   else {
                    elem.setInternalRecursiveReadOnly();
                    elem.setInternalReadOnly();
                  }
                }
              });
            },
            modelEquals$f: function (values) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  if (values.containsKey_za3rmp$(name)) {
                    if (Kotlin.equals(values.get_za3rmp$(name), value != null ? value.toString() : null)) {
                      values.remove_za3rmp$(name);
                    }
                  }
                   else {
                    values.put_wn2jw4$(name, value != null ? value.toString() : null);
                  }
                }
              });
            },
            modelEquals$f_0: function (values, payload) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var concatedKey = refNameInParent + '_' + elem.path();
                  if (values.containsKey_za3rmp$(concatedKey)) {
                    values.remove_za3rmp$(concatedKey);
                  }
                   else {
                    values.put_wn2jw4$(concatedKey, payload);
                  }
                }
              });
            },
            deepModelEquals$f: function (finalRoot, resultTest) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var similarSubObj = finalRoot.findByPath(elem.path());
                  if (!elem.modelEquals(similarSubObj)) {
                    resultTest.v = false;
                    this.stopVisit();
                  }
                }
              });
            },
            createTraces$f: function (values) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  values.put_wn2jw4$(name, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
                }
              });
            },
            createTraces$f_0: function (values, isInter, traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  var attVal2 = _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value);
                  if (Kotlin.equals(values.get_za3rmp$(name), attVal2)) {
                    if (isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this$KMFContainerImpl.path(), name, null, attVal2, null));
                    }
                  }
                   else {
                    if (!isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this$KMFContainerImpl.path(), name, null, attVal2, null));
                    }
                  }
                  values.remove_za3rmp$(name);
                }
              });
            },
            createTraces$f_1: function (values, payload) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var concatedKey = refNameInParent + '_' + elem.path();
                  values.put_wn2jw4$(concatedKey, payload);
                }
              });
            },
            createTraces$f_2: function (values, isInter, traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  var concatedKey = refNameInParent + '_' + elem.path();
                  if (values.get_za3rmp$(concatedKey) != null) {
                    if (isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(this$KMFContainerImpl.path(), refNameInParent, elem.path(), null));
                    }
                  }
                   else {
                    if (!isInter) {
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(this$KMFContainerImpl.path(), refNameInParent, elem.path(), null));
                    }
                  }
                  values.remove_za3rmp$(concatedKey);
                }
              });
            },
            toTraces$f: function (traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, null, {
                visit: function (value, name, parent) {
                  traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(this$KMFContainerImpl.path(), name, null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value), null));
                }
              });
            },
            toTraces$f_0: function (traces, this$KMFContainerImpl) {
              return Kotlin.createObject(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, {
                visit: function (elem, refNameInParent, parent) {
                  traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(this$KMFContainerImpl.path(), refNameInParent, elem.path(), null));
                }
              });
            }
          }),
          RemoveFromContainerCommand: Kotlin.createClass(null, function (target, mutatorType, refName, element) {
            this.target = target;
            this.mutatorType = mutatorType;
            this.refName = refName;
            this.element = element;
          }, /** @lends _.org.kevoree.container.RemoveFromContainerCommand.prototype */ {
            run: function () {
              if (!this.target.isDeleted()) {
                this.target.reflexiveMutator(this.mutatorType, this.refName, this.element, true, true);
              }
            }
          })
        }),
        impl: Kotlin.definePackage(null, /** @lends _.org.kevoree.impl */ {
          MBindingImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.MBinding, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_z1m2g3$ = null;
            this.$internal_containmentRefName_eftcj$ = null;
            this.$internal_unsetCmd_w1bnki$ = null;
            this.$internal_readOnlyElem_u2nvzi$ = false;
            this.$internal_recursive_readOnlyElem_wmnhfj$ = false;
            this.$internal_inboundReferences_48ffeo$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_9zuf2a$ = false;
            this.$internal_is_deleted_x6r7np$ = false;
            this.$is_root_raraxi$ = false;
            this.$internal_modelElementListeners_ovnd8r$ = null;
            this.$internal_modelTreeListeners_2bor1j$ = null;
            this.$path_cache_1c2e9j$ = null;
            this.$key_cache_3y1q8x$ = null;
            this.$generated_KMF_ID_4131jt$ = '' + Math.random() + (new Date()).getTime();
            this.$port_xzicf2$ = null;
            this.$hub_5og40c$ = null;
          }, /** @lends _.org.kevoree.impl.MBindingImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_z1m2g3$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_z1m2g3$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_eftcj$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_eftcj$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_w1bnki$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_w1bnki$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_u2nvzi$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_u2nvzi$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_wmnhfj$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_wmnhfj$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_48ffeo$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_48ffeo$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_9zuf2a$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_9zuf2a$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_x6r7np$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_x6r7np$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_raraxi$;
              },
              set: function (tmp$0) {
                this.$is_root_raraxi$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_ovnd8r$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_ovnd8r$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_2bor1j$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_2bor1j$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_1c2e9j$;
              },
              set: function (tmp$0) {
                this.$path_cache_1c2e9j$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_3y1q8x$;
              },
              set: function (tmp$0) {
                this.$key_cache_3y1q8x$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.port != null) {
                var tmp$0;
                ((tmp$0 = this.port) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_port);
                this.port = null;
              }
              if (this.hub != null) {
                var tmp$1;
                ((tmp$1 = this.hub) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hub);
                this.hub = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_4131jt$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_4131jt$;
                this.$generated_KMF_ID_4131jt$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            port: {
              get: function () {
                return this.$port_xzicf2$;
              },
              set: function (portP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_port(portP, true, true);
              }
            },
            internal_port: function (portP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$port_xzicf2$, portP)) {
                if (setOpposite) {
                  if (this.$port_xzicf2$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$port_xzicf2$) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (portP != null) {
                    portP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$port_xzicf2$;
                if (portP != null) {
                  (portP != null ? portP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_port);
                }
                 else {
                  if (this.$port_xzicf2$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$port_xzicf2$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_port);
                  }
                }
                this.$port_xzicf2$ = portP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_port, portP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withPort: function (ref) {
              return this;
            },
            hub: {
              get: function () {
                return this.$hub_5og40c$;
              },
              set: function (hubP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_hub(hubP, true, true);
              }
            },
            internal_hub: function (hubP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$hub_5og40c$, hubP)) {
                if (setOpposite) {
                  if (this.$hub_5og40c$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$hub_5og40c$) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                  if (hubP != null) {
                    hubP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_bindings, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$hub_5og40c$;
                if (hubP != null) {
                  (hubP != null ? hubP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_hub);
                }
                 else {
                  if (this.$hub_5og40c$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$hub_5og40c$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hub);
                  }
                }
                this.$hub_5og40c$ = hubP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hub, hubP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withHub: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_port) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_port(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_port(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_port(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_hub) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_hub(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_hub(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_hub(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_port) {
                  var objFound = this.port;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_hub) {
                  var objFound_0 = this.hub;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_port, _.org.kevoree.util.Constants.org_kevoree_Port)) {
                  this.internal_visit(visitor, this.port, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_port);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_port);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hub, _.org.kevoree.util.Constants.org_kevoree_Channel)) {
                  this.internal_visit(visitor, this.hub, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hub);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hub);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MBinding;
            }
          }),
          ParameterImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Parameter, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_vv9dd0$ = null;
            this.$internal_containmentRefName_ivuvlg$ = null;
            this.$internal_unsetCmd_dv8oyv$ = null;
            this.$internal_readOnlyElem_9ick9z$ = false;
            this.$internal_recursive_readOnlyElem_e2jwhy$ = false;
            this.$internal_inboundReferences_ura3rt$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_e1nyyt$ = false;
            this.$internal_is_deleted_t2ilho$ = false;
            this.$is_root_ggf0wt$ = false;
            this.$internal_modelElementListeners_5y73xg$ = null;
            this.$internal_modelTreeListeners_gylxwg$ = null;
            this.$path_cache_t5jwrm$ = null;
            this.$key_cache_pjuc2w$ = null;
            this.$name_8gjzyd$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$order_ludsj0$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$type_8gobqs$ = null;
          }, /** @lends _.org.kevoree.impl.ParameterImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_vv9dd0$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_vv9dd0$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_ivuvlg$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_ivuvlg$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_dv8oyv$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_dv8oyv$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_9ick9z$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_9ick9z$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_e2jwhy$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_e2jwhy$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_ura3rt$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_ura3rt$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_e1nyyt$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_e1nyyt$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_t2ilho$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_t2ilho$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_ggf0wt$;
              },
              set: function (tmp$0) {
                this.$is_root_ggf0wt$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_5y73xg$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_5y73xg$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_gylxwg$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_gylxwg$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_t5jwrm$;
              },
              set: function (tmp$0) {
                this.$path_cache_t5jwrm$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_pjuc2w$;
              },
              set: function (tmp$0) {
                this.$key_cache_pjuc2w$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.type != null) {
                var tmp$0;
                ((tmp$0 = this.type) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_type);
                this.type = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_8gjzyd$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_8gjzyd$;
                this.$name_8gjzyd$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withOrder: function (p) {
              this.order = p;
              return this;
            },
            order: {
              get: function () {
                return this.$order_ludsj0$;
              },
              set: function (iP) {
                this.internal_order(iP, true);
              }
            },
            internal_order: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.order) {
                var oldPath = this.path();
                var kmf_previousVal = this.$order_ludsj0$;
                this.$order_ludsj0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_order, this.order, kmf_previousVal, this, oldPath));
                }
              }
            },
            type: {
              get: function () {
                return this.$type_8gobqs$;
              },
              set: function (typeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_type(typeP, true, true);
              }
            },
            internal_type: function (typeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$type_8gobqs$, typeP)) {
                var kmf_previousVal = this.$type_8gobqs$;
                if (typeP != null) {
                  (typeP != null ? typeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_type);
                }
                 else {
                  if (this.$type_8gobqs$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$type_8gobqs$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_type);
                  }
                }
                this.$type_8gobqs$ = typeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_type, typeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withType: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_order) {
                  this.internal_order(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_type) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_type(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_type(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_type(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_type) {
                  var objFound = this.type;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_type, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  this.internal_visit(visitor, this.type, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_type);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_type);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.order, _.org.kevoree.util.Constants.Att_order, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Parameter;
            }
          }),
          GroupImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Group, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_6cdzuu$ = null;
            this.$internal_containmentRefName_vebtpy$ = null;
            this.$internal_unsetCmd_veg8dr$ = null;
            this.$internal_readOnlyElem_8pw15d$ = false;
            this.$internal_recursive_readOnlyElem_wbvzx8$ = false;
            this.$internal_inboundReferences_wq9wfx$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_wmbq8r$ = false;
            this.$internal_is_deleted_954rq6$ = false;
            this.$is_root_hr8or1$ = false;
            this.$internal_modelElementListeners_2mjqeq$ = null;
            this.$internal_modelTreeListeners_xbkrey$ = null;
            this.$path_cache_juq6q4$ = null;
            this.$key_cache_yezpfi$ = null;
            this.$name_6q21d$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_cjcnfn$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._subNodes = new _.java.util.concurrent.ConcurrentHashMap();
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition_48mgnl$ = null;
            this.$dictionary_801d16$ = null;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.GroupImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_6cdzuu$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_6cdzuu$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_vebtpy$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_vebtpy$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_veg8dr$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_veg8dr$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_8pw15d$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_8pw15d$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_wbvzx8$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_wbvzx8$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_wq9wfx$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_wq9wfx$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_wmbq8r$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_wmbq8r$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_954rq6$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_954rq6$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_hr8or1$;
              },
              set: function (tmp$0) {
                this.$is_root_hr8or1$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_2mjqeq$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_2mjqeq$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_xbkrey$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_xbkrey$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_juq6q4$;
              },
              set: function (tmp$0) {
                this.$path_cache_juq6q4$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_yezpfi$;
              },
              set: function (tmp$0) {
                this.$key_cache_yezpfi$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              this.removeAllSubNodes();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_6q21d$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_6q21d$;
                this.$name_6q21d$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_cjcnfn$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_cjcnfn$;
                this.$started_cjcnfn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            subNodes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._subNodes.values());
              },
              set: function (subNodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (subNodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_subNodes(subNodesP, true, true);
              }
            },
            internal_subNodes: function (subNodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._subNodes.values(), subNodesP)) {
                var kmf_previousVal = this._subNodes;
                this.internal_removeAllSubNodes(true, false);
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._subNodes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSubNodes: function (subNodesP) {
              var _key_ = subNodesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._subNodes.containsKey_za3rmp$(_key_)) {
                this._subNodes.put_wn2jw4$(_key_, subNodesP);
                subNodesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
              }
            },
            addSubNodes: function (subNodesP) {
              this.internal_addSubNodes(subNodesP, true, true);
              return this;
            },
            addAllSubNodes: function (subNodesP) {
              this.internal_addAllSubNodes(subNodesP, true, true);
              return this;
            },
            internal_addSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSubNodes(subNodesP);
              if (setOpposite) {
                subNodesP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, null, this, this.path()));
              }
            },
            internal_addAllSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = subNodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSubNodes(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = subNodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSubNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, null, this, this.path()));
              }
            },
            removeSubNodes: function (subNodesP) {
              this.internal_removeSubNodes(subNodesP, true, true);
              return this;
            },
            removeAllSubNodes: function () {
              this.internal_removeAllSubNodes(true, true);
              return this;
            },
            internal_removeSubNodes: function (subNodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._subNodes.size() !== 0 && this._subNodes.containsKey_za3rmp$(subNodesP.internalGetKey())) {
                var previousPathToBeRemoved = subNodesP.path();
                this._subNodes.remove_za3rmp$(subNodesP.internalGetKey());
                subNodesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, subNodesP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  subNodesP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                }
              }
            },
            internal_removeAllSubNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.subNodes;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_subNodes);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, this, false, fireEvents);
                  }
                }
              }
              this._subNodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_subNodes, temp_els, null, this, this.path()));
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_48mgnl$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_48mgnl$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_48mgnl$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_48mgnl$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_48mgnl$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_48mgnl$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_801d16$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_801d16$, dictionaryP)) {
                if (this.$dictionary_801d16$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_801d16$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_801d16$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_801d16$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_801d16$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_801d16$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_subNodes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSubNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllSubNodes(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._subNodes.size() !== 0 && this._subNodes.containsKey_za3rmp$(value)) {
                        var obj_1 = this._subNodes.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._subNodes.remove_za3rmp$(value);
                        this._subNodes.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findSubNodesByID: function (key) {
              return this._subNodes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_subNodes) {
                  return this.findSubNodesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_subNodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  {
                    var tmp$2 = this._subNodes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._subNodes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_subNodes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_subNodes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Group;
            }
          }),
          ChannelImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Channel, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_cchzb2$ = null;
            this.$internal_containmentRefName_90vn2m$ = null;
            this.$internal_unsetCmd_4t8cab$ = null;
            this.$internal_readOnlyElem_h5s8p9$ = false;
            this.$internal_recursive_readOnlyElem_9xg1b4$ = false;
            this.$internal_inboundReferences_d3fkxt$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_x70dk1$ = false;
            this.$internal_is_deleted_9jr7fq$ = false;
            this.$is_root_v6dcw9$ = false;
            this.$internal_modelElementListeners_yynwp6$ = null;
            this.$internal_modelTreeListeners_73mpdm$ = null;
            this.$path_cache_lhhprs$ = null;
            this.$key_cache_5vawfy$ = null;
            this.$name_j026ln$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_pyhbkv$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._bindings = new _.java.util.concurrent.ConcurrentHashMap();
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition_57fvd9$ = null;
            this.$dictionary_xc6jgq$ = null;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ChannelImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_cchzb2$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_cchzb2$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_90vn2m$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_90vn2m$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_4t8cab$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_4t8cab$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_h5s8p9$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_h5s8p9$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_9xg1b4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_9xg1b4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_d3fkxt$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_d3fkxt$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_x70dk1$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_x70dk1$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_9jr7fq$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_9jr7fq$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_v6dcw9$;
              },
              set: function (tmp$0) {
                this.$is_root_v6dcw9$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_yynwp6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_yynwp6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_73mpdm$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_73mpdm$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_lhhprs$;
              },
              set: function (tmp$0) {
                this.$path_cache_lhhprs$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_5vawfy$;
              },
              set: function (tmp$0) {
                this.$key_cache_5vawfy$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              this.removeAllBindings();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_j026ln$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_j026ln$;
                this.$name_j026ln$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_pyhbkv$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_pyhbkv$;
                this.$started_pyhbkv$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                var kmf_previousVal = this._bindings;
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = bindingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey_za3rmp$(_key_)) {
                this._bindings.put_wn2jw4$(_key_, bindingsP);
                bindingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
              return this;
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
              return this;
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
              return this;
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
              return this;
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(bindingsP.internalGetKey())) {
                var previousPathToBeRemoved = bindingsP.path();
                this._bindings.remove_za3rmp$(bindingsP.internalGetKey());
                bindingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.bindings;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_hub, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els, null, this, this.path()));
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_57fvd9$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_57fvd9$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_57fvd9$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_57fvd9$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_57fvd9$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_57fvd9$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_xc6jgq$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_xc6jgq$, dictionaryP)) {
                if (this.$dictionary_xc6jgq$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_xc6jgq$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_xc6jgq$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_xc6jgq$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_xc6jgq$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_xc6jgq$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllBindings(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(value)) {
                        var obj_1 = this._bindings.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._bindings.remove_za3rmp$(value);
                        this._bindings.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findBindingsByID: function (key) {
              return this._bindings.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                  return this.findBindingsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding)) {
                  {
                    var tmp$2 = this._bindings.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._bindings.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Channel;
            }
          }),
          ServicePortTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ServicePortType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_t4v1n$ = null;
            this.$internal_containmentRefName_upkekb$ = null;
            this.$internal_unsetCmd_8nhco0$ = null;
            this.$internal_readOnlyElem_o9efxc$ = false;
            this.$internal_recursive_readOnlyElem_n0v3f1$ = false;
            this.$internal_inboundReferences_sfntse$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_t3ukok$ = false;
            this.$internal_is_deleted_1zlwtp$ = false;
            this.$is_root_hm7xek$ = false;
            this.$internal_modelElementListeners_l9972b$ = null;
            this.$internal_modelTreeListeners_ssbgvb$ = null;
            this.$path_cache_fvb3ph$ = null;
            this.$key_cache_qe1lf3$ = null;
            this.$name_lcvr6m$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_osjjtx$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_maxytn$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone_8uttoy$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$interface_8uxxve$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$dictionaryType_lwo0sj$ = null;
            this._operations = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllOperationsCurrentlyProcessing = false;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ServicePortTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_t4v1n$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_t4v1n$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_upkekb$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_upkekb$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_8nhco0$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_8nhco0$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_o9efxc$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_o9efxc$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_n0v3f1$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_n0v3f1$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_sfntse$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_sfntse$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_t3ukok$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_t3ukok$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_1zlwtp$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_1zlwtp$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_hm7xek$;
              },
              set: function (tmp$0) {
                this.$is_root_hm7xek$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_l9972b$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_l9972b$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ssbgvb$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ssbgvb$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_fvb3ph$;
              },
              set: function (tmp$0) {
                this.$path_cache_fvb3ph$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_qe1lf3$;
              },
              set: function (tmp$0) {
                this.$key_cache_qe1lf3$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              {
                var tmp$2 = this.operations.iterator();
                while (tmp$2.hasNext()) {
                  var el_0 = tmp$2.next();
                  el_0.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$3;
                ((tmp$3 = this.internal_unsetCmd) != null ? tmp$3 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_lcvr6m$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_lcvr6m$;
                this.$name_lcvr6m$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_osjjtx$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_osjjtx$;
                this.$version_osjjtx$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_maxytn$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_maxytn$;
                this.$abstract_maxytn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withSynchrone: function (p) {
              this.synchrone = p;
              return this;
            },
            synchrone: {
              get: function () {
                return this.$synchrone_8uttoy$;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone_8uttoy$;
                this.$synchrone_8uttoy$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal, this, oldPath));
                }
              }
            },
            withInterface: function (p) {
              this.interface = p;
              return this;
            },
            interface: {
              get: function () {
                return this.$interface_8uxxve$;
              },
              set: function (iP) {
                this.internal_interface(iP, true);
              }
            },
            internal_interface: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.interface)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$interface_8uxxve$;
                this.$interface_8uxxve$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_interface, this.interface, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_lwo0sj$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_lwo0sj$, dictionaryTypeP)) {
                if (this.$dictionaryType_lwo0sj$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_lwo0sj$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_lwo0sj$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_lwo0sj$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_lwo0sj$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_lwo0sj$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            operations: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._operations.values());
              },
              set: function (operationsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (operationsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_operations(operationsP, true, true);
              }
            },
            internal_operations: function (operationsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._operations.values(), operationsP)) {
                var kmf_previousVal = this._operations;
                this._operations.clear();
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._operations.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_operations);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_operations, el), _.org.kevoree.util.Constants.Ref_operations);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddOperations: function (operationsP) {
              var _key_ = operationsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._operations.containsKey_za3rmp$(_key_)) {
                this._operations.put_wn2jw4$(_key_, operationsP);
                operationsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_operations, operationsP), _.org.kevoree.util.Constants.Ref_operations);
                operationsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_operations);
              }
            },
            addOperations: function (operationsP) {
              this.internal_addOperations(operationsP, true, true);
              return this;
            },
            addAllOperations: function (operationsP) {
              this.internal_addAllOperations(operationsP, true, true);
              return this;
            },
            internal_addOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddOperations(operationsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, null, this, this.path()));
              }
            },
            internal_addAllOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = operationsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddOperations(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = operationsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddOperations(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, null, this, this.path()));
              }
            },
            removeOperations: function (operationsP) {
              this.internal_removeOperations(operationsP, true, true);
              return this;
            },
            removeAllOperations: function () {
              this.internal_removeAllOperations(true, true);
              return this;
            },
            internal_removeOperations: function (operationsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._operations.size() !== 0 && this._operations.containsKey_za3rmp$(operationsP.internalGetKey())) {
                var previousPathToBeRemoved = operationsP.path();
                this._operations.remove_za3rmp$(operationsP.internalGetKey());
                operationsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_operations);
                operationsP.setEContainer(null, null, null);
                if (!this.removeAllOperationsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, operationsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllOperations: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllOperationsCurrentlyProcessing = true;
              }
              var temp_els = this.operations;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._operations.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_operations, temp_els, null, this, this.path()));
                this.removeAllOperationsCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                  this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_interface) {
                  this.internal_interface(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_operations) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeOperations(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllOperations();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._operations.size() !== 0 && this._operations.containsKey_za3rmp$(value)) {
                        var obj_2 = this._operations.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._operations.remove_za3rmp$(value);
                        this._operations.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findOperationsByID: function (key) {
              return this._operations.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_operations) {
                  return this.findOperationsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_operations, _.org.kevoree.util.Constants.org_kevoree_Operation)) {
                  {
                    var tmp$1 = this._operations.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._operations.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_operations);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_operations);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$2 = this._deployUnits.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$3 = this._superTypes.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.interface, _.org.kevoree.util.Constants.Att_interface, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ServicePortType;
            }
          }),
          FragmentDictionaryImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.FragmentDictionary, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_yo6lx$ = null;
            this.$internal_containmentRefName_ze982j$ = null;
            this.$internal_unsetCmd_vf3nr4$ = null;
            this.$internal_readOnlyElem_mt2abk$ = false;
            this.$internal_recursive_readOnlyElem_cyra1f$ = false;
            this.$internal_inboundReferences_hjj2mq$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_igi7ro$ = false;
            this.$internal_is_deleted_3reyh9$ = false;
            this.$is_root_tygcxo$ = false;
            this.$internal_modelElementListeners_1snu5f$ = null;
            this.$internal_modelTreeListeners_xh0adj$ = null;
            this.$path_cache_nygoij$ = null;
            this.$key_cache_tys64v$ = null;
            this.$generated_KMF_ID_jtp83r$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$name_f26ebm$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._values = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.FragmentDictionaryImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_yo6lx$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_yo6lx$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_ze982j$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_ze982j$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_vf3nr4$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_vf3nr4$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_mt2abk$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_mt2abk$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_cyra1f$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_cyra1f$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_hjj2mq$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_hjj2mq$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_igi7ro$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_igi7ro$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_3reyh9$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_3reyh9$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_tygcxo$;
              },
              set: function (tmp$0) {
                this.$is_root_tygcxo$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_1snu5f$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_1snu5f$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_xh0adj$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_xh0adj$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_nygoij$;
              },
              set: function (tmp$0) {
                this.$path_cache_nygoij$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_tys64v$;
              },
              set: function (tmp$0) {
                this.$key_cache_tys64v$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.values.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_jtp83r$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_jtp83r$;
                this.$generated_KMF_ID_jtp83r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_f26ebm$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_f26ebm$;
                this.$name_f26ebm$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = valuesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey_za3rmp$(_key_)) {
                this._values.put_wn2jw4$(_key_, valuesP);
                valuesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
                valuesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
              return this;
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
              return this;
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
              return this;
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
              return this;
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(valuesP.internalGetKey())) {
                var previousPathToBeRemoved = valuesP.path();
                this._values.remove_za3rmp$(valuesP.internalGetKey());
                valuesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                valuesP.setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var temp_els = this.values;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null, this, this.path()));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllValues();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(value)) {
                        var obj = this._values.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._values.remove_za3rmp$(value);
                        this._values.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                  return this.findValuesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._values.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary;
            }
          }),
          PortTypeRefImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.PortTypeRef, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_pm392r$ = null;
            this.$internal_containmentRefName_atv9kz$ = null;
            this.$internal_unsetCmd_cj7bs$ = null;
            this.$internal_readOnlyElem_hbvq08$ = false;
            this.$internal_recursive_readOnlyElem_p412fp$ = false;
            this.$internal_inboundReferences_m7ab6e$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_m15cx8$ = false;
            this.$internal_is_deleted_mtch7f$ = false;
            this.$is_root_oootrg$ = false;
            this.$internal_modelElementListeners_prt097$ = null;
            this.$internal_modelTreeListeners_8wmbvz$ = null;
            this.$path_cache_3zokj7$ = null;
            this.$key_cache_l34n9l$ = null;
            this.$name_g95rrq$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$optional_jfj7it$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$noDependency_4fourt$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$ref_e9sxd4$ = null;
            this._mappings = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMappingsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PortTypeRefImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_pm392r$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_pm392r$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_atv9kz$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_atv9kz$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_cj7bs$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_cj7bs$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_hbvq08$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_hbvq08$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_p412fp$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_p412fp$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_m7ab6e$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_m7ab6e$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_m15cx8$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_m15cx8$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_mtch7f$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_mtch7f$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_oootrg$;
              },
              set: function (tmp$0) {
                this.$is_root_oootrg$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_prt097$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_prt097$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_8wmbvz$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_8wmbvz$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_3zokj7$;
              },
              set: function (tmp$0) {
                this.$path_cache_3zokj7$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_l34n9l$;
              },
              set: function (tmp$0) {
                this.$key_cache_l34n9l$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.ref != null) {
                var tmp$0;
                ((tmp$0 = this.ref) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_ref);
                this.ref = null;
              }
              {
                var tmp$1 = this.mappings.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_g95rrq$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_g95rrq$;
                this.$name_g95rrq$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withOptional: function (p) {
              this.optional = p;
              return this;
            },
            optional: {
              get: function () {
                return this.$optional_jfj7it$;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$optional_jfj7it$;
                this.$optional_jfj7it$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional, kmf_previousVal, this, oldPath));
                }
              }
            },
            withNoDependency: function (p) {
              this.noDependency = p;
              return this;
            },
            noDependency: {
              get: function () {
                return this.$noDependency_4fourt$;
              },
              set: function (iP) {
                this.internal_noDependency(iP, true);
              }
            },
            internal_noDependency: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.noDependency)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$noDependency_4fourt$;
                this.$noDependency_4fourt$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_noDependency, this.noDependency, kmf_previousVal, this, oldPath));
                }
              }
            },
            ref: {
              get: function () {
                return this.$ref_e9sxd4$;
              },
              set: function (refP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_ref(refP, true, true);
              }
            },
            internal_ref: function (refP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$ref_e9sxd4$, refP)) {
                var kmf_previousVal = this.$ref_e9sxd4$;
                if (refP != null) {
                  (refP != null ? refP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_ref);
                }
                 else {
                  if (this.$ref_e9sxd4$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$ref_e9sxd4$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_ref);
                  }
                }
                this.$ref_e9sxd4$ = refP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_ref, refP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withRef: function (ref) {
              return this;
            },
            mappings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._mappings.values());
              },
              set: function (mappingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mappingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mappings(mappingsP, true, true);
              }
            },
            internal_mappings: function (mappingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mappings.values(), mappingsP)) {
                var kmf_previousVal = this._mappings;
                this._mappings.clear();
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mappings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mappings);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, el), _.org.kevoree.util.Constants.Ref_mappings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMappings: function (mappingsP) {
              var _key_ = mappingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mappings.containsKey_za3rmp$(_key_)) {
                this._mappings.put_wn2jw4$(_key_, mappingsP);
                mappingsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mappings, mappingsP), _.org.kevoree.util.Constants.Ref_mappings);
                mappingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mappings);
              }
            },
            addMappings: function (mappingsP) {
              this.internal_addMappings(mappingsP, true, true);
              return this;
            },
            addAllMappings: function (mappingsP) {
              this.internal_addAllMappings(mappingsP, true, true);
              return this;
            },
            internal_addMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMappings(mappingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, null, this, this.path()));
              }
            },
            internal_addAllMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mappingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMappings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mappingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMappings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, null, this, this.path()));
              }
            },
            removeMappings: function (mappingsP) {
              this.internal_removeMappings(mappingsP, true, true);
              return this;
            },
            removeAllMappings: function () {
              this.internal_removeAllMappings(true, true);
              return this;
            },
            internal_removeMappings: function (mappingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mappings.size() !== 0 && this._mappings.containsKey_za3rmp$(mappingsP.internalGetKey())) {
                var previousPathToBeRemoved = mappingsP.path();
                this._mappings.remove_za3rmp$(mappingsP.internalGetKey());
                mappingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_mappings);
                mappingsP.setEContainer(null, null, null);
                if (!this.removeAllMappingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, mappingsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMappings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMappingsCurrentlyProcessing = true;
              }
              var temp_els = this.mappings;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._mappings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mappings, temp_els, null, this, this.path()));
                this.removeAllMappingsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                  this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_noDependency) {
                  this.internal_noDependency(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_ref) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_ref(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_ref(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_ref(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_mappings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMappings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMappings();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._mappings.size() !== 0 && this._mappings.containsKey_za3rmp$(value)) {
                        var obj = this._mappings.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._mappings.remove_za3rmp$(value);
                        this._mappings.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findMappingsByID: function (key) {
              return this._mappings.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_ref) {
                  var objFound = this.ref;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_mappings) {
                  return this.findMappingsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mappings, _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping)) {
                  {
                    var tmp$0 = this._mappings.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._mappings.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mappings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mappings);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_ref, _.org.kevoree.util.Constants.org_kevoree_PortType)) {
                  this.internal_visit(visitor, this.ref, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_ref);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_ref);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.noDependency, _.org.kevoree.util.Constants.Att_noDependency, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeRef;
            }
          }),
          MessagePortTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.MessagePortType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_hbz6o3$ = null;
            this.$internal_containmentRefName_3jq7sj$ = null;
            this.$internal_unsetCmd_l6u4j6$ = null;
            this.$internal_readOnlyElem_ev9acy$ = false;
            this.$internal_recursive_readOnlyElem_kihxen$ = false;
            this.$internal_inboundReferences_kva28w$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_icn5gi$ = false;
            this.$internal_is_deleted_k4pyjf$ = false;
            this.$is_root_he4nm2$ = false;
            this.$internal_modelElementListeners_z33frp$ = null;
            this.$internal_modelTreeListeners_5gz5hj$ = null;
            this.$path_cache_2nrm5l$ = null;
            this.$key_cache_ta1ta9$ = null;
            this.$name_hyjd84$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_p0mtmf$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_fc4ja5$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone_5ytlts$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_f4566n$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._filters = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.MessagePortTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_hbz6o3$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_hbz6o3$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_3jq7sj$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_3jq7sj$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_l6u4j6$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_l6u4j6$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_ev9acy$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_ev9acy$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_kihxen$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_kihxen$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_kva28w$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_kva28w$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_icn5gi$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_icn5gi$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_k4pyjf$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_k4pyjf$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_he4nm2$;
              },
              set: function (tmp$0) {
                this.$is_root_he4nm2$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_z33frp$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_z33frp$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_5gz5hj$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_5gz5hj$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_2nrm5l$;
              },
              set: function (tmp$0) {
                this.$path_cache_2nrm5l$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ta1ta9$;
              },
              set: function (tmp$0) {
                this.$key_cache_ta1ta9$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.removeAllFilters();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_hyjd84$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_hyjd84$;
                this.$name_hyjd84$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_p0mtmf$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_p0mtmf$;
                this.$version_p0mtmf$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_fc4ja5$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_fc4ja5$;
                this.$abstract_fc4ja5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withSynchrone: function (p) {
              this.synchrone = p;
              return this;
            },
            synchrone: {
              get: function () {
                return this.$synchrone_5ytlts$;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone_5ytlts$;
                this.$synchrone_5ytlts$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_f4566n$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_f4566n$, dictionaryTypeP)) {
                if (this.$dictionaryType_f4566n$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_f4566n$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_f4566n$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_f4566n$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_f4566n$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_f4566n$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            filters: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                var kmf_previousVal = this._filters;
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFilters: function (filtersP) {
              var _key_ = filtersP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey_za3rmp$(_key_)) {
                this._filters.put_wn2jw4$(_key_, filtersP);
                filtersP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
              }
            },
            addFilters: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
              return this;
            },
            addAllFilters: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
              return this;
            },
            internal_addFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            internal_addAllFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            removeFilters: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
              return this;
            },
            removeAllFilters: function () {
              this.internal_removeAllFilters(true, true);
              return this;
            },
            internal_removeFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(filtersP.internalGetKey())) {
                var previousPathToBeRemoved = filtersP.path();
                this._filters.remove_za3rmp$(filtersP.internalGetKey());
                filtersP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, filtersP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFilters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.filters;
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_filters, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                  this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFilters();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(value)) {
                        var obj_2 = this._filters.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._filters.remove_za3rmp$(value);
                        this._filters.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findFiltersByID: function (key) {
              return this._filters.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                  return this.findFiltersByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  {
                    var tmp$3 = this._filters.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._filters.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_MessagePortType;
            }
          }),
          NetworkInfoImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.NetworkInfo, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_keo2h5$ = null;
            this.$internal_containmentRefName_wec9a1$ = null;
            this.$internal_unsetCmd_px0nvw$ = null;
            this.$internal_readOnlyElem_rpdj9w$ = false;
            this.$internal_recursive_readOnlyElem_vcdys9$ = false;
            this.$internal_inboundReferences_oir15y$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_99g4k8$ = false;
            this.$internal_is_deleted_n7euch$ = false;
            this.$is_root_yuvqsw$ = false;
            this.$internal_modelElementListeners_tf4qpd$ = null;
            this.$internal_modelTreeListeners_ybl6z1$ = null;
            this.$path_cache_kbu46n$ = null;
            this.$key_cache_mz3tob$ = null;
            this.$name_keyy5q$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._values = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NetworkInfoImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_keo2h5$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_keo2h5$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_wec9a1$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_wec9a1$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_px0nvw$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_px0nvw$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_rpdj9w$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_rpdj9w$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_vcdys9$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_vcdys9$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_oir15y$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_oir15y$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_99g4k8$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_99g4k8$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_n7euch$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_n7euch$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_yuvqsw$;
              },
              set: function (tmp$0) {
                this.$is_root_yuvqsw$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_tf4qpd$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_tf4qpd$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ybl6z1$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ybl6z1$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_kbu46n$;
              },
              set: function (tmp$0) {
                this.$path_cache_kbu46n$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_mz3tob$;
              },
              set: function (tmp$0) {
                this.$key_cache_mz3tob$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.values.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_keyy5q$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_keyy5q$;
                this.$name_keyy5q$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = valuesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey_za3rmp$(_key_)) {
                this._values.put_wn2jw4$(_key_, valuesP);
                valuesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
                valuesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
              return this;
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
              return this;
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
              return this;
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
              return this;
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(valuesP.internalGetKey())) {
                var previousPathToBeRemoved = valuesP.path();
                this._values.remove_za3rmp$(valuesP.internalGetKey());
                valuesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                valuesP.setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var temp_els = this.values;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null, this, this.path()));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllValues();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(value)) {
                        var obj = this._values.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._values.remove_za3rmp$(value);
                        this._values.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                  return this.findValuesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._values.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NetworkInfo;
            }
          }),
          ComponentInstanceImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ComponentInstance, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_nmak19$ = null;
            this.$internal_containmentRefName_kll01p$ = null;
            this.$internal_unsetCmd_y60xya$ = null;
            this.$internal_readOnlyElem_ikwqaq$ = false;
            this.$internal_recursive_readOnlyElem_7d07xt$ = false;
            this.$internal_inboundReferences_h2chgw$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_70mf3m$ = false;
            this.$internal_is_deleted_ktjs5x$ = false;
            this.$is_root_d8h6g6$ = false;
            this.$internal_modelElementListeners_ef9b0b$ = null;
            this.$internal_modelTreeListeners_ioc2cp$ = null;
            this.$path_cache_mu1bpj$ = null;
            this.$key_cache_f2th5b$ = null;
            this.$name_wk34d8$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_igd7rk$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this._provided = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllProvidedCurrentlyProcessing = false;
            this.$typeDefinition_fs7rgi$ = null;
            this.$dictionary_yoq5eh$ = null;
            this._required = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllRequiredCurrentlyProcessing = false;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ComponentInstanceImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_nmak19$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_nmak19$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_kll01p$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_kll01p$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_y60xya$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_y60xya$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_ikwqaq$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_ikwqaq$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_7d07xt$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_7d07xt$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_h2chgw$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_h2chgw$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_70mf3m$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_70mf3m$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_ktjs5x$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_ktjs5x$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_d8h6g6$;
              },
              set: function (tmp$0) {
                this.$is_root_d8h6g6$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_ef9b0b$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_ef9b0b$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ioc2cp$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ioc2cp$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_mu1bpj$;
              },
              set: function (tmp$0) {
                this.$path_cache_mu1bpj$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_f2th5b$;
              },
              set: function (tmp$0) {
                this.$key_cache_f2th5b$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              {
                var tmp$4 = this.provided.iterator();
                while (tmp$4.hasNext()) {
                  var el_1 = tmp$4.next();
                  el_1.delete();
                }
              }
              {
                var tmp$5 = this.required.iterator();
                while (tmp$5.hasNext()) {
                  var el_2 = tmp$5.next();
                  el_2.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$6;
                ((tmp$6 = this.internal_unsetCmd) != null ? tmp$6 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_wk34d8$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_wk34d8$;
                this.$name_wk34d8$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_igd7rk$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_igd7rk$;
                this.$started_igd7rk$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            provided: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                var kmf_previousVal = this._provided;
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = providedP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey_za3rmp$(_key_)) {
                this._provided.put_wn2jw4$(_key_, providedP);
                providedP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
                providedP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
              return this;
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
              return this;
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
              return this;
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
              return this;
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(providedP.internalGetKey())) {
                var previousPathToBeRemoved = providedP.path();
                this._provided.remove_za3rmp$(providedP.internalGetKey());
                providedP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                providedP.setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var temp_els = this.provided;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els, null, this, this.path()));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_fs7rgi$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_fs7rgi$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_fs7rgi$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_fs7rgi$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_fs7rgi$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_fs7rgi$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_yoq5eh$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_yoq5eh$, dictionaryP)) {
                if (this.$dictionary_yoq5eh$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_yoq5eh$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_yoq5eh$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_yoq5eh$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_yoq5eh$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_yoq5eh$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            required: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                var kmf_previousVal = this._required;
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = requiredP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey_za3rmp$(_key_)) {
                this._required.put_wn2jw4$(_key_, requiredP);
                requiredP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
                requiredP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
              return this;
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
              return this;
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
              return this;
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
              return this;
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(requiredP.internalGetKey())) {
                var previousPathToBeRemoved = requiredP.path();
                this._required.remove_za3rmp$(requiredP.internalGetKey());
                requiredP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                requiredP.setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var temp_els = this.required;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els, null, this, this.path()));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllProvided();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(value)) {
                        var obj_1 = this._provided.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._provided.remove_za3rmp$(value);
                        this._provided.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRequired();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(value)) {
                        var obj_2 = this._required.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._required.remove_za3rmp$(value);
                        this._required.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get_za3rmp$(key);
            },
            findRequiredByID: function (key) {
              return this._required.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                  return this.findProvidedByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                  return this.findRequiredByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_Port)) {
                  {
                    var tmp$2 = this._provided.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._provided.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_Port)) {
                  {
                    var tmp$3 = this._required.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._required.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentInstance;
            }
          }),
          PortTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.PortType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_k3n6zk$ = null;
            this.$internal_containmentRefName_80yn9s$ = null;
            this.$internal_unsetCmd_4o77px$ = null;
            this.$internal_readOnlyElem_nsfz3f$ = false;
            this.$internal_recursive_readOnlyElem_my4e4i$ = false;
            this.$internal_inboundReferences_99n2l9$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_79oef3$ = false;
            this.$internal_is_deleted_hawf48$ = false;
            this.$is_root_xh4ot5$ = false;
            this.$internal_modelElementListeners_68i7zc$ = null;
            this.$internal_modelTreeListeners_9y7kys$ = null;
            this.$path_cache_nk0f8a$ = null;
            this.$key_cache_qk3e3g$ = null;
            this.$name_scm1hl$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_4us42i$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_13k1nk$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$synchrone_9858rn$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_h35dea$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PortTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_k3n6zk$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_k3n6zk$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_80yn9s$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_80yn9s$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_4o77px$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_4o77px$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_nsfz3f$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_nsfz3f$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_my4e4i$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_my4e4i$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_99n2l9$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_99n2l9$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_79oef3$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_79oef3$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_hawf48$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_hawf48$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_xh4ot5$;
              },
              set: function (tmp$0) {
                this.$is_root_xh4ot5$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_68i7zc$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_68i7zc$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_9y7kys$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_9y7kys$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_nk0f8a$;
              },
              set: function (tmp$0) {
                this.$path_cache_nk0f8a$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_qk3e3g$;
              },
              set: function (tmp$0) {
                this.$key_cache_qk3e3g$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_scm1hl$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_scm1hl$;
                this.$name_scm1hl$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_4us42i$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_4us42i$;
                this.$version_4us42i$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_13k1nk$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_13k1nk$;
                this.$abstract_13k1nk$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withSynchrone: function (p) {
              this.synchrone = p;
              return this;
            },
            synchrone: {
              get: function () {
                return this.$synchrone_9858rn$;
              },
              set: function (iP) {
                this.internal_synchrone(iP, true);
              }
            },
            internal_synchrone: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.synchrone)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$synchrone_9858rn$;
                this.$synchrone_9858rn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_synchrone, this.synchrone, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_h35dea$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_h35dea$, dictionaryTypeP)) {
                if (this.$dictionaryType_h35dea$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_h35dea$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_h35dea$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_h35dea$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_h35dea$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_h35dea$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_synchrone) {
                  this.internal_synchrone(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.synchrone, _.org.kevoree.util.Constants.Att_synchrone, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortType;
            }
          }),
          NodeTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.NodeType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_gxuzfj$ = null;
            this.$internal_containmentRefName_j0daa7$ = null;
            this.$internal_unsetCmd_x7k7oq$ = null;
            this.$internal_readOnlyElem_yh9u3u$ = false;
            this.$internal_recursive_readOnlyElem_b2xs77$ = false;
            this.$internal_inboundReferences_n5xt8k$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_hhai0u$ = false;
            this.$internal_is_deleted_jqlrav$ = false;
            this.$is_root_d6010a$ = false;
            this.$internal_modelElementListeners_ze1rjt$ = null;
            this.$internal_modelTreeListeners_kxm7z7$ = null;
            this.$path_cache_c8tlx7$ = null;
            this.$key_cache_a5jobf$ = null;
            this.$name_qycue0$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_fgcjqd$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_8lfy9r$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_mhkxfx$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.NodeTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_gxuzfj$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_gxuzfj$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_j0daa7$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_j0daa7$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_x7k7oq$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_x7k7oq$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_yh9u3u$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_yh9u3u$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_b2xs77$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_b2xs77$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_n5xt8k$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_n5xt8k$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_hhai0u$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_hhai0u$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_jqlrav$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_jqlrav$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_d6010a$;
              },
              set: function (tmp$0) {
                this.$is_root_d6010a$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_ze1rjt$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_ze1rjt$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_kxm7z7$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_kxm7z7$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_c8tlx7$;
              },
              set: function (tmp$0) {
                this.$path_cache_c8tlx7$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_a5jobf$;
              },
              set: function (tmp$0) {
                this.$key_cache_a5jobf$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_qycue0$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_qycue0$;
                this.$name_qycue0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_fgcjqd$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_fgcjqd$;
                this.$version_fgcjqd$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_8lfy9r$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_8lfy9r$;
                this.$abstract_8lfy9r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_mhkxfx$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_mhkxfx$, dictionaryTypeP)) {
                if (this.$dictionaryType_mhkxfx$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_mhkxfx$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_mhkxfx$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_mhkxfx$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_mhkxfx$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_mhkxfx$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NodeType;
            }
          }),
          PackageImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Package, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_epqzi9$ = null;
            this.$internal_containmentRefName_jrgxqp$ = null;
            this.$internal_unsetCmd_gn28ty$ = null;
            this.$internal_readOnlyElem_efznuy$ = false;
            this.$internal_recursive_readOnlyElem_rxnajn$ = false;
            this.$internal_inboundReferences_5kxrj0$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_wlbk4e$ = false;
            this.$internal_is_deleted_bx07mx$ = false;
            this.$is_root_l2e4vu$ = false;
            this.$internal_modelElementListeners_r0onjb$ = null;
            this.$internal_modelTreeListeners_hu801p$ = null;
            this.$path_cache_4jijz9$ = null;
            this.$key_cache_is02bf$ = null;
            this.$name_n9iebs$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._packages = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllPackagesCurrentlyProcessing = false;
            this._typeDefinitions = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllTypeDefinitionsCurrentlyProcessing = false;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllDeployUnitsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.PackageImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_epqzi9$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_epqzi9$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_jrgxqp$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_jrgxqp$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_gn28ty$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_gn28ty$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_efznuy$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_efznuy$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_rxnajn$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_rxnajn$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_5kxrj0$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_5kxrj0$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_wlbk4e$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_wlbk4e$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_bx07mx$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_bx07mx$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_l2e4vu$;
              },
              set: function (tmp$0) {
                this.$is_root_l2e4vu$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_r0onjb$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_r0onjb$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_hu801p$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_hu801p$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_4jijz9$;
              },
              set: function (tmp$0) {
                this.$path_cache_4jijz9$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_is02bf$;
              },
              set: function (tmp$0) {
                this.$key_cache_is02bf$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.packages.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              {
                var tmp$1 = this.typeDefinitions.iterator();
                while (tmp$1.hasNext()) {
                  var el_0 = tmp$1.next();
                  el_0.delete();
                }
              }
              {
                var tmp$2 = this.deployUnits.iterator();
                while (tmp$2.hasNext()) {
                  var el_1 = tmp$2.next();
                  el_1.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$3;
                ((tmp$3 = this.internal_unsetCmd) != null ? tmp$3 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_n9iebs$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_n9iebs$;
                this.$name_n9iebs$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            packages: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._packages.values());
              },
              set: function (packagesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (packagesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_packages(packagesP, true, true);
              }
            },
            internal_packages: function (packagesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._packages.values(), packagesP)) {
                var kmf_previousVal = this._packages;
                this._packages.clear();
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._packages.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, el), _.org.kevoree.util.Constants.Ref_packages);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddPackages: function (packagesP) {
              var _key_ = packagesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._packages.containsKey_za3rmp$(_key_)) {
                this._packages.put_wn2jw4$(_key_, packagesP);
                packagesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, packagesP), _.org.kevoree.util.Constants.Ref_packages);
                packagesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
              }
            },
            addPackages: function (packagesP) {
              this.internal_addPackages(packagesP, true, true);
              return this;
            },
            addAllPackages: function (packagesP) {
              this.internal_addAllPackages(packagesP, true, true);
              return this;
            },
            internal_addPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPackages(packagesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            internal_addAllPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPackages(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = packagesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPackages(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            removePackages: function (packagesP) {
              this.internal_removePackages(packagesP, true, true);
              return this;
            },
            removeAllPackages: function () {
              this.internal_removeAllPackages(true, true);
              return this;
            },
            internal_removePackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(packagesP.internalGetKey())) {
                var previousPathToBeRemoved = packagesP.path();
                this._packages.remove_za3rmp$(packagesP.internalGetKey());
                packagesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                packagesP.setEContainer(null, null, null);
                if (!this.removeAllPackagesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllPackages: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllPackagesCurrentlyProcessing = true;
              }
              var temp_els = this.packages;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._packages.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, temp_els, null, this, this.path()));
                this.removeAllPackagesCurrentlyProcessing = false;
              }
            },
            typeDefinitions: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._typeDefinitions.values());
              },
              set: function (typeDefinitionsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (typeDefinitionsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_typeDefinitions(typeDefinitionsP, true, true);
              }
            },
            internal_typeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._typeDefinitions.values(), typeDefinitionsP)) {
                var kmf_previousVal = this._typeDefinitions;
                this._typeDefinitions.clear();
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._typeDefinitions.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, el), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddTypeDefinitions: function (typeDefinitionsP) {
              var _key_ = typeDefinitionsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._typeDefinitions.containsKey_za3rmp$(_key_)) {
                this._typeDefinitions.put_wn2jw4$(_key_, typeDefinitionsP);
                typeDefinitionsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP), _.org.kevoree.util.Constants.Ref_typeDefinitions);
                typeDefinitionsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinitions);
              }
            },
            addTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addTypeDefinitions(typeDefinitionsP, true, true);
              return this;
            },
            addAllTypeDefinitions: function (typeDefinitionsP) {
              this.internal_addAllTypeDefinitions(typeDefinitionsP, true, true);
              return this;
            },
            internal_addTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddTypeDefinitions(typeDefinitionsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, null, this, this.path()));
              }
            },
            internal_addAllTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = typeDefinitionsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddTypeDefinitions(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = typeDefinitionsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddTypeDefinitions(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, null, this, this.path()));
              }
            },
            removeTypeDefinitions: function (typeDefinitionsP) {
              this.internal_removeTypeDefinitions(typeDefinitionsP, true, true);
              return this;
            },
            removeAllTypeDefinitions: function () {
              this.internal_removeAllTypeDefinitions(true, true);
              return this;
            },
            internal_removeTypeDefinitions: function (typeDefinitionsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey_za3rmp$(typeDefinitionsP.internalGetKey())) {
                var previousPathToBeRemoved = typeDefinitionsP.path();
                this._typeDefinitions.remove_za3rmp$(typeDefinitionsP.internalGetKey());
                typeDefinitionsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                typeDefinitionsP.setEContainer(null, null, null);
                if (!this.removeAllTypeDefinitionsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, typeDefinitionsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllTypeDefinitions: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllTypeDefinitionsCurrentlyProcessing = true;
              }
              var temp_els = this.typeDefinitions;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._typeDefinitions.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_typeDefinitions, temp_els, null, this, this.path()));
                this.removeAllTypeDefinitionsCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, el), _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP), _.org.kevoree.util.Constants.Ref_deployUnits);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                deployUnitsP.setEContainer(null, null, null);
                if (!this.removeAllDeployUnitsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllDeployUnitsCurrentlyProcessing = true;
              }
              var temp_els = this.deployUnits;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
                this.removeAllDeployUnitsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_packages) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removePackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllPackages();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(value)) {
                        var obj = this._packages.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._packages.remove_za3rmp$(value);
                        this._packages.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeTypeDefinitions(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllTypeDefinitions();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._typeDefinitions.size() !== 0 && this._typeDefinitions.containsKey_za3rmp$(value)) {
                        var obj_0 = this._typeDefinitions.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._typeDefinitions.remove_za3rmp$(value);
                        this._typeDefinitions.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj_1 = this._deployUnits.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findPackagesByID: function (key) {
              return this._packages.get_za3rmp$(key);
            },
            findTypeDefinitionsByNameVersion: function (name, version) {
              return this.findTypeDefinitionsByID('name=' + name + ',version=' + version);
            },
            findTypeDefinitionsByID: function (key) {
              return this._typeDefinitions.get_za3rmp$(key);
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_packages) {
                  return this.findPackagesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinitions) {
                  return this.findTypeDefinitionsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_packages, _.org.kevoree.util.Constants.org_kevoree_Package)) {
                  {
                    var tmp$0 = this._packages.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._packages.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_packages);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_packages);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$1 = this._typeDefinitions.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._typeDefinitions.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinitions);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinitions);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$2 = this._deployUnits.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Package;
            }
          }),
          DeployUnitImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.DeployUnit, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_35i8a8$ = null;
            this.$internal_containmentRefName_23r6e8$ = null;
            this.$internal_unsetCmd_mr8vnp$ = null;
            this.$internal_readOnlyElem_3o8n45$ = false;
            this.$internal_recursive_readOnlyElem_dl0du6$ = false;
            this.$internal_inboundReferences_45iopf$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_lg6sgf$ = false;
            this.$internal_is_deleted_5y905k$ = false;
            this.$is_root_5d0ruf$ = false;
            this.$internal_modelElementListeners_9n22k8$ = null;
            this.$internal_modelTreeListeners_6i8p8$ = null;
            this.$path_cache_airkay$ = null;
            this.$key_cache_ctbw44$ = null;
            this.$name_8nxs2v$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_xzdcl2$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$hashcode_nqkelz$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$url_6lejz5$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._requiredLibs = new _.java.util.concurrent.ConcurrentHashMap();
            this._filters = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFiltersCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DeployUnitImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_35i8a8$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_35i8a8$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_23r6e8$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_23r6e8$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_mr8vnp$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_mr8vnp$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_3o8n45$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_3o8n45$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_dl0du6$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_dl0du6$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_45iopf$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_45iopf$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_lg6sgf$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_lg6sgf$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_5y905k$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_5y905k$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_5d0ruf$;
              },
              set: function (tmp$0) {
                this.$is_root_5d0ruf$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_9n22k8$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_9n22k8$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_6i8p8$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_6i8p8$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_airkay$;
              },
              set: function (tmp$0) {
                this.$path_cache_airkay$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ctbw44$;
              },
              set: function (tmp$0) {
                this.$key_cache_ctbw44$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.filters.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.removeAllRequiredLibs();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_8nxs2v$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_8nxs2v$;
                this.$name_8nxs2v$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_xzdcl2$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_xzdcl2$;
                this.$version_xzdcl2$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withHashcode: function (p) {
              this.hashcode = p;
              return this;
            },
            hashcode: {
              get: function () {
                return this.$hashcode_nqkelz$;
              },
              set: function (iP) {
                this.internal_hashcode(iP, true);
              }
            },
            internal_hashcode: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.hashcode)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$hashcode_nqkelz$;
                this.$hashcode_nqkelz$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.hashcode, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_hashcode, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withUrl: function (p) {
              this.url = p;
              return this;
            },
            url: {
              get: function () {
                return this.$url_6lejz5$;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$url_6lejz5$;
                this.$url_6lejz5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url, kmf_previousVal, this, oldPath));
                }
              }
            },
            requiredLibs: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._requiredLibs.values());
              },
              set: function (requiredLibsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredLibsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_requiredLibs(requiredLibsP, true, true);
              }
            },
            internal_requiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._requiredLibs.values(), requiredLibsP)) {
                var kmf_previousVal = this._requiredLibs;
                this._requiredLibs.clear();
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._requiredLibs.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_requiredLibs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRequiredLibs: function (requiredLibsP) {
              var _key_ = requiredLibsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._requiredLibs.containsKey_za3rmp$(_key_)) {
                this._requiredLibs.put_wn2jw4$(_key_, requiredLibsP);
                requiredLibsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_requiredLibs);
              }
            },
            addRequiredLibs: function (requiredLibsP) {
              this.internal_addRequiredLibs(requiredLibsP, true, true);
              return this;
            },
            addAllRequiredLibs: function (requiredLibsP) {
              this.internal_addAllRequiredLibs(requiredLibsP, true, true);
              return this;
            },
            internal_addRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequiredLibs(requiredLibsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, null, this, this.path()));
              }
            },
            internal_addAllRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredLibsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequiredLibs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredLibsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequiredLibs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, null, this, this.path()));
              }
            },
            removeRequiredLibs: function (requiredLibsP) {
              this.internal_removeRequiredLibs(requiredLibsP, true, true);
              return this;
            },
            removeAllRequiredLibs: function () {
              this.internal_removeAllRequiredLibs(true, true);
              return this;
            },
            internal_removeRequiredLibs: function (requiredLibsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey_za3rmp$(requiredLibsP.internalGetKey())) {
                var previousPathToBeRemoved = requiredLibsP.path();
                this._requiredLibs.remove_za3rmp$(requiredLibsP.internalGetKey());
                requiredLibsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_requiredLibs);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, requiredLibsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRequiredLibs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.requiredLibs;
              this._requiredLibs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_requiredLibs, temp_els, null, this, this.path()));
              }
            },
            filters: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._filters.values());
              },
              set: function (filtersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (filtersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_filters(filtersP, true, true);
              }
            },
            internal_filters: function (filtersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._filters.values(), filtersP)) {
                var kmf_previousVal = this._filters;
                this._filters.clear();
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._filters.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_filters, el), _.org.kevoree.util.Constants.Ref_filters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFilters: function (filtersP) {
              var _key_ = filtersP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._filters.containsKey_za3rmp$(_key_)) {
                this._filters.put_wn2jw4$(_key_, filtersP);
                filtersP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_filters, filtersP), _.org.kevoree.util.Constants.Ref_filters);
                filtersP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
              }
            },
            addFilters: function (filtersP) {
              this.internal_addFilters(filtersP, true, true);
              return this;
            },
            addAllFilters: function (filtersP) {
              this.internal_addAllFilters(filtersP, true, true);
              return this;
            },
            internal_addFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFilters(filtersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            internal_addAllFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = filtersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFilters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = filtersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFilters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, null, this, this.path()));
              }
            },
            removeFilters: function (filtersP) {
              this.internal_removeFilters(filtersP, true, true);
              return this;
            },
            removeAllFilters: function () {
              this.internal_removeAllFilters(true, true);
              return this;
            },
            internal_removeFilters: function (filtersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(filtersP.internalGetKey())) {
                var previousPathToBeRemoved = filtersP.path();
                this._filters.remove_za3rmp$(filtersP.internalGetKey());
                filtersP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_filters);
                filtersP.setEContainer(null, null, null);
                if (!this.removeAllFiltersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, filtersP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFilters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFiltersCurrentlyProcessing = true;
              }
              var temp_els = this.filters;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._filters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_filters, temp_els, null, this, this.path()));
                this.removeAllFiltersCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_hashcode) {
                  this.internal_hashcode(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_url) {
                  this.internal_url(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_filters) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFilters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFilters();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._filters.size() !== 0 && this._filters.containsKey_za3rmp$(value)) {
                        var obj = this._filters.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._filters.remove_za3rmp$(value);
                        this._filters.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRequiredLibs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRequiredLibs();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._requiredLibs.size() !== 0 && this._requiredLibs.containsKey_za3rmp$(value)) {
                        var obj_0 = this._requiredLibs.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._requiredLibs.remove_za3rmp$(value);
                        this._requiredLibs.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'hashcode=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.hashcode)) + ',name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findFiltersByID: function (key) {
              return this._filters.get_za3rmp$(key);
            },
            findRequiredLibsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findRequiredLibsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findRequiredLibsByID: function (key) {
              return this._requiredLibs.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_filters) {
                  return this.findFiltersByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_requiredLibs) {
                  return this.findRequiredLibsByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_filters, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._filters.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._filters.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_filters);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_filters);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._requiredLibs.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._requiredLibs.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_requiredLibs);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_requiredLibs);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.hashcode, _.org.kevoree.util.Constants.Att_hashcode, this);
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DeployUnit;
            }
          }),
          DictionaryAttributeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.DictionaryAttribute, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_lvd97j$ = null;
            this.$internal_containmentRefName_433nap$ = null;
            this.$internal_unsetCmd_d4moly$ = null;
            this.$internal_readOnlyElem_dvh67e$ = false;
            this.$internal_recursive_readOnlyElem_7db20z$ = false;
            this.$internal_inboundReferences_nemrp8$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_dt4myq$ = false;
            this.$internal_is_deleted_oo412v$ = false;
            this.$is_root_1tbtp6$ = false;
            this.$internal_modelElementListeners_o2bcqv$ = null;
            this.$internal_modelTreeListeners_25uplp$ = null;
            this.$path_cache_ls8h8b$ = null;
            this.$key_cache_jbpo9x$ = null;
            this.$name_1llm1k$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$optional_i4lpqb$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$state_likxw4$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$datatype_cs6br5$ = null;
            this.$fragmentDependant_mjin7y$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$defaultValue_irkhbn$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._genericTypes = new _.java.util.concurrent.ConcurrentHashMap();
          }, /** @lends _.org.kevoree.impl.DictionaryAttributeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_lvd97j$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_lvd97j$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_433nap$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_433nap$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_d4moly$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_d4moly$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_dvh67e$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_dvh67e$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_7db20z$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_7db20z$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_nemrp8$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_nemrp8$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_dt4myq$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_dt4myq$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_oo412v$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_oo412v$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_1tbtp6$;
              },
              set: function (tmp$0) {
                this.$is_root_1tbtp6$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_o2bcqv$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_o2bcqv$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_25uplp$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_25uplp$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ls8h8b$;
              },
              set: function (tmp$0) {
                this.$path_cache_ls8h8b$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_jbpo9x$;
              },
              set: function (tmp$0) {
                this.$key_cache_jbpo9x$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllGenericTypes();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_1llm1k$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_1llm1k$;
                this.$name_1llm1k$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withOptional: function (p) {
              this.optional = p;
              return this;
            },
            optional: {
              get: function () {
                return this.$optional_i4lpqb$;
              },
              set: function (iP) {
                this.internal_optional(iP, true);
              }
            },
            internal_optional: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.optional)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$optional_i4lpqb$;
                this.$optional_i4lpqb$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_optional, this.optional, kmf_previousVal, this, oldPath));
                }
              }
            },
            withState: function (p) {
              this.state = p;
              return this;
            },
            state: {
              get: function () {
                return this.$state_likxw4$;
              },
              set: function (iP) {
                this.internal_state(iP, true);
              }
            },
            internal_state: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.state)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$state_likxw4$;
                this.$state_likxw4$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_state, this.state, kmf_previousVal, this, oldPath));
                }
              }
            },
            withDatatype: function (p) {
              this.datatype = p;
              return this;
            },
            datatype: {
              get: function () {
                return this.$datatype_cs6br5$;
              },
              set: function (iP) {
                this.internal_datatype(iP, true);
              }
            },
            internal_datatype: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.datatype)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$datatype_cs6br5$;
                this.$datatype_cs6br5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_datatype, this.datatype, kmf_previousVal, this, oldPath));
                }
              }
            },
            withFragmentDependant: function (p) {
              this.fragmentDependant = p;
              return this;
            },
            fragmentDependant: {
              get: function () {
                return this.$fragmentDependant_mjin7y$;
              },
              set: function (iP) {
                this.internal_fragmentDependant(iP, true);
              }
            },
            internal_fragmentDependant: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.fragmentDependant)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$fragmentDependant_mjin7y$;
                this.$fragmentDependant_mjin7y$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_fragmentDependant, this.fragmentDependant, kmf_previousVal, this, oldPath));
                }
              }
            },
            withDefaultValue: function (p) {
              this.defaultValue = p;
              return this;
            },
            defaultValue: {
              get: function () {
                return this.$defaultValue_irkhbn$;
              },
              set: function (iP) {
                this.internal_defaultValue(iP, true);
              }
            },
            internal_defaultValue: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.defaultValue)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$defaultValue_irkhbn$;
                this.$defaultValue_irkhbn$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_defaultValue, this.defaultValue, kmf_previousVal, this, oldPath));
                }
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                var kmf_previousVal = this._genericTypes;
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = genericTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey_za3rmp$(_key_)) {
                this._genericTypes.put_wn2jw4$(_key_, genericTypesP);
                genericTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
              return this;
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
              return this;
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
              return this;
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
              return this;
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(genericTypesP.internalGetKey())) {
                var previousPathToBeRemoved = genericTypesP.path();
                this._genericTypes.remove_za3rmp$(genericTypesP.internalGetKey());
                genericTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.genericTypes;
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els, null, this, this.path()));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_optional) {
                  this.internal_optional(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_state) {
                  this.internal_state(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_datatype) {
                  var convValue;
                  if (Kotlin.isType(value, _.org.kevoree.DataType) || value == null) {
                    convValue = value;
                  }
                   else {
                    convValue = _.org.kevoree.DataType.object.valueOf(value.toString());
                  }
                  this.internal_datatype(convValue, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_fragmentDependant) {
                  this.internal_fragmentDependant(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_defaultValue) {
                  this.internal_defaultValue(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllGenericTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(value)) {
                        var obj = this._genericTypes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._genericTypes.remove_za3rmp$(value);
                        this._genericTypes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  return this.findGenericTypesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  {
                    var tmp$0 = this._genericTypes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._genericTypes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.fragmentDependant, _.org.kevoree.util.Constants.Att_fragmentDependant, this);
              visitor.visit(this.optional, _.org.kevoree.util.Constants.Att_optional, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.state, _.org.kevoree.util.Constants.Att_state, this);
              visitor.visit(this.datatype, _.org.kevoree.util.Constants.Att_datatype, this);
              visitor.visit(this.defaultValue, _.org.kevoree.util.Constants.Att_defaultValue, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute;
            }
          }),
          InstanceImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Instance, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_atfnfe$ = null;
            this.$internal_containmentRefName_y35zoq$ = null;
            this.$internal_unsetCmd_vhr633$ = null;
            this.$internal_readOnlyElem_4kdsgf$ = false;
            this.$internal_recursive_readOnlyElem_219qv8$ = false;
            this.$internal_inboundReferences_wwppr1$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_s155ff$ = false;
            this.$internal_is_deleted_80ovk2$ = false;
            this.$is_root_g1sn9v$ = false;
            this.$internal_modelElementListeners_q1vpta$ = null;
            this.$internal_modelTreeListeners_w5x1zq$ = null;
            this.$path_cache_4llyek$ = null;
            this.$key_cache_9lzfj6$ = null;
            this.$name_89emlt$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_l9ool9$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this.$typeDefinition_18at2p$ = null;
            this.$dictionary_792vae$ = null;
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.InstanceImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_atfnfe$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_atfnfe$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_y35zoq$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_y35zoq$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_vhr633$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_vhr633$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_4kdsgf$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_4kdsgf$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_219qv8$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_219qv8$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_wwppr1$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_wwppr1$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_s155ff$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_s155ff$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_80ovk2$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_80ovk2$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_g1sn9v$;
              },
              set: function (tmp$0) {
                this.$is_root_g1sn9v$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_q1vpta$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_q1vpta$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_w5x1zq$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_w5x1zq$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_4llyek$;
              },
              set: function (tmp$0) {
                this.$path_cache_4llyek$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_9lzfj6$;
              },
              set: function (tmp$0) {
                this.$key_cache_9lzfj6$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_89emlt$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_89emlt$;
                this.$name_89emlt$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_l9ool9$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_l9ool9$;
                this.$started_l9ool9$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_18at2p$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_18at2p$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_18at2p$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_18at2p$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_18at2p$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_18at2p$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            dictionary: {
              get: function () {
                return this.$dictionary_792vae$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_792vae$, dictionaryP)) {
                if (this.$dictionary_792vae$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_792vae$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_792vae$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_792vae$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_792vae$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_792vae$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Instance;
            }
          }),
          RepositoryImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Repository, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_a6cpb$ = null;
            this.$internal_containmentRefName_bv5tnj$ = null;
            this.$internal_unsetCmd_y7t9hg$ = null;
            this.$internal_readOnlyElem_x4tpbw$ = false;
            this.$internal_recursive_readOnlyElem_7f0bld$ = false;
            this.$internal_inboundReferences_t1jnhu$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_c47wxc$ = false;
            this.$internal_is_deleted_2ikf61$ = false;
            this.$is_root_ypc8o$ = false;
            this.$internal_modelElementListeners_80yh95$ = null;
            this.$internal_modelTreeListeners_9xwvyj$ = null;
            this.$path_cache_kp14yf$ = null;
            this.$key_cache_mu7ust$ = null;
            this.$url_yffns0$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.RepositoryImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_a6cpb$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_a6cpb$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_bv5tnj$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_bv5tnj$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_y7t9hg$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_y7t9hg$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_x4tpbw$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_x4tpbw$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_7f0bld$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_7f0bld$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_t1jnhu$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_t1jnhu$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_c47wxc$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_c47wxc$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_2ikf61$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_2ikf61$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_ypc8o$;
              },
              set: function (tmp$0) {
                this.$is_root_ypc8o$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_80yh95$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_80yh95$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_9xwvyj$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_9xwvyj$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_kp14yf$;
              },
              set: function (tmp$0) {
                this.$path_cache_kp14yf$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_mu7ust$;
              },
              set: function (tmp$0) {
                this.$key_cache_mu7ust$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withUrl: function (p) {
              this.url = p;
              return this;
            },
            url: {
              get: function () {
                return this.$url_yffns0$;
              },
              set: function (iP) {
                this.internal_url(iP, true);
              }
            },
            internal_url: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.url)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$url_yffns0$;
                this.$url_yffns0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.url, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_url, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_url) {
                  this.internal_url(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.url));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.url, _.org.kevoree.util.Constants.Att_url, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Repository;
            }
          }),
          DictionaryTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.DictionaryType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_abqpl7$ = null;
            this.$internal_containmentRefName_th108r$ = null;
            this.$internal_unsetCmd_evew46$ = null;
            this.$internal_readOnlyElem_7s0tm$ = false;
            this.$internal_recursive_readOnlyElem_8w37s9$ = false;
            this.$internal_inboundReferences_6a8xgo$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_tanora$ = false;
            this.$internal_is_deleted_d4hhgj$ = false;
            this.$is_root_fnbw2a$ = false;
            this.$internal_modelElementListeners_njfjeb$ = null;
            this.$internal_modelTreeListeners_ve9xxr$ = null;
            this.$path_cache_o0mo3z$ = null;
            this.$key_cache_x7wu1$ = null;
            this.$generated_KMF_ID_v48n7z$ = '' + Math.random() + (new Date()).getTime();
            this._attributes = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllAttributesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_abqpl7$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_abqpl7$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_th108r$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_th108r$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_evew46$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_evew46$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_7s0tm$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_7s0tm$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_8w37s9$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_8w37s9$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_6a8xgo$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_6a8xgo$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_tanora$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_tanora$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_d4hhgj$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_d4hhgj$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_fnbw2a$;
              },
              set: function (tmp$0) {
                this.$is_root_fnbw2a$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_njfjeb$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_njfjeb$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_ve9xxr$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_ve9xxr$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_o0mo3z$;
              },
              set: function (tmp$0) {
                this.$path_cache_o0mo3z$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_x7wu1$;
              },
              set: function (tmp$0) {
                this.$key_cache_x7wu1$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.attributes.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_v48n7z$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_v48n7z$;
                this.$generated_KMF_ID_v48n7z$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            attributes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._attributes.values());
              },
              set: function (attributesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (attributesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_attributes(attributesP, true, true);
              }
            },
            internal_attributes: function (attributesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._attributes.values(), attributesP)) {
                var kmf_previousVal = this._attributes;
                this._attributes.clear();
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._attributes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_attributes);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, el), _.org.kevoree.util.Constants.Ref_attributes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddAttributes: function (attributesP) {
              var _key_ = attributesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._attributes.containsKey_za3rmp$(_key_)) {
                this._attributes.put_wn2jw4$(_key_, attributesP);
                attributesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_attributes, attributesP), _.org.kevoree.util.Constants.Ref_attributes);
                attributesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_attributes);
              }
            },
            addAttributes: function (attributesP) {
              this.internal_addAttributes(attributesP, true, true);
              return this;
            },
            addAllAttributes: function (attributesP) {
              this.internal_addAllAttributes(attributesP, true, true);
              return this;
            },
            internal_addAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddAttributes(attributesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, null, this, this.path()));
              }
            },
            internal_addAllAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = attributesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddAttributes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = attributesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddAttributes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, null, this, this.path()));
              }
            },
            removeAttributes: function (attributesP) {
              this.internal_removeAttributes(attributesP, true, true);
              return this;
            },
            removeAllAttributes: function () {
              this.internal_removeAllAttributes(true, true);
              return this;
            },
            internal_removeAttributes: function (attributesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._attributes.size() !== 0 && this._attributes.containsKey_za3rmp$(attributesP.internalGetKey())) {
                var previousPathToBeRemoved = attributesP.path();
                this._attributes.remove_za3rmp$(attributesP.internalGetKey());
                attributesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_attributes);
                attributesP.setEContainer(null, null, null);
                if (!this.removeAllAttributesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, attributesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllAttributes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllAttributesCurrentlyProcessing = true;
              }
              var temp_els = this.attributes;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._attributes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_attributes, temp_els, null, this, this.path()));
                this.removeAllAttributesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_attributes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeAttributes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllAttributes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._attributes.size() !== 0 && this._attributes.containsKey_za3rmp$(value)) {
                        var obj = this._attributes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._attributes.remove_za3rmp$(value);
                        this._attributes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findAttributesByID: function (key) {
              return this._attributes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_attributes) {
                  return this.findAttributesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_attributes, _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute)) {
                  {
                    var tmp$0 = this._attributes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._attributes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_attributes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_attributes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_DictionaryType;
            }
          }),
          PortImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Port, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_bvc152$ = null;
            this.$internal_containmentRefName_137kiy$ = null;
            this.$internal_unsetCmd_sgp4aj$ = null;
            this.$internal_readOnlyElem_lu72yj$ = false;
            this.$internal_recursive_readOnlyElem_ggi4h4$ = false;
            this.$internal_inboundReferences_ml4lft$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_em7dbb$ = false;
            this.$internal_is_deleted_92l99q$ = false;
            this.$is_root_virmtb$ = false;
            this.$internal_modelElementListeners_gvwku6$ = null;
            this.$internal_modelTreeListeners_30gi7y$ = null;
            this.$path_cache_59dnk0$ = null;
            this.$key_cache_czftoq$ = null;
            this.$name_hp1bz1$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._bindings = new _.java.util.concurrent.ConcurrentHashMap();
            this.$portTypeRef_or8u3k$ = null;
          }, /** @lends _.org.kevoree.impl.PortImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_bvc152$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_bvc152$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_137kiy$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_137kiy$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_sgp4aj$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_sgp4aj$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_lu72yj$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_lu72yj$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_ggi4h4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_ggi4h4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_ml4lft$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_ml4lft$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_em7dbb$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_em7dbb$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_92l99q$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_92l99q$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_virmtb$;
              },
              set: function (tmp$0) {
                this.$is_root_virmtb$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_gvwku6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_gvwku6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_30gi7y$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_30gi7y$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_59dnk0$;
              },
              set: function (tmp$0) {
                this.$path_cache_59dnk0$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_czftoq$;
              },
              set: function (tmp$0) {
                this.$key_cache_czftoq$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllBindings();
              if (this.portTypeRef != null) {
                var tmp$0;
                ((tmp$0 = this.portTypeRef) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_portTypeRef);
                this.portTypeRef = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_hp1bz1$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_hp1bz1$;
                this.$name_hp1bz1$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            bindings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._bindings.values());
              },
              set: function (bindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (bindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_bindings(bindingsP, true, true);
              }
            },
            internal_bindings: function (bindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._bindings.values(), bindingsP)) {
                var kmf_previousVal = this._bindings;
                this.internal_removeAllBindings(true, false);
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._bindings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddBindings: function (bindingsP) {
              var _key_ = bindingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._bindings.containsKey_za3rmp$(_key_)) {
                this._bindings.put_wn2jw4$(_key_, bindingsP);
                bindingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
              }
            },
            addBindings: function (bindingsP) {
              this.internal_addBindings(bindingsP, true, true);
              return this;
            },
            addAllBindings: function (bindingsP) {
              this.internal_addAllBindings(bindingsP, true, true);
              return this;
            },
            internal_addBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddBindings(bindingsP);
              if (setOpposite) {
                bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            internal_addAllBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = bindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddBindings(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = bindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, null, this, this.path()));
              }
            },
            removeBindings: function (bindingsP) {
              this.internal_removeBindings(bindingsP, true, true);
              return this;
            },
            removeAllBindings: function () {
              this.internal_removeAllBindings(true, true);
              return this;
            },
            internal_removeBindings: function (bindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(bindingsP.internalGetKey())) {
                var previousPathToBeRemoved = bindingsP.path();
                this._bindings.remove_za3rmp$(bindingsP.internalGetKey());
                bindingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, bindingsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  bindingsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                }
              }
            },
            internal_removeAllBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.bindings;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_bindings);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_port, null, false, fireEvents);
                  }
                }
              }
              this._bindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_bindings, temp_els, null, this, this.path()));
              }
            },
            portTypeRef: {
              get: function () {
                return this.$portTypeRef_or8u3k$;
              },
              set: function (portTypeRefP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_portTypeRef(portTypeRefP, true, true);
              }
            },
            internal_portTypeRef: function (portTypeRefP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$portTypeRef_or8u3k$, portTypeRefP)) {
                var kmf_previousVal = this.$portTypeRef_or8u3k$;
                if (portTypeRefP != null) {
                  (portTypeRefP != null ? portTypeRefP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_portTypeRef);
                }
                 else {
                  if (this.$portTypeRef_or8u3k$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$portTypeRef_or8u3k$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_portTypeRef);
                  }
                }
                this.$portTypeRef_or8u3k$ = portTypeRefP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_portTypeRef, portTypeRefP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withPortTypeRef: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_bindings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllBindings(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._bindings.size() !== 0 && this._bindings.containsKey_za3rmp$(value)) {
                        var obj = this._bindings.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._bindings.remove_za3rmp$(value);
                        this._bindings.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_portTypeRef(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_portTypeRef(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_portTypeRef(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findBindingsByID: function (key) {
              return this._bindings.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_bindings) {
                  return this.findBindingsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_portTypeRef) {
                  var objFound = this.portTypeRef;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_bindings, _.org.kevoree.util.Constants.org_kevoree_MBinding)) {
                  {
                    var tmp$0 = this._bindings.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._bindings.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_bindings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_bindings);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef)) {
                  this.internal_visit(visitor, this.portTypeRef, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_portTypeRef);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_portTypeRef);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Port;
            }
          }),
          TypeDefinitionImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.TypeDefinition, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_iaeiwi$ = null;
            this.$internal_containmentRefName_b6ecla$ = null;
            this.$internal_unsetCmd_ghvhbb$ = null;
            this.$internal_readOnlyElem_aeygpz$ = false;
            this.$internal_recursive_readOnlyElem_2rbk30$ = false;
            this.$internal_inboundReferences_4kxylx$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_5f9unh$ = false;
            this.$internal_is_deleted_fhnr16$ = false;
            this.$is_root_c0gd3p$ = false;
            this.$internal_modelElementListeners_xjmu7e$ = null;
            this.$internal_modelTreeListeners_d3naaa$ = null;
            this.$path_cache_s6x66s$ = null;
            this.$key_cache_e2ad86$ = null;
            this.$name_vqbc21$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_ueb44s$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_9dkeku$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_yjvpuk$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.TypeDefinitionImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_iaeiwi$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_iaeiwi$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_b6ecla$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_b6ecla$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_ghvhbb$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_ghvhbb$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_aeygpz$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_aeygpz$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_2rbk30$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_2rbk30$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_4kxylx$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_4kxylx$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_5f9unh$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_5f9unh$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_fhnr16$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_fhnr16$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_c0gd3p$;
              },
              set: function (tmp$0) {
                this.$is_root_c0gd3p$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_xjmu7e$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_xjmu7e$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_d3naaa$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_d3naaa$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_s6x66s$;
              },
              set: function (tmp$0) {
                this.$path_cache_s6x66s$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_e2ad86$;
              },
              set: function (tmp$0) {
                this.$key_cache_e2ad86$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_vqbc21$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_vqbc21$;
                this.$name_vqbc21$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_ueb44s$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_ueb44s$;
                this.$version_ueb44s$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_9dkeku$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_9dkeku$;
                this.$abstract_9dkeku$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_yjvpuk$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_yjvpuk$, dictionaryTypeP)) {
                if (this.$dictionaryType_yjvpuk$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_yjvpuk$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_yjvpuk$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_yjvpuk$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_yjvpuk$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_yjvpuk$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypeDefinition;
            }
          }),
          TypedElementImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.TypedElement, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_2p9ea1$ = null;
            this.$internal_containmentRefName_ogoop$ = null;
            this.$internal_unsetCmd_8v0lpo$ = null;
            this.$internal_readOnlyElem_b5dagc$ = false;
            this.$internal_recursive_readOnlyElem_al615l$ = false;
            this.$internal_inboundReferences_8tq63e$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_h0n10o$ = false;
            this.$internal_is_deleted_5i065d$ = false;
            this.$is_root_r50igg$ = false;
            this.$internal_modelElementListeners_utnavj$ = null;
            this.$internal_modelTreeListeners_2lpmdp$ = null;
            this.$path_cache_498g4v$ = null;
            this.$key_cache_7bw939$ = null;
            this.$name_2bmn4i$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._genericTypes = new _.java.util.concurrent.ConcurrentHashMap();
          }, /** @lends _.org.kevoree.impl.TypedElementImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_2p9ea1$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_2p9ea1$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_ogoop$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_ogoop$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_8v0lpo$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_8v0lpo$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_b5dagc$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_b5dagc$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_al615l$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_al615l$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_8tq63e$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_8tq63e$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_h0n10o$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_h0n10o$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_5i065d$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_5i065d$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_r50igg$;
              },
              set: function (tmp$0) {
                this.$is_root_r50igg$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_utnavj$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_utnavj$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_2lpmdp$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_2lpmdp$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_498g4v$;
              },
              set: function (tmp$0) {
                this.$path_cache_498g4v$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_7bw939$;
              },
              set: function (tmp$0) {
                this.$key_cache_7bw939$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllGenericTypes();
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_2bmn4i$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_2bmn4i$;
                this.$name_2bmn4i$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            genericTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._genericTypes.values());
              },
              set: function (genericTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (genericTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_genericTypes(genericTypesP, true, true);
              }
            },
            internal_genericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._genericTypes.values(), genericTypesP)) {
                var kmf_previousVal = this._genericTypes;
                this._genericTypes.clear();
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._genericTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGenericTypes: function (genericTypesP) {
              var _key_ = genericTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._genericTypes.containsKey_za3rmp$(_key_)) {
                this._genericTypes.put_wn2jw4$(_key_, genericTypesP);
                genericTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
              }
            },
            addGenericTypes: function (genericTypesP) {
              this.internal_addGenericTypes(genericTypesP, true, true);
              return this;
            },
            addAllGenericTypes: function (genericTypesP) {
              this.internal_addAllGenericTypes(genericTypesP, true, true);
              return this;
            },
            internal_addGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGenericTypes(genericTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            internal_addAllGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = genericTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGenericTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = genericTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGenericTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, null, this, this.path()));
              }
            },
            removeGenericTypes: function (genericTypesP) {
              this.internal_removeGenericTypes(genericTypesP, true, true);
              return this;
            },
            removeAllGenericTypes: function () {
              this.internal_removeAllGenericTypes(true, true);
              return this;
            },
            internal_removeGenericTypes: function (genericTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(genericTypesP.internalGetKey())) {
                var previousPathToBeRemoved = genericTypesP.path();
                this._genericTypes.remove_za3rmp$(genericTypesP.internalGetKey());
                genericTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_genericTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, genericTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllGenericTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.genericTypes;
              this._genericTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_genericTypes, temp_els, null, this, this.path()));
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGenericTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllGenericTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._genericTypes.size() !== 0 && this._genericTypes.containsKey_za3rmp$(value)) {
                        var obj = this._genericTypes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._genericTypes.remove_za3rmp$(value);
                        this._genericTypes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findGenericTypesByID: function (key) {
              return this._genericTypes.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_genericTypes) {
                  return this.findGenericTypesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  {
                    var tmp$0 = this._genericTypes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._genericTypes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_genericTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_genericTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_TypedElement;
            }
          }),
          ContainerNodeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ContainerNode, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_ff71em$ = null;
            this.$internal_containmentRefName_5lz5gu$ = null;
            this.$internal_unsetCmd_537mr1$ = null;
            this.$internal_readOnlyElem_pjij83$ = false;
            this.$internal_recursive_readOnlyElem_mlmdhc$ = false;
            this.$internal_inboundReferences_ywu8v3$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_50jgan$ = false;
            this.$internal_is_deleted_cmg9ja$ = false;
            this.$is_root_ets2fr$ = false;
            this.$internal_modelElementListeners_p0q5cm$ = null;
            this.$internal_modelTreeListeners_3oq7ru$ = null;
            this.$path_cache_ixfdyg$ = null;
            this.$key_cache_mxha8y$ = null;
            this.$name_fcvh8r$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$started_k1o3r5$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$host_fcrxuw$ = null;
            this._fragmentDictionary = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllFragmentDictionaryCurrentlyProcessing = false;
            this._hosts = new _.java.util.concurrent.ConcurrentHashMap();
            this.$typeDefinition_ydov9v$ = null;
            this._components = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllComponentsCurrentlyProcessing = false;
            this.$dictionary_72qk9i$ = null;
            this._networkInformation = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllNetworkInformationCurrentlyProcessing = false;
            this._groups = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ContainerNodeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_ff71em$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_ff71em$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_5lz5gu$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_5lz5gu$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_537mr1$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_537mr1$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_pjij83$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_pjij83$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_mlmdhc$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_mlmdhc$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_ywu8v3$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_ywu8v3$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_50jgan$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_50jgan$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_cmg9ja$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_cmg9ja$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_ets2fr$;
              },
              set: function (tmp$0) {
                this.$is_root_ets2fr$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_p0q5cm$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_p0q5cm$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_3oq7ru$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_3oq7ru$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ixfdyg$;
              },
              set: function (tmp$0) {
                this.$path_cache_ixfdyg$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_mxha8y$;
              },
              set: function (tmp$0) {
                this.$key_cache_mxha8y$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              if (this.typeDefinition != null) {
                var tmp$0;
                ((tmp$0 = this.typeDefinition) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                this.typeDefinition = null;
              }
              if (this.dictionary != null) {
                var tmp$1;
                ((tmp$1 = this.dictionary) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                this.dictionary = null;
              }
              {
                var tmp$2 = this.fragmentDictionary.iterator();
                while (tmp$2.hasNext()) {
                  var el = tmp$2.next();
                  el.delete();
                }
              }
              {
                var tmp$3 = this.metaData.iterator();
                while (tmp$3.hasNext()) {
                  var el_0 = tmp$3.next();
                  el_0.delete();
                }
              }
              {
                var tmp$4 = this.components.iterator();
                while (tmp$4.hasNext()) {
                  var el_1 = tmp$4.next();
                  el_1.delete();
                }
              }
              this.removeAllHosts();
              if (this.host != null) {
                var tmp$5;
                ((tmp$5 = this.host) != null ? tmp$5 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_host);
                this.host = null;
              }
              this.removeAllGroups();
              {
                var tmp$6 = this.networkInformation.iterator();
                while (tmp$6.hasNext()) {
                  var el_2 = tmp$6.next();
                  el_2.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$7;
                ((tmp$7 = this.internal_unsetCmd) != null ? tmp$7 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_fcvh8r$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_fcvh8r$;
                this.$name_fcvh8r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withStarted: function (p) {
              this.started = p;
              return this;
            },
            started: {
              get: function () {
                return this.$started_k1o3r5$;
              },
              set: function (iP) {
                this.internal_started(iP, true);
              }
            },
            internal_started: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.started)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$started_k1o3r5$;
                this.$started_k1o3r5$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_started, this.started, kmf_previousVal, this, oldPath));
                }
              }
            },
            host: {
              get: function () {
                return this.$host_fcrxuw$;
              },
              set: function (hostP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_host(hostP, true, true);
              }
            },
            internal_host: function (hostP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$host_fcrxuw$, hostP)) {
                if (setOpposite) {
                  if (this.$host_fcrxuw$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$host_fcrxuw$) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                  if (hostP != null) {
                    hostP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_hosts, this, false, fireEvents);
                  }
                }
                var kmf_previousVal = this.$host_fcrxuw$;
                if (hostP != null) {
                  (hostP != null ? hostP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_host);
                }
                 else {
                  if (this.$host_fcrxuw$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$host_fcrxuw$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_host);
                  }
                }
                this.$host_fcrxuw$ = hostP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_host, hostP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withHost: function (ref) {
              return this;
            },
            fragmentDictionary: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._fragmentDictionary.values());
              },
              set: function (fragmentDictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (fragmentDictionaryP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_fragmentDictionary(fragmentDictionaryP, true, true);
              }
            },
            internal_fragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._fragmentDictionary.values(), fragmentDictionaryP)) {
                var kmf_previousVal = this._fragmentDictionary;
                this._fragmentDictionary.clear();
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._fragmentDictionary.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, el), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddFragmentDictionary: function (fragmentDictionaryP) {
              var _key_ = fragmentDictionaryP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._fragmentDictionary.containsKey_za3rmp$(_key_)) {
                this._fragmentDictionary.put_wn2jw4$(_key_, fragmentDictionaryP);
                fragmentDictionaryP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP), _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
              }
            },
            addFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            addAllFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_addAllFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            internal_addFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddFragmentDictionary(fragmentDictionaryP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            internal_addAllFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = fragmentDictionaryP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddFragmentDictionary(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = fragmentDictionaryP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddFragmentDictionary(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, null, this, this.path()));
              }
            },
            removeFragmentDictionary: function (fragmentDictionaryP) {
              this.internal_removeFragmentDictionary(fragmentDictionaryP, true, true);
              return this;
            },
            removeAllFragmentDictionary: function () {
              this.internal_removeAllFragmentDictionary(true, true);
              return this;
            },
            internal_removeFragmentDictionary: function (fragmentDictionaryP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(fragmentDictionaryP.internalGetKey())) {
                var previousPathToBeRemoved = fragmentDictionaryP.path();
                this._fragmentDictionary.remove_za3rmp$(fragmentDictionaryP.internalGetKey());
                fragmentDictionaryP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                fragmentDictionaryP.setEContainer(null, null, null);
                if (!this.removeAllFragmentDictionaryCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, fragmentDictionaryP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllFragmentDictionary: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllFragmentDictionaryCurrentlyProcessing = true;
              }
              var temp_els = this.fragmentDictionary;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._fragmentDictionary.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_fragmentDictionary, temp_els, null, this, this.path()));
                this.removeAllFragmentDictionaryCurrentlyProcessing = false;
              }
            },
            hosts: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._hosts.values());
              },
              set: function (hostsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hostsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hosts(hostsP, true, true);
              }
            },
            internal_hosts: function (hostsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hosts.values(), hostsP)) {
                var kmf_previousVal = this._hosts;
                this.internal_removeAllHosts(true, false);
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hosts.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddHosts: function (hostsP) {
              var _key_ = hostsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hosts.containsKey_za3rmp$(_key_)) {
                this._hosts.put_wn2jw4$(_key_, hostsP);
                hostsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
              }
            },
            addHosts: function (hostsP) {
              this.internal_addHosts(hostsP, true, true);
              return this;
            },
            addAllHosts: function (hostsP) {
              this.internal_addAllHosts(hostsP, true, true);
              return this;
            },
            internal_addHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHosts(hostsP);
              if (setOpposite) {
                hostsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, null, this, this.path()));
              }
            },
            internal_addAllHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hostsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHosts(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hostsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHosts(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, null, this, this.path()));
              }
            },
            removeHosts: function (hostsP) {
              this.internal_removeHosts(hostsP, true, true);
              return this;
            },
            removeAllHosts: function () {
              this.internal_removeAllHosts(true, true);
              return this;
            },
            internal_removeHosts: function (hostsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hosts.size() !== 0 && this._hosts.containsKey_za3rmp$(hostsP.internalGetKey())) {
                var previousPathToBeRemoved = hostsP.path();
                this._hosts.remove_za3rmp$(hostsP.internalGetKey());
                hostsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, hostsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  hostsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                }
              }
            },
            internal_removeAllHosts: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.hosts;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hosts);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_host, null, false, fireEvents);
                  }
                }
              }
              this._hosts.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_hosts, temp_els, null, this, this.path()));
              }
            },
            typeDefinition: {
              get: function () {
                return this.$typeDefinition_ydov9v$;
              },
              set: function (typeDefinitionP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_typeDefinition(typeDefinitionP, true, true);
              }
            },
            internal_typeDefinition: function (typeDefinitionP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$typeDefinition_ydov9v$, typeDefinitionP)) {
                var kmf_previousVal = this.$typeDefinition_ydov9v$;
                if (typeDefinitionP != null) {
                  (typeDefinitionP != null ? typeDefinitionP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                 else {
                  if (this.$typeDefinition_ydov9v$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$typeDefinition_ydov9v$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_typeDefinition);
                  }
                }
                this.$typeDefinition_ydov9v$ = typeDefinitionP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_typeDefinition, typeDefinitionP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withTypeDefinition: function (ref) {
              return this;
            },
            components: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._components.values());
              },
              set: function (componentsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (componentsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_components(componentsP, true, true);
              }
            },
            internal_components: function (componentsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._components.values(), componentsP)) {
                var kmf_previousVal = this._components;
                this._components.clear();
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._components.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_components);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_components, el), _.org.kevoree.util.Constants.Ref_components);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddComponents: function (componentsP) {
              var _key_ = componentsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._components.containsKey_za3rmp$(_key_)) {
                this._components.put_wn2jw4$(_key_, componentsP);
                componentsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_components, componentsP), _.org.kevoree.util.Constants.Ref_components);
                componentsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_components);
              }
            },
            addComponents: function (componentsP) {
              this.internal_addComponents(componentsP, true, true);
              return this;
            },
            addAllComponents: function (componentsP) {
              this.internal_addAllComponents(componentsP, true, true);
              return this;
            },
            internal_addComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddComponents(componentsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, null, this, this.path()));
              }
            },
            internal_addAllComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = componentsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddComponents(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = componentsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddComponents(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, null, this, this.path()));
              }
            },
            removeComponents: function (componentsP) {
              this.internal_removeComponents(componentsP, true, true);
              return this;
            },
            removeAllComponents: function () {
              this.internal_removeAllComponents(true, true);
              return this;
            },
            internal_removeComponents: function (componentsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._components.size() !== 0 && this._components.containsKey_za3rmp$(componentsP.internalGetKey())) {
                var previousPathToBeRemoved = componentsP.path();
                this._components.remove_za3rmp$(componentsP.internalGetKey());
                componentsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_components);
                componentsP.setEContainer(null, null, null);
                if (!this.removeAllComponentsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, componentsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllComponents: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllComponentsCurrentlyProcessing = true;
              }
              var temp_els = this.components;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._components.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_components, temp_els, null, this, this.path()));
                this.removeAllComponentsCurrentlyProcessing = false;
              }
            },
            dictionary: {
              get: function () {
                return this.$dictionary_72qk9i$;
              },
              set: function (dictionaryP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionary(dictionaryP, true, true);
              }
            },
            internal_dictionary: function (dictionaryP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionary_72qk9i$, dictionaryP)) {
                if (this.$dictionary_72qk9i$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionary_72qk9i$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionary, null), _.org.kevoree.util.Constants.Ref_dictionary);
                }
                var kmf_previousVal = this.$dictionary_72qk9i$;
                if (dictionaryP != null) {
                  (dictionaryP != null ? dictionaryP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                 else {
                  if (this.$dictionary_72qk9i$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionary_72qk9i$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionary);
                  }
                }
                this.$dictionary_72qk9i$ = dictionaryP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionary, dictionaryP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionary: function (ref) {
              return this;
            },
            networkInformation: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._networkInformation.values());
              },
              set: function (networkInformationP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (networkInformationP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_networkInformation(networkInformationP, true, true);
              }
            },
            internal_networkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._networkInformation.values(), networkInformationP)) {
                var kmf_previousVal = this._networkInformation;
                this._networkInformation.clear();
                {
                  var tmp$0 = networkInformationP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._networkInformation.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_networkInformation);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkInformation, el), _.org.kevoree.util.Constants.Ref_networkInformation);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddNetworkInformation: function (networkInformationP) {
              var _key_ = networkInformationP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._networkInformation.containsKey_za3rmp$(_key_)) {
                this._networkInformation.put_wn2jw4$(_key_, networkInformationP);
                networkInformationP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP), _.org.kevoree.util.Constants.Ref_networkInformation);
                networkInformationP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_networkInformation);
              }
            },
            addNetworkInformation: function (networkInformationP) {
              this.internal_addNetworkInformation(networkInformationP, true, true);
              return this;
            },
            addAllNetworkInformation: function (networkInformationP) {
              this.internal_addAllNetworkInformation(networkInformationP, true, true);
              return this;
            },
            internal_addNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNetworkInformation(networkInformationP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, null, this, this.path()));
              }
            },
            internal_addAllNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = networkInformationP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNetworkInformation(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = networkInformationP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNetworkInformation(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, null, this, this.path()));
              }
            },
            removeNetworkInformation: function (networkInformationP) {
              this.internal_removeNetworkInformation(networkInformationP, true, true);
              return this;
            },
            removeAllNetworkInformation: function () {
              this.internal_removeAllNetworkInformation(true, true);
              return this;
            },
            internal_removeNetworkInformation: function (networkInformationP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._networkInformation.size() !== 0 && this._networkInformation.containsKey_za3rmp$(networkInformationP.internalGetKey())) {
                var previousPathToBeRemoved = networkInformationP.path();
                this._networkInformation.remove_za3rmp$(networkInformationP.internalGetKey());
                networkInformationP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_networkInformation);
                networkInformationP.setEContainer(null, null, null);
                if (!this.removeAllNetworkInformationCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, networkInformationP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllNetworkInformation: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNetworkInformationCurrentlyProcessing = true;
              }
              var temp_els = this.networkInformation;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._networkInformation.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_networkInformation, temp_els, null, this, this.path()));
                this.removeAllNetworkInformationCurrentlyProcessing = false;
              }
            },
            groups: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                var kmf_previousVal = this._groups;
                this.internal_removeAllGroups(true, false);
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGroups: function (groupsP) {
              var _key_ = groupsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey_za3rmp$(_key_)) {
                this._groups.put_wn2jw4$(_key_, groupsP);
                groupsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
              }
            },
            addGroups: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
              return this;
            },
            addAllGroups: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
              return this;
            },
            internal_addGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (setOpposite) {
                groupsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            internal_addAllGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            removeGroups: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
              return this;
            },
            removeAllGroups: function () {
              this.internal_removeAllGroups(true, true);
              return this;
            },
            internal_removeGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(groupsP.internalGetKey())) {
                var previousPathToBeRemoved = groupsP.path();
                this._groups.remove_za3rmp$(groupsP.internalGetKey());
                groupsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, groupsP, previousPathToBeRemoved, this, this.path()));
                }
                if (setOpposite) {
                  groupsP.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                }
              }
            },
            internal_removeAllGroups: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.groups;
              if (setOpposite) {
                {
                  var tmp$0 = temp_els.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    el.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                    el.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_subNodes, this, false, fireEvents);
                  }
                }
              }
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_groups, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_started) {
                  this.internal_started(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_typeDefinition(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_typeDefinition(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionary(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionary(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeFragmentDictionary(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllFragmentDictionary();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._fragmentDictionary.size() !== 0 && this._fragmentDictionary.containsKey_za3rmp$(value)) {
                        var obj = this._fragmentDictionary.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._fragmentDictionary.remove_za3rmp$(value);
                        this._fragmentDictionary.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_0 = this._metaData.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_components) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeComponents(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllComponents();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._components.size() !== 0 && this._components.containsKey_za3rmp$(value)) {
                        var obj_1 = this._components.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._components.remove_za3rmp$(value);
                        this._components.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_hosts) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeHosts(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllHosts(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._hosts.size() !== 0 && this._hosts.containsKey_za3rmp$(value)) {
                        var obj_2 = this._hosts.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._hosts.remove_za3rmp$(value);
                        this._hosts.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_host) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_host(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_host(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_host(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.internal_removeAllGroups(setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(value)) {
                        var obj_3 = this._groups.get_za3rmp$(value);
                        var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_3 == null) {
                          throw new Error('Key newed to null ' + obj_3);
                        }
                        this._groups.remove_za3rmp$(value);
                        this._groups.put_wn2jw4$(objNewKey_3, obj_3);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_networkInformation) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeNetworkInformation(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllNetworkInformation();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._networkInformation.size() !== 0 && this._networkInformation.containsKey_za3rmp$(value)) {
                        var obj_4 = this._networkInformation.get_za3rmp$(value);
                        var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_4 == null) {
                          throw new Error('Key newed to null ' + obj_4);
                        }
                        this._networkInformation.remove_za3rmp$(value);
                        this._networkInformation.put_wn2jw4$(objNewKey_4, obj_4);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findFragmentDictionaryByID: function (key) {
              return this._fragmentDictionary.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findComponentsByID: function (key) {
              return this._components.get_za3rmp$(key);
            },
            findHostsByID: function (key) {
              return this._hosts.get_za3rmp$(key);
            },
            findGroupsByID: function (key) {
              return this._groups.get_za3rmp$(key);
            },
            findNetworkInformationByID: function (key) {
              return this._networkInformation.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_typeDefinition) {
                  var objFound = this.typeDefinition;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionary) {
                  var objFound_0 = this.dictionary;
                  if (objFound_0 != null && Kotlin.equals(objFound_0.internalGetKey(), idP)) {
                    return objFound_0;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_fragmentDictionary) {
                  return this.findFragmentDictionaryByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_components) {
                  return this.findComponentsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_hosts) {
                  return this.findHostsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_host) {
                  var objFound_1 = this.host;
                  if (objFound_1 != null && Kotlin.equals(objFound_1.internalGetKey(), idP)) {
                    return objFound_1;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                  return this.findGroupsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_networkInformation) {
                  return this.findNetworkInformationByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionary, _.org.kevoree.util.Constants.org_kevoree_Dictionary)) {
                  this.internal_visit(visitor, this.dictionary, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionary);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary, _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary)) {
                  {
                    var tmp$0 = this._fragmentDictionary.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._fragmentDictionary.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_fragmentDictionary);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_fragmentDictionary);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$1 = this._metaData.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_components, _.org.kevoree.util.Constants.org_kevoree_ComponentInstance)) {
                  {
                    var tmp$2 = this._components.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._components.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_components);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_components);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_networkInformation, _.org.kevoree.util.Constants.org_kevoree_NetworkInfo)) {
                  {
                    var tmp$3 = this._networkInformation.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._networkInformation.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_networkInformation);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_networkInformation);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  this.internal_visit(visitor, this.typeDefinition, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_typeDefinition);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_typeDefinition);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hosts, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  {
                    var tmp$4 = this._hosts.keySet().iterator();
                    while (tmp$4.hasNext()) {
                      var KMFLoopEntryKey_3 = tmp$4.next();
                      this.internal_visit(visitor, this._hosts.get_za3rmp$(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hosts);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hosts);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_host, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  this.internal_visit(visitor, this.host, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_host);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_host);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group)) {
                  {
                    var tmp$5 = this._groups.keySet().iterator();
                    while (tmp$5.hasNext()) {
                      var KMFLoopEntryKey_4 = tmp$5.next();
                      this.internal_visit(visitor, this._groups.get_za3rmp$(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.started, _.org.kevoree.util.Constants.Att_started, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerNode;
            }
          }),
          OperationImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Operation, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_pqk4f2$ = null;
            this.$internal_containmentRefName_27os7i$ = null;
            this.$internal_unsetCmd_5vpuxj$ = null;
            this.$internal_readOnlyElem_z56mjb$ = false;
            this.$internal_recursive_readOnlyElem_gorlz8$ = false;
            this.$internal_inboundReferences_201nfp$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_czmfib$ = false;
            this.$internal_is_deleted_sjawae$ = false;
            this.$is_root_2hwzyz$ = false;
            this.$internal_modelElementListeners_cwp63q$ = null;
            this.$internal_modelTreeListeners_44xpwi$ = null;
            this.$path_cache_arte78$ = null;
            this.$key_cache_ym6fq2$ = null;
            this.$name_p49yk9$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this._parameters = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllParametersCurrentlyProcessing = false;
            this.$returnType_dn3q2u$ = null;
          }, /** @lends _.org.kevoree.impl.OperationImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_pqk4f2$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_pqk4f2$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_27os7i$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_27os7i$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_5vpuxj$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_5vpuxj$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_z56mjb$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_z56mjb$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_gorlz8$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_gorlz8$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_201nfp$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_201nfp$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_czmfib$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_czmfib$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_sjawae$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_sjawae$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_2hwzyz$;
              },
              set: function (tmp$0) {
                this.$is_root_2hwzyz$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_cwp63q$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_cwp63q$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_44xpwi$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_44xpwi$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_arte78$;
              },
              set: function (tmp$0) {
                this.$path_cache_arte78$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ym6fq2$;
              },
              set: function (tmp$0) {
                this.$key_cache_ym6fq2$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.parameters.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              if (this.returnType != null) {
                var tmp$1;
                ((tmp$1 = this.returnType) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_returnType);
                this.returnType = null;
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_p49yk9$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_p49yk9$;
                this.$name_p49yk9$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            parameters: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._parameters.values());
              },
              set: function (parametersP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (parametersP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_parameters(parametersP, true, true);
              }
            },
            internal_parameters: function (parametersP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._parameters.values(), parametersP)) {
                var kmf_previousVal = this._parameters;
                this._parameters.clear();
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._parameters.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_parameters);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, el), _.org.kevoree.util.Constants.Ref_parameters);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddParameters: function (parametersP) {
              var _key_ = parametersP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._parameters.containsKey_za3rmp$(_key_)) {
                this._parameters.put_wn2jw4$(_key_, parametersP);
                parametersP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_parameters, parametersP), _.org.kevoree.util.Constants.Ref_parameters);
                parametersP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_parameters);
              }
            },
            addParameters: function (parametersP) {
              this.internal_addParameters(parametersP, true, true);
              return this;
            },
            addAllParameters: function (parametersP) {
              this.internal_addAllParameters(parametersP, true, true);
              return this;
            },
            internal_addParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddParameters(parametersP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, null, this, this.path()));
              }
            },
            internal_addAllParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = parametersP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddParameters(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = parametersP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddParameters(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, null, this, this.path()));
              }
            },
            removeParameters: function (parametersP) {
              this.internal_removeParameters(parametersP, true, true);
              return this;
            },
            removeAllParameters: function () {
              this.internal_removeAllParameters(true, true);
              return this;
            },
            internal_removeParameters: function (parametersP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._parameters.size() !== 0 && this._parameters.containsKey_za3rmp$(parametersP.internalGetKey())) {
                var previousPathToBeRemoved = parametersP.path();
                this._parameters.remove_za3rmp$(parametersP.internalGetKey());
                parametersP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_parameters);
                parametersP.setEContainer(null, null, null);
                if (!this.removeAllParametersCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, parametersP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllParameters: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllParametersCurrentlyProcessing = true;
              }
              var temp_els = this.parameters;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._parameters.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_parameters, temp_els, null, this, this.path()));
                this.removeAllParametersCurrentlyProcessing = false;
              }
            },
            returnType: {
              get: function () {
                return this.$returnType_dn3q2u$;
              },
              set: function (returnTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_returnType(returnTypeP, true, true);
              }
            },
            internal_returnType: function (returnTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$returnType_dn3q2u$, returnTypeP)) {
                var kmf_previousVal = this.$returnType_dn3q2u$;
                if (returnTypeP != null) {
                  (returnTypeP != null ? returnTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_returnType);
                }
                 else {
                  if (this.$returnType_dn3q2u$ != null) {
                    var tmp$0;
                    ((tmp$0 = this.$returnType_dn3q2u$) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_returnType);
                  }
                }
                this.$returnType_dn3q2u$ = returnTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_returnType, returnTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withReturnType: function (ref) {
              return this;
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_parameters) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeParameters(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllParameters();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._parameters.size() !== 0 && this._parameters.containsKey_za3rmp$(value)) {
                        var obj = this._parameters.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._parameters.remove_za3rmp$(value);
                        this._parameters.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_returnType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_returnType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_returnType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_returnType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findParametersByID: function (key) {
              return this._parameters.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_parameters) {
                  return this.findParametersByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_returnType) {
                  var objFound = this.returnType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_parameters, _.org.kevoree.util.Constants.org_kevoree_Parameter)) {
                  {
                    var tmp$0 = this._parameters.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._parameters.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_parameters);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_parameters);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_returnType, _.org.kevoree.util.Constants.org_kevoree_TypedElement)) {
                  this.internal_visit(visitor, this.returnType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_returnType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_returnType);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Operation;
            }
          }),
          ComponentTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ComponentType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_16ip9q$ = null;
            this.$internal_containmentRefName_u5b5cu$ = null;
            this.$internal_unsetCmd_3rxrnd$ = null;
            this.$internal_readOnlyElem_j7e9vd$ = false;
            this.$internal_recursive_readOnlyElem_ocbfg4$ = false;
            this.$internal_inboundReferences_c2fo45$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_12zpjh$ = false;
            this.$internal_is_deleted_3z9h52$ = false;
            this.$is_root_jjvnxx$ = false;
            this.$internal_modelElementListeners_vhhkc6$ = null;
            this.$internal_modelTreeListeners_w2k31u$ = null;
            this.$path_cache_g5zodw$ = null;
            this.$key_cache_doblxy$ = null;
            this.$name_kd67dj$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_muvtak$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_b99riq$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_n08r3w$ = null;
            this._provided = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllProvidedCurrentlyProcessing = false;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._required = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllRequiredCurrentlyProcessing = false;
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ComponentTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_16ip9q$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_16ip9q$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_u5b5cu$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_u5b5cu$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_3rxrnd$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_3rxrnd$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_j7e9vd$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_j7e9vd$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_ocbfg4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_ocbfg4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_c2fo45$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_c2fo45$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_12zpjh$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_12zpjh$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_3z9h52$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_3z9h52$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_jjvnxx$;
              },
              set: function (tmp$0) {
                this.$is_root_jjvnxx$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_vhhkc6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_vhhkc6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_w2k31u$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_w2k31u$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_g5zodw$;
              },
              set: function (tmp$0) {
                this.$path_cache_g5zodw$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_doblxy$;
              },
              set: function (tmp$0) {
                this.$key_cache_doblxy$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              {
                var tmp$2 = this.required.iterator();
                while (tmp$2.hasNext()) {
                  var el_0 = tmp$2.next();
                  el_0.delete();
                }
              }
              {
                var tmp$3 = this.provided.iterator();
                while (tmp$3.hasNext()) {
                  var el_1 = tmp$3.next();
                  el_1.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$4;
                ((tmp$4 = this.internal_unsetCmd) != null ? tmp$4 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_kd67dj$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_kd67dj$;
                this.$name_kd67dj$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_muvtak$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_muvtak$;
                this.$version_muvtak$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_b99riq$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_b99riq$;
                this.$abstract_b99riq$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_n08r3w$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_n08r3w$, dictionaryTypeP)) {
                if (this.$dictionaryType_n08r3w$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_n08r3w$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_n08r3w$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_n08r3w$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_n08r3w$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_n08r3w$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            provided: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._provided.values());
              },
              set: function (providedP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (providedP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_provided(providedP, true, true);
              }
            },
            internal_provided: function (providedP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._provided.values(), providedP)) {
                var kmf_previousVal = this._provided;
                this._provided.clear();
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._provided.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, el), _.org.kevoree.util.Constants.Ref_provided);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddProvided: function (providedP) {
              var _key_ = providedP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._provided.containsKey_za3rmp$(_key_)) {
                this._provided.put_wn2jw4$(_key_, providedP);
                providedP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_provided, providedP), _.org.kevoree.util.Constants.Ref_provided);
                providedP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
              }
            },
            addProvided: function (providedP) {
              this.internal_addProvided(providedP, true, true);
              return this;
            },
            addAllProvided: function (providedP) {
              this.internal_addAllProvided(providedP, true, true);
              return this;
            },
            internal_addProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddProvided(providedP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            internal_addAllProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = providedP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddProvided(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = providedP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddProvided(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, null, this, this.path()));
              }
            },
            removeProvided: function (providedP) {
              this.internal_removeProvided(providedP, true, true);
              return this;
            },
            removeAllProvided: function () {
              this.internal_removeAllProvided(true, true);
              return this;
            },
            internal_removeProvided: function (providedP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(providedP.internalGetKey())) {
                var previousPathToBeRemoved = providedP.path();
                this._provided.remove_za3rmp$(providedP.internalGetKey());
                providedP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_provided);
                providedP.setEContainer(null, null, null);
                if (!this.removeAllProvidedCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, providedP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllProvided: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllProvidedCurrentlyProcessing = true;
              }
              var temp_els = this.provided;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._provided.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_provided, temp_els, null, this, this.path()));
                this.removeAllProvidedCurrentlyProcessing = false;
              }
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            required: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._required.values());
              },
              set: function (requiredP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (requiredP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_required(requiredP, true, true);
              }
            },
            internal_required: function (requiredP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._required.values(), requiredP)) {
                var kmf_previousVal = this._required;
                this._required.clear();
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._required.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, el), _.org.kevoree.util.Constants.Ref_required);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRequired: function (requiredP) {
              var _key_ = requiredP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._required.containsKey_za3rmp$(_key_)) {
                this._required.put_wn2jw4$(_key_, requiredP);
                requiredP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_required, requiredP), _.org.kevoree.util.Constants.Ref_required);
                requiredP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
              }
            },
            addRequired: function (requiredP) {
              this.internal_addRequired(requiredP, true, true);
              return this;
            },
            addAllRequired: function (requiredP) {
              this.internal_addAllRequired(requiredP, true, true);
              return this;
            },
            internal_addRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRequired(requiredP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            internal_addAllRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = requiredP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRequired(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = requiredP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRequired(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, null, this, this.path()));
              }
            },
            removeRequired: function (requiredP) {
              this.internal_removeRequired(requiredP, true, true);
              return this;
            },
            removeAllRequired: function () {
              this.internal_removeAllRequired(true, true);
              return this;
            },
            internal_removeRequired: function (requiredP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(requiredP.internalGetKey())) {
                var previousPathToBeRemoved = requiredP.path();
                this._required.remove_za3rmp$(requiredP.internalGetKey());
                requiredP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_required);
                requiredP.setEContainer(null, null, null);
                if (!this.removeAllRequiredCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, requiredP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRequired: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRequiredCurrentlyProcessing = true;
              }
              var temp_els = this.required;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._required.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_required, temp_els, null, this, this.path()));
                this.removeAllRequiredCurrentlyProcessing = false;
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_required) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRequired(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRequired();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._required.size() !== 0 && this._required.containsKey_za3rmp$(value)) {
                        var obj_2 = this._required.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._required.remove_za3rmp$(value);
                        this._required.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_provided) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeProvided(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllProvided();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._provided.size() !== 0 && this._provided.containsKey_za3rmp$(value)) {
                        var obj_3 = this._provided.get_za3rmp$(value);
                        var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_3 == null) {
                          throw new Error('Key newed to null ' + obj_3);
                        }
                        this._provided.remove_za3rmp$(value);
                        this._provided.put_wn2jw4$(objNewKey_3, obj_3);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findRequiredByID: function (key) {
              return this._required.get_za3rmp$(key);
            },
            findProvidedByID: function (key) {
              return this._provided.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_required) {
                  return this.findRequiredByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_provided) {
                  return this.findProvidedByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_required, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef)) {
                  {
                    var tmp$1 = this._required.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._required.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_required);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_required);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_provided, _.org.kevoree.util.Constants.org_kevoree_PortTypeRef)) {
                  {
                    var tmp$2 = this._provided.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._provided.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_provided);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_provided);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$3 = this._deployUnits.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$4 = this._superTypes.keySet().iterator();
                    while (tmp$4.hasNext()) {
                      var KMFLoopEntryKey_3 = tmp$4.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ComponentType;
            }
          }),
          DictionaryImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Dictionary, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_k4mdcr$ = null;
            this.$internal_containmentRefName_g7blud$ = null;
            this.$internal_unsetCmd_eeb2i8$ = null;
            this.$internal_readOnlyElem_2akz4g$ = false;
            this.$internal_recursive_readOnlyElem_4zk8hv$ = false;
            this.$internal_inboundReferences_bams8y$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_weooqs$ = false;
            this.$internal_is_deleted_hbvlhf$ = false;
            this.$is_root_6jhz4k$ = false;
            this.$internal_modelElementListeners_jvapyr$ = null;
            this.$internal_modelTreeListeners_i4kjjd$ = null;
            this.$path_cache_g2g5fv$ = null;
            this.$key_cache_fyp1nj$ = null;
            this.$generated_KMF_ID_gzg1jr$ = '' + Math.random() + (new Date()).getTime();
            this._values = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllValuesCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.DictionaryImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_k4mdcr$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_k4mdcr$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_g7blud$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_g7blud$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_eeb2i8$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_eeb2i8$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_2akz4g$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_2akz4g$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_4zk8hv$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_4zk8hv$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_bams8y$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_bams8y$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_weooqs$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_weooqs$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_hbvlhf$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_hbvlhf$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_6jhz4k$;
              },
              set: function (tmp$0) {
                this.$is_root_6jhz4k$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_jvapyr$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_jvapyr$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_i4kjjd$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_i4kjjd$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_g2g5fv$;
              },
              set: function (tmp$0) {
                this.$path_cache_g2g5fv$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_fyp1nj$;
              },
              set: function (tmp$0) {
                this.$key_cache_fyp1nj$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.values.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$1;
                ((tmp$1 = this.internal_unsetCmd) != null ? tmp$1 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_gzg1jr$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_gzg1jr$;
                this.$generated_KMF_ID_gzg1jr$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            values: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._values.values());
              },
              set: function (valuesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (valuesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_values(valuesP, true, true);
              }
            },
            internal_values: function (valuesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._values.values(), valuesP)) {
                var kmf_previousVal = this._values;
                this._values.clear();
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._values.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, el), _.org.kevoree.util.Constants.Ref_values);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddValues: function (valuesP) {
              var _key_ = valuesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._values.containsKey_za3rmp$(_key_)) {
                this._values.put_wn2jw4$(_key_, valuesP);
                valuesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_values, valuesP), _.org.kevoree.util.Constants.Ref_values);
                valuesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
              }
            },
            addValues: function (valuesP) {
              this.internal_addValues(valuesP, true, true);
              return this;
            },
            addAllValues: function (valuesP) {
              this.internal_addAllValues(valuesP, true, true);
              return this;
            },
            internal_addValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddValues(valuesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            internal_addAllValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = valuesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddValues(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = valuesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddValues(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, null, this, this.path()));
              }
            },
            removeValues: function (valuesP) {
              this.internal_removeValues(valuesP, true, true);
              return this;
            },
            removeAllValues: function () {
              this.internal_removeAllValues(true, true);
              return this;
            },
            internal_removeValues: function (valuesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(valuesP.internalGetKey())) {
                var previousPathToBeRemoved = valuesP.path();
                this._values.remove_za3rmp$(valuesP.internalGetKey());
                valuesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_values);
                valuesP.setEContainer(null, null, null);
                if (!this.removeAllValuesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, valuesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllValues: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllValuesCurrentlyProcessing = true;
              }
              var temp_els = this.values;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._values.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_values, temp_els, null, this, this.path()));
                this.removeAllValuesCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_values) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeValues(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllValues();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._values.size() !== 0 && this._values.containsKey_za3rmp$(value)) {
                        var obj = this._values.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._values.remove_za3rmp$(value);
                        this._values.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findValuesByID: function (key) {
              return this._values.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_values) {
                  return this.findValuesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_values, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._values.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._values.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_values);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_values);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Dictionary;
            }
          }),
          NamedElementImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.NamedElement, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_8krigo$ = null;
            this.$internal_containmentRefName_b6nctk$ = null;
            this.$internal_unsetCmd_l75xml$ = null;
            this.$internal_readOnlyElem_ndc2pv$ = false;
            this.$internal_recursive_readOnlyElem_rvab4m$ = false;
            this.$internal_inboundReferences_bgglkl$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_r66dux$ = false;
            this.$internal_is_deleted_bdiac0$ = false;
            this.$is_root_4096f3$ = false;
            this.$internal_modelElementListeners_rhbydc$ = null;
            this.$internal_modelTreeListeners_d3waik$ = null;
            this.$path_cache_ez6iq$ = null;
            this.$key_cache_yz673o$ = null;
            this.$name_rkp09r$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.NamedElementImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_8krigo$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_8krigo$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_b6nctk$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_b6nctk$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_l75xml$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_l75xml$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_ndc2pv$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_ndc2pv$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_rvab4m$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_rvab4m$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_bgglkl$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_bgglkl$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_r66dux$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_r66dux$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_bdiac0$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_bdiac0$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_4096f3$;
              },
              set: function (tmp$0) {
                this.$is_root_4096f3$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_rhbydc$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_rhbydc$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_d3waik$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_d3waik$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ez6iq$;
              },
              set: function (tmp$0) {
                this.$path_cache_ez6iq$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_yz673o$;
              },
              set: function (tmp$0) {
                this.$key_cache_yz673o$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_rkp09r$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_rkp09r$;
                this.$name_rkp09r$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_NamedElement;
            }
          }),
          ValueImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.Value, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_uv178$ = null;
            this.$internal_containmentRefName_qtk5h8$ = null;
            this.$internal_unsetCmd_47w2zj$ = null;
            this.$internal_readOnlyElem_7uz0yp$ = false;
            this.$internal_recursive_readOnlyElem_km7vxu$ = false;
            this.$internal_inboundReferences_3ctd4f$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_3s3le5$ = false;
            this.$internal_is_deleted_3nlt2k$ = false;
            this.$is_root_dw4jvp$ = false;
            this.$internal_modelElementListeners_tjebvo$ = null;
            this.$internal_modelTreeListeners_owb7s8$ = null;
            this.$path_cache_e2vdqy$ = null;
            this.$key_cache_n1wff4$ = null;
            this.$name_drlocj$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$value_glagx$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
          }, /** @lends _.org.kevoree.impl.ValueImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_uv178$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_uv178$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_qtk5h8$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_qtk5h8$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_47w2zj$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_47w2zj$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_7uz0yp$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_7uz0yp$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_km7vxu$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_km7vxu$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_3ctd4f$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_3ctd4f$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_3s3le5$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_3s3le5$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_3nlt2k$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_3nlt2k$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_dw4jvp$;
              },
              set: function (tmp$0) {
                this.$is_root_dw4jvp$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_tjebvo$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_tjebvo$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_owb7s8$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_owb7s8$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_e2vdqy$;
              },
              set: function (tmp$0) {
                this.$path_cache_e2vdqy$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_n1wff4$;
              },
              set: function (tmp$0) {
                this.$key_cache_n1wff4$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_drlocj$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_drlocj$;
                this.$name_drlocj$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withValue: function (p) {
              this.value = p;
              return this;
            },
            value: {
              get: function () {
                return this.$value_glagx$;
              },
              set: function (iP) {
                this.internal_value(iP, true);
              }
            },
            internal_value: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.value)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$value_glagx$;
                this.$value_glagx$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_value, this.value, kmf_previousVal, this, oldPath));
                }
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_value) {
                  this.internal_value(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name));
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.value, _.org.kevoree.util.Constants.Att_value, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_Value;
            }
          }),
          ContainerRootImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ContainerRoot, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_dv9q2q$ = null;
            this.$internal_containmentRefName_7fk4aa$ = null;
            this.$internal_unsetCmd_9fvvn7$ = null;
            this.$internal_readOnlyElem_5emnqr$ = false;
            this.$internal_recursive_readOnlyElem_qqvtb4$ = false;
            this.$internal_inboundReferences_yhoz9b$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_7ajevz$ = false;
            this.$internal_is_deleted_go0hy2$ = false;
            this.$is_root_te1ulz$ = false;
            this.$internal_modelElementListeners_vka3d6$ = null;
            this.$internal_modelTreeListeners_9ct1za$ = null;
            this.$path_cache_bkt1u0$ = null;
            this.$key_cache_ozfj7m$ = null;
            this.$generated_KMF_ID_vwh4di$ = '' + Math.random() + (new Date()).getTime();
            this._mBindings = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMBindingsCurrentlyProcessing = false;
            this._packages = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllPackagesCurrentlyProcessing = false;
            this._repositories = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllRepositoriesCurrentlyProcessing = false;
            this._nodes = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllNodesCurrentlyProcessing = false;
            this._groups = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllGroupsCurrentlyProcessing = false;
            this._hubs = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllHubsCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ContainerRootImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_dv9q2q$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_dv9q2q$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_7fk4aa$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_7fk4aa$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_9fvvn7$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_9fvvn7$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_5emnqr$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_5emnqr$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_qqvtb4$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_qqvtb4$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_yhoz9b$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_yhoz9b$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_7ajevz$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_7ajevz$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_go0hy2$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_go0hy2$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_te1ulz$;
              },
              set: function (tmp$0) {
                this.$is_root_te1ulz$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_vka3d6$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_vka3d6$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_9ct1za$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_9ct1za$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_bkt1u0$;
              },
              set: function (tmp$0) {
                this.$path_cache_bkt1u0$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_ozfj7m$;
              },
              set: function (tmp$0) {
                this.$key_cache_ozfj7m$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              {
                var tmp$0 = this.nodes.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.delete();
                }
              }
              {
                var tmp$1 = this.repositories.iterator();
                while (tmp$1.hasNext()) {
                  var el_0 = tmp$1.next();
                  el_0.delete();
                }
              }
              {
                var tmp$2 = this.hubs.iterator();
                while (tmp$2.hasNext()) {
                  var el_1 = tmp$2.next();
                  el_1.delete();
                }
              }
              {
                var tmp$3 = this.mBindings.iterator();
                while (tmp$3.hasNext()) {
                  var el_2 = tmp$3.next();
                  el_2.delete();
                }
              }
              {
                var tmp$4 = this.groups.iterator();
                while (tmp$4.hasNext()) {
                  var el_3 = tmp$4.next();
                  el_3.delete();
                }
              }
              {
                var tmp$5 = this.packages.iterator();
                while (tmp$5.hasNext()) {
                  var el_4 = tmp$5.next();
                  el_4.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$6;
                ((tmp$6 = this.internal_unsetCmd) != null ? tmp$6 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_vwh4di$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_vwh4di$;
                this.$generated_KMF_ID_vwh4di$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            mBindings: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._mBindings.values());
              },
              set: function (mBindingsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (mBindingsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_mBindings(mBindingsP, true, true);
              }
            },
            internal_mBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._mBindings.values(), mBindingsP)) {
                var kmf_previousVal = this._mBindings;
                this._mBindings.clear();
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._mBindings.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mBindings);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, el), _.org.kevoree.util.Constants.Ref_mBindings);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMBindings: function (mBindingsP) {
              var _key_ = mBindingsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._mBindings.containsKey_za3rmp$(_key_)) {
                this._mBindings.put_wn2jw4$(_key_, mBindingsP);
                mBindingsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP), _.org.kevoree.util.Constants.Ref_mBindings);
                mBindingsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_mBindings);
              }
            },
            addMBindings: function (mBindingsP) {
              this.internal_addMBindings(mBindingsP, true, true);
              return this;
            },
            addAllMBindings: function (mBindingsP) {
              this.internal_addAllMBindings(mBindingsP, true, true);
              return this;
            },
            internal_addMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMBindings(mBindingsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, null, this, this.path()));
              }
            },
            internal_addAllMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = mBindingsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMBindings(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = mBindingsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMBindings(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, null, this, this.path()));
              }
            },
            removeMBindings: function (mBindingsP) {
              this.internal_removeMBindings(mBindingsP, true, true);
              return this;
            },
            removeAllMBindings: function () {
              this.internal_removeAllMBindings(true, true);
              return this;
            },
            internal_removeMBindings: function (mBindingsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._mBindings.size() !== 0 && this._mBindings.containsKey_za3rmp$(mBindingsP.internalGetKey())) {
                var previousPathToBeRemoved = mBindingsP.path();
                this._mBindings.remove_za3rmp$(mBindingsP.internalGetKey());
                mBindingsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_mBindings);
                mBindingsP.setEContainer(null, null, null);
                if (!this.removeAllMBindingsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, mBindingsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMBindings: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMBindingsCurrentlyProcessing = true;
              }
              var temp_els = this.mBindings;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._mBindings.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_mBindings, temp_els, null, this, this.path()));
                this.removeAllMBindingsCurrentlyProcessing = false;
              }
            },
            packages: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._packages.values());
              },
              set: function (packagesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (packagesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_packages(packagesP, true, true);
              }
            },
            internal_packages: function (packagesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._packages.values(), packagesP)) {
                var kmf_previousVal = this._packages;
                this._packages.clear();
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._packages.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, el), _.org.kevoree.util.Constants.Ref_packages);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddPackages: function (packagesP) {
              var _key_ = packagesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._packages.containsKey_za3rmp$(_key_)) {
                this._packages.put_wn2jw4$(_key_, packagesP);
                packagesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_packages, packagesP), _.org.kevoree.util.Constants.Ref_packages);
                packagesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
              }
            },
            addPackages: function (packagesP) {
              this.internal_addPackages(packagesP, true, true);
              return this;
            },
            addAllPackages: function (packagesP) {
              this.internal_addAllPackages(packagesP, true, true);
              return this;
            },
            internal_addPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddPackages(packagesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            internal_addAllPackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = packagesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddPackages(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = packagesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddPackages(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, null, this, this.path()));
              }
            },
            removePackages: function (packagesP) {
              this.internal_removePackages(packagesP, true, true);
              return this;
            },
            removeAllPackages: function () {
              this.internal_removeAllPackages(true, true);
              return this;
            },
            internal_removePackages: function (packagesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(packagesP.internalGetKey())) {
                var previousPathToBeRemoved = packagesP.path();
                this._packages.remove_za3rmp$(packagesP.internalGetKey());
                packagesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_packages);
                packagesP.setEContainer(null, null, null);
                if (!this.removeAllPackagesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, packagesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllPackages: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllPackagesCurrentlyProcessing = true;
              }
              var temp_els = this.packages;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._packages.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_packages, temp_els, null, this, this.path()));
                this.removeAllPackagesCurrentlyProcessing = false;
              }
            },
            repositories: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._repositories.values());
              },
              set: function (repositoriesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (repositoriesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_repositories(repositoriesP, true, true);
              }
            },
            internal_repositories: function (repositoriesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._repositories.values(), repositoriesP)) {
                var kmf_previousVal = this._repositories;
                this._repositories.clear();
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._repositories.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_repositories);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, el), _.org.kevoree.util.Constants.Ref_repositories);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddRepositories: function (repositoriesP) {
              var _key_ = repositoriesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._repositories.containsKey_za3rmp$(_key_)) {
                this._repositories.put_wn2jw4$(_key_, repositoriesP);
                repositoriesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP), _.org.kevoree.util.Constants.Ref_repositories);
                repositoriesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_repositories);
              }
            },
            addRepositories: function (repositoriesP) {
              this.internal_addRepositories(repositoriesP, true, true);
              return this;
            },
            addAllRepositories: function (repositoriesP) {
              this.internal_addAllRepositories(repositoriesP, true, true);
              return this;
            },
            internal_addRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddRepositories(repositoriesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, null, this, this.path()));
              }
            },
            internal_addAllRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = repositoriesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddRepositories(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = repositoriesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddRepositories(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, null, this, this.path()));
              }
            },
            removeRepositories: function (repositoriesP) {
              this.internal_removeRepositories(repositoriesP, true, true);
              return this;
            },
            removeAllRepositories: function () {
              this.internal_removeAllRepositories(true, true);
              return this;
            },
            internal_removeRepositories: function (repositoriesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._repositories.size() !== 0 && this._repositories.containsKey_za3rmp$(repositoriesP.internalGetKey())) {
                var previousPathToBeRemoved = repositoriesP.path();
                this._repositories.remove_za3rmp$(repositoriesP.internalGetKey());
                repositoriesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_repositories);
                repositoriesP.setEContainer(null, null, null);
                if (!this.removeAllRepositoriesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, repositoriesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllRepositories: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllRepositoriesCurrentlyProcessing = true;
              }
              var temp_els = this.repositories;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._repositories.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_repositories, temp_els, null, this, this.path()));
                this.removeAllRepositoriesCurrentlyProcessing = false;
              }
            },
            nodes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._nodes.values());
              },
              set: function (nodesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (nodesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_nodes(nodesP, true, true);
              }
            },
            internal_nodes: function (nodesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._nodes.values(), nodesP)) {
                var kmf_previousVal = this._nodes;
                this._nodes.clear();
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._nodes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_nodes);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, el), _.org.kevoree.util.Constants.Ref_nodes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddNodes: function (nodesP) {
              var _key_ = nodesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._nodes.containsKey_za3rmp$(_key_)) {
                this._nodes.put_wn2jw4$(_key_, nodesP);
                nodesP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_nodes, nodesP), _.org.kevoree.util.Constants.Ref_nodes);
                nodesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_nodes);
              }
            },
            addNodes: function (nodesP) {
              this.internal_addNodes(nodesP, true, true);
              return this;
            },
            addAllNodes: function (nodesP) {
              this.internal_addAllNodes(nodesP, true, true);
              return this;
            },
            internal_addNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddNodes(nodesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, null, this, this.path()));
              }
            },
            internal_addAllNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = nodesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddNodes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = nodesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddNodes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, null, this, this.path()));
              }
            },
            removeNodes: function (nodesP) {
              this.internal_removeNodes(nodesP, true, true);
              return this;
            },
            removeAllNodes: function () {
              this.internal_removeAllNodes(true, true);
              return this;
            },
            internal_removeNodes: function (nodesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._nodes.size() !== 0 && this._nodes.containsKey_za3rmp$(nodesP.internalGetKey())) {
                var previousPathToBeRemoved = nodesP.path();
                this._nodes.remove_za3rmp$(nodesP.internalGetKey());
                nodesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_nodes);
                nodesP.setEContainer(null, null, null);
                if (!this.removeAllNodesCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, nodesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllNodes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllNodesCurrentlyProcessing = true;
              }
              var temp_els = this.nodes;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._nodes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_nodes, temp_els, null, this, this.path()));
                this.removeAllNodesCurrentlyProcessing = false;
              }
            },
            groups: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._groups.values());
              },
              set: function (groupsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (groupsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_groups(groupsP, true, true);
              }
            },
            internal_groups: function (groupsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._groups.values(), groupsP)) {
                var kmf_previousVal = this._groups;
                this._groups.clear();
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._groups.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, el), _.org.kevoree.util.Constants.Ref_groups);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddGroups: function (groupsP) {
              var _key_ = groupsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._groups.containsKey_za3rmp$(_key_)) {
                this._groups.put_wn2jw4$(_key_, groupsP);
                groupsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_groups, groupsP), _.org.kevoree.util.Constants.Ref_groups);
                groupsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
              }
            },
            addGroups: function (groupsP) {
              this.internal_addGroups(groupsP, true, true);
              return this;
            },
            addAllGroups: function (groupsP) {
              this.internal_addAllGroups(groupsP, true, true);
              return this;
            },
            internal_addGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddGroups(groupsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            internal_addAllGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = groupsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddGroups(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = groupsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddGroups(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, null, this, this.path()));
              }
            },
            removeGroups: function (groupsP) {
              this.internal_removeGroups(groupsP, true, true);
              return this;
            },
            removeAllGroups: function () {
              this.internal_removeAllGroups(true, true);
              return this;
            },
            internal_removeGroups: function (groupsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(groupsP.internalGetKey())) {
                var previousPathToBeRemoved = groupsP.path();
                this._groups.remove_za3rmp$(groupsP.internalGetKey());
                groupsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_groups);
                groupsP.setEContainer(null, null, null);
                if (!this.removeAllGroupsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, groupsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllGroups: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllGroupsCurrentlyProcessing = true;
              }
              var temp_els = this.groups;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._groups.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_groups, temp_els, null, this, this.path()));
                this.removeAllGroupsCurrentlyProcessing = false;
              }
            },
            hubs: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._hubs.values());
              },
              set: function (hubsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (hubsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_hubs(hubsP, true, true);
              }
            },
            internal_hubs: function (hubsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._hubs.values(), hubsP)) {
                var kmf_previousVal = this._hubs;
                this._hubs.clear();
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._hubs.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hubs);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, el), _.org.kevoree.util.Constants.Ref_hubs);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddHubs: function (hubsP) {
              var _key_ = hubsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._hubs.containsKey_za3rmp$(_key_)) {
                this._hubs.put_wn2jw4$(_key_, hubsP);
                hubsP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_hubs, hubsP), _.org.kevoree.util.Constants.Ref_hubs);
                hubsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_hubs);
              }
            },
            addHubs: function (hubsP) {
              this.internal_addHubs(hubsP, true, true);
              return this;
            },
            addAllHubs: function (hubsP) {
              this.internal_addAllHubs(hubsP, true, true);
              return this;
            },
            internal_addHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddHubs(hubsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, null, this, this.path()));
              }
            },
            internal_addAllHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = hubsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddHubs(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = hubsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddHubs(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, null, this, this.path()));
              }
            },
            removeHubs: function (hubsP) {
              this.internal_removeHubs(hubsP, true, true);
              return this;
            },
            removeAllHubs: function () {
              this.internal_removeAllHubs(true, true);
              return this;
            },
            internal_removeHubs: function (hubsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._hubs.size() !== 0 && this._hubs.containsKey_za3rmp$(hubsP.internalGetKey())) {
                var previousPathToBeRemoved = hubsP.path();
                this._hubs.remove_za3rmp$(hubsP.internalGetKey());
                hubsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_hubs);
                hubsP.setEContainer(null, null, null);
                if (!this.removeAllHubsCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, hubsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllHubs: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllHubsCurrentlyProcessing = true;
              }
              var temp_els = this.hubs;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._hubs.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_hubs, temp_els, null, this, this.path()));
                this.removeAllHubsCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_nodes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeNodes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllNodes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._nodes.size() !== 0 && this._nodes.containsKey_za3rmp$(value)) {
                        var obj = this._nodes.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._nodes.remove_za3rmp$(value);
                        this._nodes.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_repositories) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeRepositories(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllRepositories();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._repositories.size() !== 0 && this._repositories.containsKey_za3rmp$(value)) {
                        var obj_0 = this._repositories.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._repositories.remove_za3rmp$(value);
                        this._repositories.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_hubs) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeHubs(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllHubs();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._hubs.size() !== 0 && this._hubs.containsKey_za3rmp$(value)) {
                        var obj_1 = this._hubs.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._hubs.remove_za3rmp$(value);
                        this._hubs.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_mBindings) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMBindings(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMBindings();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._mBindings.size() !== 0 && this._mBindings.containsKey_za3rmp$(value)) {
                        var obj_2 = this._mBindings.get_za3rmp$(value);
                        var objNewKey_2 = (obj_2 != null ? obj_2 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_2 == null) {
                          throw new Error('Key newed to null ' + obj_2);
                        }
                        this._mBindings.remove_za3rmp$(value);
                        this._mBindings.put_wn2jw4$(objNewKey_2, obj_2);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_groups) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeGroups(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllGroups();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._groups.size() !== 0 && this._groups.containsKey_za3rmp$(value)) {
                        var obj_3 = this._groups.get_za3rmp$(value);
                        var objNewKey_3 = (obj_3 != null ? obj_3 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_3 == null) {
                          throw new Error('Key newed to null ' + obj_3);
                        }
                        this._groups.remove_za3rmp$(value);
                        this._groups.put_wn2jw4$(objNewKey_3, obj_3);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_packages) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllPackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removePackages(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllPackages();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._packages.size() !== 0 && this._packages.containsKey_za3rmp$(value)) {
                        var obj_4 = this._packages.get_za3rmp$(value);
                        var objNewKey_4 = (obj_4 != null ? obj_4 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_4 == null) {
                          throw new Error('Key newed to null ' + obj_4);
                        }
                        this._packages.remove_za3rmp$(value);
                        this._packages.put_wn2jw4$(objNewKey_4, obj_4);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findNodesByID: function (key) {
              return this._nodes.get_za3rmp$(key);
            },
            findRepositoriesByID: function (key) {
              return this._repositories.get_za3rmp$(key);
            },
            findHubsByID: function (key) {
              return this._hubs.get_za3rmp$(key);
            },
            findMBindingsByID: function (key) {
              return this._mBindings.get_za3rmp$(key);
            },
            findGroupsByID: function (key) {
              return this._groups.get_za3rmp$(key);
            },
            findPackagesByID: function (key) {
              return this._packages.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_nodes) {
                  return this.findNodesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_repositories) {
                  return this.findRepositoriesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_hubs) {
                  return this.findHubsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_mBindings) {
                  return this.findMBindingsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_groups) {
                  return this.findGroupsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_packages) {
                  return this.findPackagesByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_nodes, _.org.kevoree.util.Constants.org_kevoree_ContainerNode)) {
                  {
                    var tmp$0 = this._nodes.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._nodes.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_nodes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_nodes);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_repositories, _.org.kevoree.util.Constants.org_kevoree_Repository)) {
                  {
                    var tmp$1 = this._repositories.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._repositories.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_repositories);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_repositories);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_hubs, _.org.kevoree.util.Constants.org_kevoree_Channel)) {
                  {
                    var tmp$2 = this._hubs.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._hubs.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_hubs);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_hubs);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_mBindings, _.org.kevoree.util.Constants.org_kevoree_MBinding)) {
                  {
                    var tmp$3 = this._mBindings.keySet().iterator();
                    while (tmp$3.hasNext()) {
                      var KMFLoopEntryKey_2 = tmp$3.next();
                      this.internal_visit(visitor, this._mBindings.get_za3rmp$(KMFLoopEntryKey_2), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_mBindings);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_mBindings);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_groups, _.org.kevoree.util.Constants.org_kevoree_Group)) {
                  {
                    var tmp$4 = this._groups.keySet().iterator();
                    while (tmp$4.hasNext()) {
                      var KMFLoopEntryKey_3 = tmp$4.next();
                      this.internal_visit(visitor, this._groups.get_za3rmp$(KMFLoopEntryKey_3), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_groups);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_groups);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_packages, _.org.kevoree.util.Constants.org_kevoree_Package)) {
                  {
                    var tmp$5 = this._packages.keySet().iterator();
                    while (tmp$5.hasNext()) {
                      var KMFLoopEntryKey_4 = tmp$5.next();
                      this.internal_visit(visitor, this._packages.get_za3rmp$(KMFLoopEntryKey_4), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_packages);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_packages);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ContainerRoot;
            }
          }),
          ChannelTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.ChannelType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_p3y5rc$ = null;
            this.$internal_containmentRefName_yewt20$ = null;
            this.$internal_unsetCmd_ybs3xv$ = null;
            this.$internal_readOnlyElem_kjnzn$ = false;
            this.$internal_recursive_readOnlyElem_4yqmva$ = false;
            this.$internal_inboundReferences_9wwhuj$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_jce2mf$ = false;
            this.$internal_is_deleted_rwoxmo$ = false;
            this.$is_root_rpf5xt$ = false;
            this.$internal_modelElementListeners_3tuwy8$ = null;
            this.$internal_modelTreeListeners_yoyb84$ = null;
            this.$path_cache_dqee6q$ = null;
            this.$key_cache_utnug4$ = null;
            this.$name_2jcrtd$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_wxesu$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_x4svag$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$lowerBindings_2eifxl$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$upperBindings_qtzjre$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$lowerFragments_p02ne0$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$upperFragments_zkcbr$ = _.org.kevoree.util.Constants.INT_DEFAULTVAL;
            this.$dictionaryType_v1n452$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.ChannelTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_p3y5rc$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_p3y5rc$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_yewt20$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_yewt20$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_ybs3xv$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_ybs3xv$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_kjnzn$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_kjnzn$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_4yqmva$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_4yqmva$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_9wwhuj$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_9wwhuj$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_jce2mf$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_jce2mf$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_rwoxmo$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_rwoxmo$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_rpf5xt$;
              },
              set: function (tmp$0) {
                this.$is_root_rpf5xt$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_3tuwy8$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_3tuwy8$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_yoyb84$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_yoyb84$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_dqee6q$;
              },
              set: function (tmp$0) {
                this.$path_cache_dqee6q$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_utnug4$;
              },
              set: function (tmp$0) {
                this.$key_cache_utnug4$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_2jcrtd$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_2jcrtd$;
                this.$name_2jcrtd$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_wxesu$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_wxesu$;
                this.$version_wxesu$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_x4svag$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_x4svag$;
                this.$abstract_x4svag$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            withLowerBindings: function (p) {
              this.lowerBindings = p;
              return this;
            },
            lowerBindings: {
              get: function () {
                return this.$lowerBindings_2eifxl$;
              },
              set: function (iP) {
                this.internal_lowerBindings(iP, true);
              }
            },
            internal_lowerBindings: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerBindings) {
                var oldPath = this.path();
                var kmf_previousVal = this.$lowerBindings_2eifxl$;
                this.$lowerBindings_2eifxl$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerBindings, this.lowerBindings, kmf_previousVal, this, oldPath));
                }
              }
            },
            withUpperBindings: function (p) {
              this.upperBindings = p;
              return this;
            },
            upperBindings: {
              get: function () {
                return this.$upperBindings_qtzjre$;
              },
              set: function (iP) {
                this.internal_upperBindings(iP, true);
              }
            },
            internal_upperBindings: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperBindings) {
                var oldPath = this.path();
                var kmf_previousVal = this.$upperBindings_qtzjre$;
                this.$upperBindings_qtzjre$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperBindings, this.upperBindings, kmf_previousVal, this, oldPath));
                }
              }
            },
            withLowerFragments: function (p) {
              this.lowerFragments = p;
              return this;
            },
            lowerFragments: {
              get: function () {
                return this.$lowerFragments_p02ne0$;
              },
              set: function (iP) {
                this.internal_lowerFragments(iP, true);
              }
            },
            internal_lowerFragments: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.lowerFragments) {
                var oldPath = this.path();
                var kmf_previousVal = this.$lowerFragments_p02ne0$;
                this.$lowerFragments_p02ne0$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_lowerFragments, this.lowerFragments, kmf_previousVal, this, oldPath));
                }
              }
            },
            withUpperFragments: function (p) {
              this.upperFragments = p;
              return this;
            },
            upperFragments: {
              get: function () {
                return this.$upperFragments_zkcbr$;
              },
              set: function (iP) {
                this.internal_upperFragments(iP, true);
              }
            },
            internal_upperFragments: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (iP !== this.upperFragments) {
                var oldPath = this.path();
                var kmf_previousVal = this.$upperFragments_zkcbr$;
                this.$upperFragments_zkcbr$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_upperFragments, this.upperFragments, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_v1n452$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_v1n452$, dictionaryTypeP)) {
                if (this.$dictionaryType_v1n452$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_v1n452$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_v1n452$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_v1n452$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_v1n452$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_v1n452$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_lowerBindings) {
                  this.internal_lowerBindings(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_upperBindings) {
                  this.internal_upperBindings(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_lowerFragments) {
                  this.internal_lowerFragments(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_upperFragments) {
                  this.internal_upperFragments(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.upperFragments, _.org.kevoree.util.Constants.Att_upperFragments, this);
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.upperBindings, _.org.kevoree.util.Constants.Att_upperBindings, this);
              visitor.visit(this.lowerBindings, _.org.kevoree.util.Constants.Att_lowerBindings, this);
              visitor.visit(this.lowerFragments, _.org.kevoree.util.Constants.Att_lowerFragments, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_ChannelType;
            }
          }),
          PortTypeMappingImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.PortTypeMapping, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_hxvi0e$ = null;
            this.$internal_containmentRefName_8oqxdq$ = null;
            this.$internal_unsetCmd_ftwvtv$ = null;
            this.$internal_readOnlyElem_v4nxer$ = false;
            this.$internal_recursive_readOnlyElem_mrxc4w$ = false;
            this.$internal_inboundReferences_atc4a9$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_7wzzjl$ = false;
            this.$internal_is_deleted_f54q52$ = false;
            this.$is_root_jgjmah$ = false;
            this.$internal_modelElementListeners_bmvbyy$ = null;
            this.$internal_modelTreeListeners_6rhzoq$ = null;
            this.$path_cache_5fvza0$ = null;
            this.$key_cache_vnrmsy$ = null;
            this.$beanMethodName_ostbqs$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$serviceMethodName_uert8v$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$paramTypes_6h3gkk$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$generated_KMF_ID_yedsty$ = '' + Math.random() + (new Date()).getTime();
          }, /** @lends _.org.kevoree.impl.PortTypeMappingImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_hxvi0e$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_hxvi0e$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_8oqxdq$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_8oqxdq$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_ftwvtv$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_ftwvtv$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_v4nxer$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_v4nxer$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_mrxc4w$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_mrxc4w$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_atc4a9$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_atc4a9$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_7wzzjl$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_7wzzjl$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_f54q52$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_f54q52$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_jgjmah$;
              },
              set: function (tmp$0) {
                this.$is_root_jgjmah$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_bmvbyy$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_bmvbyy$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_6rhzoq$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_6rhzoq$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_5fvza0$;
              },
              set: function (tmp$0) {
                this.$path_cache_5fvza0$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_vnrmsy$;
              },
              set: function (tmp$0) {
                this.$key_cache_vnrmsy$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$0;
                ((tmp$0 = this.internal_unsetCmd) != null ? tmp$0 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withBeanMethodName: function (p) {
              this.beanMethodName = p;
              return this;
            },
            beanMethodName: {
              get: function () {
                return this.$beanMethodName_ostbqs$;
              },
              set: function (iP) {
                this.internal_beanMethodName(iP, true);
              }
            },
            internal_beanMethodName: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.beanMethodName)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$beanMethodName_ostbqs$;
                this.$beanMethodName_ostbqs$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_beanMethodName, this.beanMethodName, kmf_previousVal, this, oldPath));
                }
              }
            },
            withServiceMethodName: function (p) {
              this.serviceMethodName = p;
              return this;
            },
            serviceMethodName: {
              get: function () {
                return this.$serviceMethodName_uert8v$;
              },
              set: function (iP) {
                this.internal_serviceMethodName(iP, true);
              }
            },
            internal_serviceMethodName: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.serviceMethodName)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$serviceMethodName_uert8v$;
                this.$serviceMethodName_uert8v$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_serviceMethodName, this.serviceMethodName, kmf_previousVal, this, oldPath));
                }
              }
            },
            withParamTypes: function (p) {
              this.paramTypes = p;
              return this;
            },
            paramTypes: {
              get: function () {
                return this.$paramTypes_6h3gkk$;
              },
              set: function (iP) {
                this.internal_paramTypes(iP, true);
              }
            },
            internal_paramTypes: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.paramTypes)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$paramTypes_6h3gkk$;
                this.$paramTypes_6h3gkk$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_paramTypes, this.paramTypes, kmf_previousVal, this, oldPath));
                }
              }
            },
            withGenerated_KMF_ID: function (p) {
              this.generated_KMF_ID = p;
              return this;
            },
            generated_KMF_ID: {
              get: function () {
                return this.$generated_KMF_ID_yedsty$;
              },
              set: function (iP) {
                this.internal_generated_KMF_ID(iP, true);
              }
            },
            internal_generated_KMF_ID: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.generated_KMF_ID)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$generated_KMF_ID_yedsty$;
                this.$generated_KMF_ID_yedsty$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.generated_KMF_ID, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_beanMethodName) {
                  this.internal_beanMethodName(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_serviceMethodName) {
                  this.internal_serviceMethodName(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_paramTypes) {
                  this.internal_paramTypes(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_generated_KMF_ID) {
                  this.internal_generated_KMF_ID(value, fireEvents);
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = this.generated_KMF_ID;
              }
              return this.key_cache;
            },
            findByID: function (relationName, idP) {
              {
                {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.generated_KMF_ID, _.org.kevoree.util.Constants.Att_generated_KMF_ID, this);
              visitor.visit(this.paramTypes, _.org.kevoree.util.Constants.Att_paramTypes, this);
              visitor.visit(this.serviceMethodName, _.org.kevoree.util.Constants.Att_serviceMethodName, this);
              visitor.visit(this.beanMethodName, _.org.kevoree.util.Constants.Att_beanMethodName, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping;
            }
          }),
          GroupTypeImpl: Kotlin.createClass(function () {
            return [_.org.kevoree.GroupType, _.org.kevoree.container.KMFContainerImpl];
          }, function () {
            this.$internal_eContainer_abyt0s$ = null;
            this.$internal_containmentRefName_7uf86c$ = null;
            this.$internal_unsetCmd_pvvwdz$ = null;
            this.$internal_readOnlyElem_5sbm5z$ = false;
            this.$internal_recursive_readOnlyElem_ukepe2$ = false;
            this.$internal_inboundReferences_nizx0p$ = new Kotlin.ComplexHashMap();
            this.$internal_deleteInProgress_be3cej$ = false;
            this.$internal_is_deleted_d4pkw4$ = false;
            this.$is_root_uo75sd$ = false;
            this.$internal_modelElementListeners_98kc98$ = null;
            this.$internal_modelTreeListeners_5x6ahc$ = null;
            this.$path_cache_ep7swe$ = null;
            this.$key_cache_lou2so$ = null;
            this.$name_7marjf$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$version_21ul1q$ = _.org.kevoree.util.Constants.STRING_DEFAULTVAL;
            this.$abstract_gzbdck$ = _.org.kevoree.util.Constants.BOOLEAN_DEFAULTVAL;
            this.$dictionaryType_2y33ei$ = null;
            this._deployUnits = new _.java.util.concurrent.ConcurrentHashMap();
            this._superTypes = new _.java.util.concurrent.ConcurrentHashMap();
            this._metaData = new _.java.util.concurrent.ConcurrentHashMap();
            this.removeAllMetaDataCurrentlyProcessing = false;
          }, /** @lends _.org.kevoree.impl.GroupTypeImpl.prototype */ {
            internal_eContainer: {
              get: function () {
                return this.$internal_eContainer_abyt0s$;
              },
              set: function (tmp$0) {
                this.$internal_eContainer_abyt0s$ = tmp$0;
              }
            },
            internal_containmentRefName: {
              get: function () {
                return this.$internal_containmentRefName_7uf86c$;
              },
              set: function (tmp$0) {
                this.$internal_containmentRefName_7uf86c$ = tmp$0;
              }
            },
            internal_unsetCmd: {
              get: function () {
                return this.$internal_unsetCmd_pvvwdz$;
              },
              set: function (tmp$0) {
                this.$internal_unsetCmd_pvvwdz$ = tmp$0;
              }
            },
            internal_readOnlyElem: {
              get: function () {
                return this.$internal_readOnlyElem_5sbm5z$;
              },
              set: function (tmp$0) {
                this.$internal_readOnlyElem_5sbm5z$ = tmp$0;
              }
            },
            internal_recursive_readOnlyElem: {
              get: function () {
                return this.$internal_recursive_readOnlyElem_ukepe2$;
              },
              set: function (tmp$0) {
                this.$internal_recursive_readOnlyElem_ukepe2$ = tmp$0;
              }
            },
            internal_inboundReferences: {
              get: function () {
                return this.$internal_inboundReferences_nizx0p$;
              },
              set: function (tmp$0) {
                this.$internal_inboundReferences_nizx0p$ = tmp$0;
              }
            },
            internal_deleteInProgress: {
              get: function () {
                return this.$internal_deleteInProgress_be3cej$;
              },
              set: function (tmp$0) {
                this.$internal_deleteInProgress_be3cej$ = tmp$0;
              }
            },
            internal_is_deleted: {
              get: function () {
                return this.$internal_is_deleted_d4pkw4$;
              },
              set: function (tmp$0) {
                this.$internal_is_deleted_d4pkw4$ = tmp$0;
              }
            },
            is_root: {
              get: function () {
                return this.$is_root_uo75sd$;
              },
              set: function (tmp$0) {
                this.$is_root_uo75sd$ = tmp$0;
              }
            },
            internal_modelElementListeners: {
              get: function () {
                return this.$internal_modelElementListeners_98kc98$;
              },
              set: function (tmp$0) {
                this.$internal_modelElementListeners_98kc98$ = tmp$0;
              }
            },
            internal_modelTreeListeners: {
              get: function () {
                return this.$internal_modelTreeListeners_5x6ahc$;
              },
              set: function (tmp$0) {
                this.$internal_modelTreeListeners_5x6ahc$ = tmp$0;
              }
            },
            path_cache: {
              get: function () {
                return this.$path_cache_ep7swe$;
              },
              set: function (tmp$0) {
                this.$path_cache_ep7swe$ = tmp$0;
              }
            },
            key_cache: {
              get: function () {
                return this.$key_cache_lou2so$;
              },
              set: function (tmp$0) {
                this.$key_cache_lou2so$ = tmp$0;
              }
            },
            delete: function () {
              this.internal_deleteInProgress = true;
              this.removeAllDeployUnits();
              this.removeAllSuperTypes();
              if (this.dictionaryType != null) {
                var tmp$0;
                ((tmp$0 = this.dictionaryType) != null ? tmp$0 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                this.dictionaryType = null;
              }
              {
                var tmp$1 = this.metaData.iterator();
                while (tmp$1.hasNext()) {
                  var el = tmp$1.next();
                  el.delete();
                }
              }
              this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, this);
              this.internal_inboundReferences.clear();
              if (this.internal_unsetCmd != null) {
                var tmp$2;
                ((tmp$2 = this.internal_unsetCmd) != null ? tmp$2 : Kotlin.throwNPE()).run();
              }
              this.internal_is_deleted = true;
            },
            withName: function (p) {
              this.name = p;
              return this;
            },
            name: {
              get: function () {
                return this.$name_7marjf$;
              },
              set: function (iP) {
                this.internal_name(iP, true);
              }
            },
            internal_name: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.name)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$name_7marjf$;
                this.$name_7marjf$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.name, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_name, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withVersion: function (p) {
              this.version = p;
              return this;
            },
            version: {
              get: function () {
                return this.$version_21ul1q$;
              },
              set: function (iP) {
                this.internal_version(iP, true);
              }
            },
            internal_version: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.version)) {
                var oldPath = this.path();
                var oldId = this.internalGetKey();
                this.path_cache = null;
                this.key_cache = null;
                var previousParent = this.eContainer();
                var previousRefNameInParent = this.getRefInParent();
                var kmf_previousVal = this.$version_21ul1q$;
                this.$version_21ul1q$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.version, kmf_previousVal, this, oldPath));
                }
                if (previousParent != null) {
                  previousParent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, previousRefNameInParent != null ? previousRefNameInParent : Kotlin.throwNPE(), oldId, false, false);
                }
                this.advertiseInboundRefs(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, oldId);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_version, this.path(), null, this, oldPath));
                }
                this.visit(_.org.kevoree.container.cleanCacheVisitor, true, true, false);
              }
            },
            withAbstract: function (p) {
              this.abstract = p;
              return this;
            },
            abstract: {
              get: function () {
                return this.$abstract_gzbdck$;
              },
              set: function (iP) {
                this.internal_abstract(iP, true);
              }
            },
            internal_abstract: function (iP, fireEvents) {
              if (fireEvents === void 0)
                fireEvents = true;
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (!Kotlin.equals(iP, this.abstract)) {
                var oldPath = this.path();
                var kmf_previousVal = this.$abstract_gzbdck$;
                this.$abstract_gzbdck$ = iP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE, _.org.kevoree.util.Constants.Att_abstract, this.abstract, kmf_previousVal, this, oldPath));
                }
              }
            },
            dictionaryType: {
              get: function () {
                return this.$dictionaryType_2y33ei$;
              },
              set: function (dictionaryTypeP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                this.internal_dictionaryType(dictionaryTypeP, true, true);
              }
            },
            internal_dictionaryType: function (dictionaryTypeP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this.$dictionaryType_2y33ei$, dictionaryTypeP)) {
                if (this.$dictionaryType_2y33ei$ != null) {
                  var tmp$0;
                  ((tmp$0 = this.$dictionaryType_2y33ei$) != null ? tmp$0 : Kotlin.throwNPE()).setEContainer(null, null, null);
                }
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.util.Constants.Ref_dictionaryType, null), _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                var kmf_previousVal = this.$dictionaryType_2y33ei$;
                if (dictionaryTypeP != null) {
                  (dictionaryTypeP != null ? dictionaryTypeP : Kotlin.throwNPE()).addInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                 else {
                  if (this.$dictionaryType_2y33ei$ != null) {
                    var tmp$1;
                    ((tmp$1 = this.$dictionaryType_2y33ei$) != null ? tmp$1 : Kotlin.throwNPE()).removeInboundReference(this, _.org.kevoree.util.Constants.Ref_dictionaryType);
                  }
                }
                this.$dictionaryType_2y33ei$ = dictionaryTypeP;
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_dictionaryType, dictionaryTypeP, kmf_previousVal, this, this.path()));
                }
              }
            },
            withDictionaryType: function (ref) {
              return this;
            },
            deployUnits: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._deployUnits.values());
              },
              set: function (deployUnitsP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (deployUnitsP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_deployUnits(deployUnitsP, true, true);
              }
            },
            internal_deployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._deployUnits.values(), deployUnitsP)) {
                var kmf_previousVal = this._deployUnits;
                this._deployUnits.clear();
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._deployUnits.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddDeployUnits: function (deployUnitsP) {
              var _key_ = deployUnitsP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._deployUnits.containsKey_za3rmp$(_key_)) {
                this._deployUnits.put_wn2jw4$(_key_, deployUnitsP);
                deployUnitsP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
              }
            },
            addDeployUnits: function (deployUnitsP) {
              this.internal_addDeployUnits(deployUnitsP, true, true);
              return this;
            },
            addAllDeployUnits: function (deployUnitsP) {
              this.internal_addAllDeployUnits(deployUnitsP, true, true);
              return this;
            },
            internal_addDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddDeployUnits(deployUnitsP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            internal_addAllDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = deployUnitsP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddDeployUnits(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = deployUnitsP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddDeployUnits(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, null, this, this.path()));
              }
            },
            removeDeployUnits: function (deployUnitsP) {
              this.internal_removeDeployUnits(deployUnitsP, true, true);
              return this;
            },
            removeAllDeployUnits: function () {
              this.internal_removeAllDeployUnits(true, true);
              return this;
            },
            internal_removeDeployUnits: function (deployUnitsP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(deployUnitsP.internalGetKey())) {
                var previousPathToBeRemoved = deployUnitsP.path();
                this._deployUnits.remove_za3rmp$(deployUnitsP.internalGetKey());
                deployUnitsP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_deployUnits);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, deployUnitsP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllDeployUnits: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.deployUnits;
              this._deployUnits.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_deployUnits, temp_els, null, this, this.path()));
              }
            },
            superTypes: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._superTypes.values());
              },
              set: function (superTypesP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (superTypesP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_superTypes(superTypesP, true, true);
              }
            },
            internal_superTypes: function (superTypesP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._superTypes.values(), superTypesP)) {
                var kmf_previousVal = this._superTypes;
                this._superTypes.clear();
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._superTypes.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddSuperTypes: function (superTypesP) {
              var _key_ = superTypesP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._superTypes.containsKey_za3rmp$(_key_)) {
                this._superTypes.put_wn2jw4$(_key_, superTypesP);
                superTypesP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
              }
            },
            addSuperTypes: function (superTypesP) {
              this.internal_addSuperTypes(superTypesP, true, true);
              return this;
            },
            addAllSuperTypes: function (superTypesP) {
              this.internal_addAllSuperTypes(superTypesP, true, true);
              return this;
            },
            internal_addSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddSuperTypes(superTypesP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            internal_addAllSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = superTypesP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddSuperTypes(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = superTypesP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddSuperTypes(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, null, this, this.path()));
              }
            },
            removeSuperTypes: function (superTypesP) {
              this.internal_removeSuperTypes(superTypesP, true, true);
              return this;
            },
            removeAllSuperTypes: function () {
              this.internal_removeAllSuperTypes(true, true);
              return this;
            },
            internal_removeSuperTypes: function (superTypesP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(superTypesP.internalGetKey())) {
                var previousPathToBeRemoved = superTypesP.path();
                this._superTypes.remove_za3rmp$(superTypesP.internalGetKey());
                superTypesP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_superTypes);
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, superTypesP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllSuperTypes: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              var temp_els = this.superTypes;
              this._superTypes.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.REFERENCE, _.org.kevoree.util.Constants.Ref_superTypes, temp_els, null, this, this.path()));
              }
            },
            metaData: {
              get: function () {
                return _.kotlin.toList_h3panj$(this._metaData.values());
              },
              set: function (metaDataP) {
                if (this.isReadOnly()) {
                  throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
                }
                if (metaDataP == null) {
                  throw new Kotlin.IllegalArgumentException(_.org.kevoree.util.Constants.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION);
                }
                this.internal_metaData(metaDataP, true, true);
              }
            },
            internal_metaData: function (metaDataP, setOpposite, fireEvents) {
              if (!Kotlin.equals(this._metaData.values(), metaDataP)) {
                var kmf_previousVal = this._metaData;
                this._metaData.clear();
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    var elKey = el.internalGetKey();
                    if (elKey == null) {
                      throw new Error(_.org.kevoree.util.Constants.ELEMENT_HAS_NO_KEY_IN_COLLECTION);
                    }
                    this._metaData.put_wn2jw4$(elKey != null ? elKey : Kotlin.throwNPE(), el);
                    el.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                    el.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, el), _.org.kevoree.util.Constants.Ref_metaData);
                  }
                }
                if (fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.SET, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, kmf_previousVal, this, this.path()));
                }
              }
            },
            doAddMetaData: function (metaDataP) {
              var _key_ = metaDataP.internalGetKey();
              if (_key_ == null || Kotlin.equals(_key_, '')) {
                throw new Error(_.org.kevoree.util.Constants.EMPTY_KEY);
              }
              if (!this._metaData.containsKey_za3rmp$(_key_)) {
                this._metaData.put_wn2jw4$(_key_, metaDataP);
                metaDataP.setEContainer(this, new _.org.kevoree.container.RemoveFromContainerCommand(this, _.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.util.Constants.Ref_metaData, metaDataP), _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.addInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
              }
            },
            addMetaData: function (metaDataP) {
              this.internal_addMetaData(metaDataP, true, true);
              return this;
            },
            addAllMetaData: function (metaDataP) {
              this.internal_addAllMetaData(metaDataP, true, true);
              return this;
            },
            internal_addMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              this.doAddMetaData(metaDataP);
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            internal_addAllMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (setOpposite) {
                {
                  var tmp$0 = metaDataP.iterator();
                  while (tmp$0.hasNext()) {
                    var el = tmp$0.next();
                    this.doAddMetaData(el);
                  }
                }
              }
               else {
                {
                  var tmp$1 = metaDataP.iterator();
                  while (tmp$1.hasNext()) {
                    var el_0 = tmp$1.next();
                    this.doAddMetaData(el_0);
                  }
                }
              }
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, null, this, this.path()));
              }
            },
            removeMetaData: function (metaDataP) {
              this.internal_removeMetaData(metaDataP, true, true);
              return this;
            },
            removeAllMetaData: function () {
              this.internal_removeAllMetaData(true, true);
              return this;
            },
            internal_removeMetaData: function (metaDataP, setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(metaDataP.internalGetKey())) {
                var previousPathToBeRemoved = metaDataP.path();
                this._metaData.remove_za3rmp$(metaDataP.internalGetKey());
                metaDataP.removeInboundReference(this, _.org.kevoree.util.Constants.Ref_metaData);
                metaDataP.setEContainer(null, null, null);
                if (!this.removeAllMetaDataCurrentlyProcessing && fireEvents) {
                  this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, metaDataP, previousPathToBeRemoved, this, this.path()));
                }
              }
            },
            internal_removeAllMetaData: function (setOpposite, fireEvents) {
              if (this.isReadOnly()) {
                throw new Error(_.org.kevoree.util.Constants.READ_ONLY_EXCEPTION);
              }
              if (fireEvents) {
                this.removeAllMetaDataCurrentlyProcessing = true;
              }
              var temp_els = this.metaData;
              {
                var tmp$0 = temp_els.iterator();
                while (tmp$0.hasNext()) {
                  var el = tmp$0.next();
                  el.setEContainer(null, null, null);
                }
              }
              this._metaData.clear();
              if (fireEvents) {
                this.fireModelEvent(new _.org.kevoree.modeling.api.events.ModelEvent(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, _.org.kevoree.modeling.api.util.ElementAttributeType.object.CONTAINMENT, _.org.kevoree.util.Constants.Ref_metaData, temp_els, null, this, this.path()));
                this.removeAllMetaDataCurrentlyProcessing = false;
              }
            },
            reflexiveMutator: function (mutationType, refName, value, setOpposite, fireEvents) {
              {
                if (refName === _.org.kevoree.util.Constants.Att_name) {
                  this.internal_name(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_version) {
                  this.internal_version(value, fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Att_abstract) {
                  this.internal_abstract(Kotlin.equals('true', value) || Kotlin.equals(true, value), fireEvents);
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeDeployUnits(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllDeployUnits();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._deployUnits.size() !== 0 && this._deployUnits.containsKey_za3rmp$(value)) {
                        var obj = this._deployUnits.get_za3rmp$(value);
                        var objNewKey = (obj != null ? obj : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey == null) {
                          throw new Error('Key newed to null ' + obj);
                        }
                        this._deployUnits.remove_za3rmp$(value);
                        this._deployUnits.put_wn2jw4$(objNewKey, obj);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeSuperTypes(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllSuperTypes();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._superTypes.size() !== 0 && this._superTypes.containsKey_za3rmp$(value)) {
                        var obj_0 = this._superTypes.get_za3rmp$(value);
                        var objNewKey_0 = (obj_0 != null ? obj_0 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_0 == null) {
                          throw new Error('Key newed to null ' + obj_0);
                        }
                        this._superTypes.remove_za3rmp$(value);
                        this._superTypes.put_wn2jw4$(objNewKey_0, obj_0);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_dictionaryType(null, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_dictionaryType(value, setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else if (refName === _.org.kevoree.util.Constants.Ref_metaData) {
                  {
                    if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      this.internal_addMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      this.internal_addAllMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      this.internal_removeMetaData(value != null ? value : Kotlin.throwNPE(), setOpposite, fireEvents);
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      this.removeAllMetaData();
                    }
                     else if (mutationType === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                      if (this._metaData.size() !== 0 && this._metaData.containsKey_za3rmp$(value)) {
                        var obj_1 = this._metaData.get_za3rmp$(value);
                        var objNewKey_1 = (obj_1 != null ? obj_1 : Kotlin.throwNPE()).internalGetKey();
                        if (objNewKey_1 == null) {
                          throw new Error('Key newed to null ' + obj_1);
                        }
                        this._metaData.remove_za3rmp$(value);
                        this._metaData.put_wn2jw4$(objNewKey_1, obj_1);
                      }
                    }
                     else {
                      throw new Error(_.org.kevoree.util.Constants.UNKNOWN_MUTATION_TYPE_EXCEPTION + mutationType);
                    }
                  }
                }
                 else {
                  throw new Error('Can not reflexively ' + mutationType + ' for ' + refName + ' on ' + this);
                }
              }
            },
            internalGetKey: function () {
              if (this.key_cache != null) {
                return this.key_cache;
              }
               else {
                this.key_cache = 'name=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.name)) + ',version=' + Kotlin.toString(_.org.kevoree.modeling.api.util.KevURLEncoder.encode(this.version));
              }
              return this.key_cache;
            },
            findDeployUnitsByHashcodeNameVersion: function (hashcode, name, version) {
              return this.findDeployUnitsByID('hashcode=' + hashcode + ',name=' + name + ',version=' + version);
            },
            findDeployUnitsByID: function (key) {
              return this._deployUnits.get_za3rmp$(key);
            },
            findSuperTypesByNameVersion: function (name, version) {
              return this.findSuperTypesByID('name=' + name + ',version=' + version);
            },
            findSuperTypesByID: function (key) {
              return this._superTypes.get_za3rmp$(key);
            },
            findMetaDataByID: function (key) {
              return this._metaData.get_za3rmp$(key);
            },
            findByID: function (relationName, idP) {
              {
                if (relationName === _.org.kevoree.util.Constants.Ref_deployUnits) {
                  return this.findDeployUnitsByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_superTypes) {
                  return this.findSuperTypesByID(idP);
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_dictionaryType) {
                  var objFound = this.dictionaryType;
                  if (objFound != null && Kotlin.equals(objFound.internalGetKey(), idP)) {
                    return objFound;
                  }
                   else {
                    return null;
                  }
                }
                 else if (relationName === _.org.kevoree.util.Constants.Ref_metaData) {
                  return this.findMetaDataByID(idP);
                }
                 else {
                  return null;
                }
              }
            },
            visit: function (visitor, recursive, containedReference, nonContainedReference) {
              visitor.beginVisitElem(this);
              if (containedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType, _.org.kevoree.util.Constants.org_kevoree_DictionaryType)) {
                  this.internal_visit(visitor, this.dictionaryType, recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_dictionaryType);
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_dictionaryType);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_metaData, _.org.kevoree.util.Constants.org_kevoree_Value)) {
                  {
                    var tmp$0 = this._metaData.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var KMFLoopEntryKey = tmp$0.next();
                      this.internal_visit(visitor, this._metaData.get_za3rmp$(KMFLoopEntryKey), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_metaData);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_metaData);
              }
              if (nonContainedReference) {
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits, _.org.kevoree.util.Constants.org_kevoree_DeployUnit)) {
                  {
                    var tmp$1 = this._deployUnits.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var KMFLoopEntryKey_0 = tmp$1.next();
                      this.internal_visit(visitor, this._deployUnits.get_za3rmp$(KMFLoopEntryKey_0), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_deployUnits);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_deployUnits);
                if (visitor.beginVisitRef(_.org.kevoree.util.Constants.Ref_superTypes, _.org.kevoree.util.Constants.org_kevoree_TypeDefinition)) {
                  {
                    var tmp$2 = this._superTypes.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var KMFLoopEntryKey_1 = tmp$2.next();
                      this.internal_visit(visitor, this._superTypes.get_za3rmp$(KMFLoopEntryKey_1), recursive, containedReference, nonContainedReference, _.org.kevoree.util.Constants.Ref_superTypes);
                    }
                  }
                }
                visitor.endVisitRef(_.org.kevoree.util.Constants.Ref_superTypes);
              }
              visitor.endVisitElem(this);
            },
            visitAttributes: function (visitor) {
              visitor.visit(this.abstract, _.org.kevoree.util.Constants.Att_abstract, this);
              visitor.visit(this.name, _.org.kevoree.util.Constants.Att_name, this);
              visitor.visit(this.version, _.org.kevoree.util.Constants.Att_version, this);
            },
            metaClassName: function () {
              return _.org.kevoree.util.Constants.org_kevoree_GroupType;
            }
          })
        }),
        util: Kotlin.definePackage(function () {
          this.Constants = Kotlin.createObject(null, function () {
            this.UNKNOWN_MUTATION_TYPE_EXCEPTION = 'Unknown mutation type: ';
            this.READ_ONLY_EXCEPTION = 'This model is ReadOnly. Elements are not modifiable.';
            this.LIST_PARAMETER_OF_SET_IS_NULL_EXCEPTION = 'The list in parameter of the setter cannot be null. Use removeAll to empty a collection.';
            this.ELEMENT_HAS_NO_KEY_IN_COLLECTION = 'Cannot set the collection, because at least one element of it has no key!';
            this.EMPTY_KEY = 'Key empty : please set the attribute key before adding the object.';
            this.KMFQL_CONTAINED = 'contained';
            this.STRING_DEFAULTVAL = '';
            this.INT_DEFAULTVAL = 0;
            this.BOOLEAN_DEFAULTVAL = false;
            this.CHAR_DEFAULTVAL = 'a';
            this.SHORT_DEFAULTVAL = 0;
            this.LONG_DEFAULTVAL = 0.0;
            this.DOUBLE_DEFAULTVAL = 0.0;
            this.FLOAT_DEFAULTVAL = 0;
            this.BYTE_DEFAULTVAL = 0;
            this.Ref_superTypes = 'superTypes';
            this.org_kevoree_Instance = 'org.kevoree.Instance';
            this.Att_defaultValue = 'defaultValue';
            this.Ref_provided = 'provided';
            this.Att_started = 'started';
            this.org_kevoree_TypedElement = 'org.kevoree.TypedElement';
            this.org_kevoree_PortTypeMapping = 'org.kevoree.PortTypeMapping';
            this.Ref_hub = 'hub';
            this.java_lang_Boolean = 'java.lang.Boolean';
            this.Ref_dictionaryType = 'dictionaryType';
            this.Att_upperBindings = 'upperBindings';
            this.Ref_host = 'host';
            this.Ref_returnType = 'returnType';
            this.Ref_port = 'port';
            this.Att_url = 'url';
            this.Ref_portTypeRef = 'portTypeRef';
            this.org_kevoree_NodeType = 'org.kevoree.NodeType';
            this.Ref_values = 'values';
            this.org_kevoree_Package = 'org.kevoree.Package';
            this.org_kevoree_ContainerRoot = 'org.kevoree.ContainerRoot';
            this.Att_fragmentDependant = 'fragmentDependant';
            this.Att_state = 'state';
            this.org_kevoree_ServicePortType = 'org.kevoree.ServicePortType';
            this.Att_interface = 'interface';
            this.org_kevoree_PortType = 'org.kevoree.PortType';
            this.Ref_hosts = 'hosts';
            this.org_kevoree_MBinding = 'org.kevoree.MBinding';
            this.Ref_operations = 'operations';
            this.org_kevoree_Value = 'org.kevoree.Value';
            this.java_lang_Integer = 'java.lang.Integer';
            this.Ref_groups = 'groups';
            this.org_kevoree_Group = 'org.kevoree.Group';
            this.Ref_metaData = 'metaData';
            this.Att_generated_KMF_ID = 'generated_KMF_ID';
            this.org_kevoree_NamedElement = 'org.kevoree.NamedElement';
            this.Ref_dictionary = 'dictionary';
            this.Ref_packages = 'packages';
            this.org_kevoree_ComponentType = 'org.kevoree.ComponentType';
            this.org_kevoree_DeployUnit = 'org.kevoree.DeployUnit';
            this.Ref_mBindings = 'mBindings';
            this.Ref_subNodes = 'subNodes';
            this.Ref_fragmentDictionary = 'fragmentDictionary';
            this.Ref_nodes = 'nodes';
            this.org_kevoree_DataType = 'org.kevoree.DataType';
            this.Ref_hubs = 'hubs';
            this.Ref_mappings = 'mappings';
            this.org_kevoree_ChannelType = 'org.kevoree.ChannelType';
            this.Ref_attributes = 'attributes';
            this.Att_hashcode = 'hashcode';
            this.Att_lowerFragments = 'lowerFragments';
            this.Ref_parameters = 'parameters';
            this.Ref_type = 'type';
            this.Att_datatype = 'datatype';
            this.Ref_networkInformation = 'networkInformation';
            this.Att_value = 'value';
            this.org_kevoree_Port = 'org.kevoree.Port';
            this.Att_abstract = 'abstract';
            this.org_kevoree_ComponentInstance = 'org.kevoree.ComponentInstance';
            this.Att_version = 'version';
            this.org_kevoree_ContainerNode = 'org.kevoree.ContainerNode';
            this.Ref_components = 'components';
            this.org_kevoree_DictionaryAttribute = 'org.kevoree.DictionaryAttribute';
            this.Ref_typeDefinitions = 'typeDefinitions';
            this.Ref_genericTypes = 'genericTypes';
            this.org_kevoree_FragmentDictionary = 'org.kevoree.FragmentDictionary';
            this.Ref_requiredLibs = 'requiredLibs';
            this.Ref_typeDefinition = 'typeDefinition';
            this.org_kevoree_Channel = 'org.kevoree.Channel';
            this.Ref_deployUnits = 'deployUnits';
            this.org_kevoree_Parameter = 'org.kevoree.Parameter';
            this.org_kevoree_Dictionary = 'org.kevoree.Dictionary';
            this.Att_synchrone = 'synchrone';
            this.org_kevoree_Repository = 'org.kevoree.Repository';
            this.Att_serviceMethodName = 'serviceMethodName';
            this.Ref_repositories = 'repositories';
            this.Ref_required = 'required';
            this.Att_name = 'name';
            this.Att_order = 'order';
            this.java_lang_String = 'java.lang.String';
            this.Att_upperFragments = 'upperFragments';
            this.Att_lowerBindings = 'lowerBindings';
            this.org_kevoree_NetworkInfo = 'org.kevoree.NetworkInfo';
            this.org_kevoree_GroupType = 'org.kevoree.GroupType';
            this.org_kevoree_Operation = 'org.kevoree.Operation';
            this.Ref_filters = 'filters';
            this.org_kevoree_PortTypeRef = 'org.kevoree.PortTypeRef';
            this.Att_optional = 'optional';
            this.org_kevoree_DictionaryType = 'org.kevoree.DictionaryType';
            this.Att_beanMethodName = 'beanMethodName';
            this.Ref_ref = 'ref';
            this.Ref_bindings = 'bindings';
            this.org_kevoree_MessagePortType = 'org.kevoree.MessagePortType';
            this.org_kevoree_TypeDefinition = 'org.kevoree.TypeDefinition';
            this.Att_paramTypes = 'paramTypes';
            this.Att_noDependency = 'noDependency';
          });
        }, /** @lends _.org.kevoree.util */ {
        }),
        factory: Kotlin.definePackage(null, /** @lends _.org.kevoree.factory */ {
          DefaultKevoreeFactory: Kotlin.createClass(function () {
            return [_.org.kevoree.factory.KevoreeFactory];
          }, null, /** @lends _.org.kevoree.factory.DefaultKevoreeFactory.prototype */ {
            getVersion: function () {
              return '5.0.1-SNAPSHOT';
            },
            lookup: function (path) {
              return null;
            },
            createComponentInstance: function () {
              var tempElem = new _.org.kevoree.impl.ComponentInstanceImpl();
              return tempElem;
            },
            createInstance: function () {
              var tempElem = new _.org.kevoree.impl.InstanceImpl();
              return tempElem;
            },
            createPort: function () {
              var tempElem = new _.org.kevoree.impl.PortImpl();
              return tempElem;
            },
            createComponentType: function () {
              var tempElem = new _.org.kevoree.impl.ComponentTypeImpl();
              return tempElem;
            },
            createTypeDefinition: function () {
              var tempElem = new _.org.kevoree.impl.TypeDefinitionImpl();
              return tempElem;
            },
            createPortTypeRef: function () {
              var tempElem = new _.org.kevoree.impl.PortTypeRefImpl();
              return tempElem;
            },
            createContainerNode: function () {
              var tempElem = new _.org.kevoree.impl.ContainerNodeImpl();
              return tempElem;
            },
            createGroup: function () {
              var tempElem = new _.org.kevoree.impl.GroupImpl();
              return tempElem;
            },
            createNetworkInfo: function () {
              var tempElem = new _.org.kevoree.impl.NetworkInfoImpl();
              return tempElem;
            },
            createContainerRoot: function () {
              var tempElem = new _.org.kevoree.impl.ContainerRootImpl();
              return tempElem;
            },
            createRepository: function () {
              var tempElem = new _.org.kevoree.impl.RepositoryImpl();
              return tempElem;
            },
            createChannel: function () {
              var tempElem = new _.org.kevoree.impl.ChannelImpl();
              return tempElem;
            },
            createMBinding: function () {
              var tempElem = new _.org.kevoree.impl.MBindingImpl();
              return tempElem;
            },
            createPackage: function () {
              var tempElem = new _.org.kevoree.impl.PackageImpl();
              return tempElem;
            },
            createNamedElement: function () {
              var tempElem = new _.org.kevoree.impl.NamedElementImpl();
              return tempElem;
            },
            createDeployUnit: function () {
              var tempElem = new _.org.kevoree.impl.DeployUnitImpl();
              return tempElem;
            },
            createPortType: function () {
              var tempElem = new _.org.kevoree.impl.PortTypeImpl();
              return tempElem;
            },
            createDictionary: function () {
              var tempElem = new _.org.kevoree.impl.DictionaryImpl();
              return tempElem;
            },
            createValue: function () {
              var tempElem = new _.org.kevoree.impl.ValueImpl();
              return tempElem;
            },
            createFragmentDictionary: function () {
              var tempElem = new _.org.kevoree.impl.FragmentDictionaryImpl();
              return tempElem;
            },
            createDictionaryType: function () {
              var tempElem = new _.org.kevoree.impl.DictionaryTypeImpl();
              return tempElem;
            },
            createDictionaryAttribute: function () {
              var tempElem = new _.org.kevoree.impl.DictionaryAttributeImpl();
              return tempElem;
            },
            createTypedElement: function () {
              var tempElem = new _.org.kevoree.impl.TypedElementImpl();
              return tempElem;
            },
            createPortTypeMapping: function () {
              var tempElem = new _.org.kevoree.impl.PortTypeMappingImpl();
              return tempElem;
            },
            createServicePortType: function () {
              var tempElem = new _.org.kevoree.impl.ServicePortTypeImpl();
              return tempElem;
            },
            createOperation: function () {
              var tempElem = new _.org.kevoree.impl.OperationImpl();
              return tempElem;
            },
            createParameter: function () {
              var tempElem = new _.org.kevoree.impl.ParameterImpl();
              return tempElem;
            },
            createMessagePortType: function () {
              var tempElem = new _.org.kevoree.impl.MessagePortTypeImpl();
              return tempElem;
            },
            createChannelType: function () {
              var tempElem = new _.org.kevoree.impl.ChannelTypeImpl();
              return tempElem;
            },
            createGroupType: function () {
              var tempElem = new _.org.kevoree.impl.GroupTypeImpl();
              return tempElem;
            },
            createNodeType: function () {
              var tempElem = new _.org.kevoree.impl.NodeTypeImpl();
              return tempElem;
            },
            create: function (metaClassName) {
              {
                if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentInstance) {
                  return this.createComponentInstance();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Instance) {
                  return this.createInstance();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Port) {
                  return this.createPort();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ComponentType) {
                  return this.createComponentType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypeDefinition) {
                  return this.createTypeDefinition();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeRef) {
                  return this.createPortTypeRef();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerNode) {
                  return this.createContainerNode();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Group) {
                  return this.createGroup();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NetworkInfo) {
                  return this.createNetworkInfo();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ContainerRoot) {
                  return this.createContainerRoot();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Repository) {
                  return this.createRepository();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Channel) {
                  return this.createChannel();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MBinding) {
                  return this.createMBinding();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Package) {
                  return this.createPackage();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NamedElement) {
                  return this.createNamedElement();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DeployUnit) {
                  return this.createDeployUnit();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortType) {
                  return this.createPortType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Dictionary) {
                  return this.createDictionary();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Value) {
                  return this.createValue();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_FragmentDictionary) {
                  return this.createFragmentDictionary();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryType) {
                  return this.createDictionaryType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_DictionaryAttribute) {
                  return this.createDictionaryAttribute();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_TypedElement) {
                  return this.createTypedElement();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_PortTypeMapping) {
                  return this.createPortTypeMapping();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ServicePortType) {
                  return this.createServicePortType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Operation) {
                  return this.createOperation();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_Parameter) {
                  return this.createParameter();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_MessagePortType) {
                  return this.createMessagePortType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_ChannelType) {
                  return this.createChannelType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_GroupType) {
                  return this.createGroupType();
                }
                 else if (metaClassName === _.org.kevoree.util.Constants.org_kevoree_NodeType) {
                  return this.createNodeType();
                }
                 else {
                  return null;
                }
              }
            },
            select: function (query) {
              return new Kotlin.ArrayList();
            },
            root: function (elem) {
              elem.is_root = true;
              elem.path_cache = '/';
            },
            createJSONSerializer: function () {
              return new _.org.kevoree.modeling.api.json.JSONModelSerializer();
            },
            createJSONLoader: function () {
              return new _.org.kevoree.modeling.api.json.JSONModelLoader(this);
            },
            createXMISerializer: function () {
              return new _.org.kevoree.modeling.api.xmi.XMIModelSerializer();
            },
            createXMILoader: function () {
              return new _.org.kevoree.modeling.api.xmi.XMIModelLoader(this);
            },
            createModelCompare: function () {
              return new _.org.kevoree.modeling.api.compare.ModelCompare(this);
            },
            createModelCloner: function () {
              return new _.org.kevoree.modeling.api.ModelCloner(this);
            },
            createModelPruner: function () {
              return new _.org.kevoree.modeling.api.ModelPruner(this);
            }
          }),
          KevoreeFactory: Kotlin.createTrait(function () {
            return [_.org.kevoree.modeling.api.KMFFactory];
          })
        }),
        modeling: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling */ {
          api: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api */ {
            time: Kotlin.definePackage(function () {
              this.TimeComparator = Kotlin.createObject(null, null, {
                compare: function (a, b) {
                  if (a === b) {
                    return 0;
                  }
                   else {
                    if (a < b) {
                      return -1;
                    }
                     else {
                      return 1;
                    }
                  }
                }
              });
              this.TimeSegmentConst = Kotlin.createObject(null, function () {
                this.GLOBAL_TIMEMETA = '#global';
              });
            }, /** @lends _.org.kevoree.modeling.api.time */ {
              TimeAwareKMFContainer: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.TimedContainer, _.org.kevoree.modeling.api.persistence.KMFContainerProxy];
              }, /** @lends _.org.kevoree.modeling.api.time.TimeAwareKMFContainer.prototype */ {
                meta: {
                  get: function () {
                    return this.$meta_e0ta8m$;
                  },
                  set: function (tmp$0) {
                    this.$meta_e0ta8m$ = tmp$0;
                  }
                },
                getOriginTransaction: function () {
                  var tmp$0;
                  return ((tmp$0 = this.originFactory) != null ? tmp$0 : Kotlin.throwNPE()).originTransaction;
                },
                previous: function () {
                  var previousTime = this.timeTree().previous(this.now);
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                next: function () {
                  var previousTime = this.timeTree().next(this.now);
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                last: function () {
                  var tmp$0;
                  var previousTime = (tmp$0 = this.timeTree().versionTree.lastWhileNot(this.now, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) != null ? tmp$0.key : null;
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                first: function () {
                  var tmp$0;
                  var previousTime = (tmp$0 = this.timeTree().versionTree.firstWhileNot(this.now, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) != null ? tmp$0.key : null;
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                jump: function (time) {
                  var previousTime = this.timeTree().previous(time);
                  if (previousTime != null) {
                    return this.getOriginTransaction().time(previousTime).lookup(this.path());
                  }
                  return null;
                },
                timeTree: function () {
                  var tmp$0;
                  return ((tmp$0 = this.originFactory) != null ? tmp$0 : Kotlin.throwNPE()).getTimeTree(this.path());
                }
              }),
              TimeAwareKMFFactory: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.time.TimeView, _.org.kevoree.modeling.api.persistence.PersistenceKMFFactory];
              }, /** @lends _.org.kevoree.modeling.api.time.TimeAwareKMFFactory.prototype */ {
                relativeTime: {
                  get: function () {
                    return this.$relativeTime_53j5cx$;
                  }
                },
                sharedCache: {
                  get: function () {
                    return this.$sharedCache_s3os97$;
                  }
                },
                entitiesCache: {
                  get: function () {
                    return this.$entitiesCache_hk1jbt$;
                  },
                  set: function (tmp$0) {
                    this.$entitiesCache_hk1jbt$ = tmp$0;
                  }
                },
                originTransaction: {
                  get: function () {
                    return this.$originTransaction_8vjs1c$;
                  },
                  set: function (tmp$0) {
                    this.$originTransaction_8vjs1c$ = tmp$0;
                  }
                },
                getEntitiesMeta: function () {
                  if (this.entitiesCache != null) {
                    var tmp$0;
                    return (tmp$0 = this.entitiesCache) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                   else {
                    var payload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITIES.name(), this.relativeTime.toString());
                    var blob = new _.org.kevoree.modeling.api.time.blob.EntitiesMeta();
                    if (payload != null) {
                      blob.load(payload);
                    }
                    this.entitiesCache = blob;
                    return blob;
                  }
                },
                endCommit: function () {
                  var entitiesMeta = this.getEntitiesMeta();
                  {
                    var tmp$0 = entitiesMeta.list.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var path = tmp$0.next();
                      var timeTree = this.getTimeTree(path);
                      if (timeTree.dirty) {
                        this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.TIMEMETA.name(), path, timeTree.toString());
                        timeTree.dirty = false;
                      }
                    }
                  }
                  if (entitiesMeta.isDirty) {
                    this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITIES.name(), this.relativeTime.toString(), entitiesMeta.toString());
                    entitiesMeta.isDirty = false;
                  }
                  var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                  if (globalTime.dirty) {
                    this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.TIMEMETA.name(), _.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA, globalTime.toString());
                    globalTime.dirty = false;
                  }
                  {
                    var tmp$1 = this.elementsToBeRemoved.iterator();
                    while (tmp$1.hasNext()) {
                      var e = tmp$1.next();
                      this.cleanUnusedPaths(e);
                    }
                  }
                  this.elementsToBeRemoved.clear();
                  this.datastore.commit();
                },
                clear: function () {
                  var tmp$0;
                  if (this.entitiesCache != null && ((tmp$0 = this.entitiesCache) != null ? tmp$0 : Kotlin.throwNPE()).isDirty) {
                    Kotlin.println('WARNING :: CLOSED TimeView in dirty mode ! ' + this.relativeTime);
                  }
                  _.org.kevoree.modeling.api.persistence.PersistenceKMFFactory.prototype.clear.call(this);
                  this.entitiesCache = null;
                },
                monitor: function (elem) {
                  if (!this.dirty) {
                    this.dirty = true;
                    var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                    if (globalTime.versionTree.lookup(this.relativeTime) == null) {
                      globalTime.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                      globalTime.dirty = true;
                    }
                  }
                  elem.addModelElementListener(this);
                },
                commit: function () {
                  var keys = _.kotlin.toList_h3panj$(this.modified_elements.keySet());
                  {
                    var tmp$0 = keys.iterator();
                    while (tmp$0.hasNext()) {
                      var elem = tmp$0.next();
                      var resolved = this.modified_elements.get_za3rmp$(elem);
                      if (resolved != null) {
                        if (Kotlin.equals(resolved.path(), '')) {
                          if (!resolved.isDeleted()) {
                            resolved.delete();
                          }
                           else {
                            this.modified_elements.remove_za3rmp$(elem);
                          }
                        }
                      }
                    }
                  }
                  {
                    var tmp$1 = this.modified_elements.values().iterator();
                    while (tmp$1.hasNext()) {
                      var elem_0 = tmp$1.next();
                      this.persist(elem_0);
                      this.elementsToBeRemoved.remove_za3rmp$(elem_0.path());
                    }
                  }
                },
                persist: function (elem) {
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy) && !elem.isDirty) {
                    return;
                  }
                  var currentPath = elem.path();
                  if (Kotlin.equals(currentPath, '')) {
                    throw new Error('Internal error, empty path found during persist method ' + elem);
                  }
                  if (!currentPath.startsWith('/')) {
                    throw new Error('Cannot persist, because the path of the element do not refer to a root: ' + currentPath + ' -> ' + elem);
                  }
                  var casted = elem;
                  var traces = elem.toTraces(true, true);
                  var traceSeq = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  traceSeq.populate(traces);
                  var entitiesMeta = this.getEntitiesMeta();
                  entitiesMeta.list.put_wn2jw4$(currentPath, true);
                  entitiesMeta.isDirty = true;
                  var key = this.relativeTime.toString() + '/' + currentPath;
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key, traceSeq.exportToString());
                  var castedInBounds = elem;
                  var saved = _.org.kevoree.modeling.api.time.blob.MetaHelper.serialize(castedInBounds.internal_inboundReferences);
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key + '#', saved);
                  var tmp$0;
                  ((tmp$0 = casted.meta) != null ? tmp$0 : Kotlin.throwNPE()).latestPersisted = this.relativeTime;
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITYMETA.name(), key, Kotlin.toString(casted.meta));
                  var timeTree = this.getTimeTree(currentPath);
                  if (timeTree.versionTree.lookup(this.relativeTime) == null) {
                    timeTree.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                    timeTree.dirty = true;
                  }
                },
                remove: function (elem) {
                  if (elem.isDeleted()) {
                    return;
                  }
                  var path = elem.path();
                  if (Kotlin.equals(path, '')) {
                    this.modified_elements.remove_za3rmp$(elem);
                    Kotlin.println("WARNING :: Can't process dangling element! type:" + elem.metaClassName() + ',id=' + elem.internalGetKey() + ' ignored');
                    return;
                  }
                  this.elem_cache.remove_za3rmp$(path);
                  var currentCachedTimeTree = this.getTimeTree(path);
                  currentCachedTimeTree.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED);
                  currentCachedTimeTree.dirty = true;
                  var entitiesMeta = this.getEntitiesMeta();
                  entitiesMeta.list.put_wn2jw4$(path, true);
                  entitiesMeta.isDirty = true;
                  if (!this.dirty) {
                    var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                    if (globalTime.versionTree.lookup(this.relativeTime) == null) {
                      globalTime.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                      globalTime.dirty = true;
                    }
                  }
                  this.modified_elements.remove_za3rmp$(Kotlin.hashCode(elem).toString());
                },
                cleanUnusedPaths: function (path) {
                  var key = this.relativeTime.toString() + '/' + path;
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITYMETA.name(), key);
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key);
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key + '#');
                },
                getTimeTree: function (path) {
                  var alreadyCached = this.sharedCache.timeCache.get_za3rmp$(path);
                  if (alreadyCached != null) {
                    return alreadyCached;
                  }
                   else {
                    var timeMetaPayLoad = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.TIMEMETA.name(), path);
                    var blob = new _.org.kevoree.modeling.api.time.blob.TimeMeta();
                    if (timeMetaPayLoad != null) {
                      blob.load(timeMetaPayLoad);
                    }
                    this.sharedCache.timeCache.put_wn2jw4$(path, blob);
                    return blob;
                  }
                },
                lookup: function (path) {
                  var timeTree = this.getTimeTree(path);
                  var askedTimeResult = timeTree.versionTree.previousOrEqual(this.relativeTime);
                  var askedTime = askedTimeResult != null ? askedTimeResult.key : null;
                  if (askedTime == null || Kotlin.equals((askedTimeResult != null ? askedTimeResult : Kotlin.throwNPE()).value, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) {
                    return null;
                  }
                  var composedKey = Kotlin.toString(askedTime) + '/' + path;
                  if (this.elem_cache.containsKey_za3rmp$(composedKey)) {
                    return this.elem_cache.get_za3rmp$(composedKey);
                  }
                  var metaPayload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.ENTITYMETA.name(), composedKey);
                  if (metaPayload == null) {
                    return null;
                  }
                  var meta = new _.org.kevoree.modeling.api.time.blob.EntityMeta();
                  meta.load(metaPayload);
                  if (meta.metatype != null) {
                    var tmp$0, tmp$1;
                    var elem = (tmp$1 = this.create((tmp$0 = meta.metatype) != null ? tmp$0 : Kotlin.throwNPE())) != null ? tmp$1 : Kotlin.throwNPE();
                    elem.meta = meta;
                    this.elem_cache.put_wn2jw4$(composedKey, elem);
                    elem.isResolved = false;
                    elem.now = askedTime;
                    elem.setOriginPath(path);
                    this.monitor(elem);
                    return elem;
                  }
                   else {
                    throw new Error('Empty Type Name for ' + path);
                  }
                },
                getTraces: function (origin) {
                  var currentPath = origin.path();
                  var sequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  var castedOrigin = origin;
                  var tmp$0, tmp$1;
                  if (((tmp$0 = castedOrigin.meta) != null ? tmp$0 : Kotlin.throwNPE()).latestPersisted == null) {
                    return null;
                  }
                  var traces = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), Kotlin.toString(((tmp$1 = castedOrigin.meta) != null ? tmp$1 : Kotlin.throwNPE()).latestPersisted) + '/' + currentPath);
                  if (traces != null) {
                    sequence.populateFromString(traces != null ? traces : Kotlin.throwNPE());
                    return sequence;
                  }
                  return null;
                },
                now: function () {
                  return this.relativeTime;
                },
                modified: function () {
                  return this.getEntitiesMeta().list.keySet();
                },
                loadInbounds: function (elem) {
                  var castedInBounds = elem;
                  var casted2 = elem;
                  var tmp$0;
                  var payload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), Kotlin.toString(((tmp$0 = casted2.meta) != null ? tmp$0 : Kotlin.throwNPE()).latestPersisted) + '/' + elem.path() + '#');
                  if (payload != null) {
                    castedInBounds.internal_inboundReferences = _.org.kevoree.modeling.api.time.blob.MetaHelper.unserialize(payload, this);
                  }
                },
                delete: function () {
                  {
                    var tmp$0 = this.getEntitiesMeta().list.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var path = tmp$0.next();
                      var timeMeta = this.getTimeTree(path);
                      timeMeta.versionTree.delete(this.relativeTime);
                      timeMeta.dirty = true;
                      this.elementsToBeRemoved.add_za3rmp$(path);
                    }
                  }
                  this.getEntitiesMeta().list.clear();
                  this.getEntitiesMeta().isDirty = true;
                  if (!this.dirty) {
                    var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                    if (globalTime.versionTree.lookup(this.relativeTime) == null) {
                      globalTime.versionTree.insert(this.relativeTime, _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS);
                      globalTime.dirty = true;
                    }
                  }
                  var entitiesMeta = this.getEntitiesMeta();
                  entitiesMeta.list.clear();
                  entitiesMeta.isDirty = true;
                },
                diff: function (other) {
                  var casted = other;
                  var sequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  var globalTime = this.getTimeTree(_.org.kevoree.modeling.api.time.TimeSegmentConst.GLOBAL_TIMEMETA);
                  var tmp$0, tmp$1;
                  var resolved1 = (tmp$0 = globalTime.versionTree.previousOrEqual(this.relativeTime)) != null ? tmp$0.key : null;
                  var resolved2 = (tmp$1 = globalTime.versionTree.previousOrEqual(casted.relativeTime)) != null ? tmp$1.key : null;
                  if (resolved1 == null || resolved2 == null) {
                    return sequence;
                  }
                   else {
                    if (_.org.kevoree.modeling.api.time.TimeComparator.compare(resolved1 != null ? resolved1 : Kotlin.throwNPE(), resolved2 != null ? resolved2 : Kotlin.throwNPE()) > 1) {
                      var temp = resolved1;
                      resolved1 = resolved2;
                      resolved2 = temp;
                    }
                  }
                  var currentTP = resolved1 != null ? resolved1 : Kotlin.throwNPE();
                  while (!Kotlin.equals(currentTP, resolved2 != null ? resolved2 : Kotlin.throwNPE())) {
                    var otherEntities = casted.getEntitiesMeta();
                    {
                      var tmp$2 = otherEntities.list.keySet().iterator();
                      while (tmp$2.hasNext()) {
                        var path = tmp$2.next();
                        var key = currentTP.toString() + '/' + path;
                        var raw = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), key);
                        if (raw != null) {
                          sequence.populateFromString(raw);
                        }
                      }
                    }
                    var tmp$3, tmp$4;
                    currentTP = (tmp$4 = (tmp$3 = globalTime.versionTree.next(currentTP)) != null ? tmp$3.key : null) != null ? tmp$4 : Kotlin.throwNPE();
                  }
                  return sequence;
                }
              }),
              TimeTree: Kotlin.createTrait(null),
              TimeView: Kotlin.createTrait(null),
              TimeSegment: Kotlin.createClass(function () {
                return [Kotlin.Enum];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.time.TimeSegment */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    RAW: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    ENTITYMETA: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    TIMEMETA: new _.org.kevoree.modeling.api.time.TimeSegment(),
                    ENTITIES: new _.org.kevoree.modeling.api.time.TimeSegment()
                  });
                }
              }),
              TimeWalker: Kotlin.createTrait(null),
              blob: Kotlin.definePackage(function () {
                this.RBCONST = Kotlin.createObject(null, function () {
                  this.BLACK_DELETE = '0';
                  this.BLACK_EXISTS = '1';
                  this.RED_DELETE = '2';
                  this.RED_EXISTS = '3';
                });
                this.MetaHelper = Kotlin.createObject(null, function () {
                  this.sep = '#';
                  this.sep2 = '%';
                }, {
                  serialize: function (p) {
                    var buffer = new Kotlin.StringBuilder();
                    var isFirst = true;
                    {
                      var tmp$0 = p.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var key = tmp$0.next();
                        var tmp$1;
                        var v = (tmp$1 = p.get_za3rmp$(key)) != null ? tmp$1 : Kotlin.throwNPE();
                        if (!isFirst) {
                          buffer.append(this.sep);
                        }
                        buffer.append(key.path());
                        if (v.size() !== 0) {
                          {
                            var tmp$2 = v.iterator();
                            while (tmp$2.hasNext()) {
                              var v2 = tmp$2.next();
                              buffer.append(this.sep2);
                              buffer.append(v2);
                            }
                          }
                        }
                        isFirst = false;
                      }
                    }
                    return buffer.toString();
                  },
                  unserialize: function (p, factory) {
                    var result = new Kotlin.ComplexHashMap();
                    var lines = Kotlin.splitString(p, this.sep);
                    var tmp$0, tmp$1, tmp$2;
                    {
                      tmp$0 = lines, tmp$1 = tmp$0.length;
                      for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
                        var l = tmp$0[tmp$2];
                        var elems = Kotlin.splitString(l, this.sep2);
                        if (elems.length > 1) {
                          var payload = new Kotlin.PrimitiveHashSet();
                          var tmp$3, tmp$4;
                          {
                            tmp$3 = elems.length - 1 + 1;
                            for (var i = 1; i !== tmp$3; i++) {
                              payload.add_za3rmp$(elems[i]);
                            }
                          }
                          result.put_wn2jw4$((tmp$4 = factory.lookup(elems[0])) != null ? tmp$4 : Kotlin.throwNPE(), payload);
                        }
                      }
                    }
                    return result;
                  }
                });
              }, /** @lends _.org.kevoree.modeling.api.time.blob */ {
                TimeMeta: Kotlin.createClass(function () {
                  return [_.org.kevoree.modeling.api.time.TimeTree];
                }, function () {
                  this.dirty = true;
                  this.versionTree = new _.org.kevoree.modeling.api.time.blob.RBTree();
                }, /** @lends _.org.kevoree.modeling.api.time.blob.TimeMeta.prototype */ {
                  first: function () {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.first()) != null ? tmp$0.key : null;
                  },
                  last: function () {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.last()) != null ? tmp$0.key : null;
                  },
                  next: function (from) {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.next(from)) != null ? tmp$0.key : null;
                  },
                  previous: function (from) {
                    var tmp$0;
                    return (tmp$0 = this.versionTree.previous(from)) != null ? tmp$0.key : null;
                  },
                  walk: function (walker) {
                    return this.walkAsc(walker);
                  },
                  toString: function () {
                    return this.versionTree.serialize();
                  },
                  load: function (payload) {
                    this.versionTree.unserialize(payload);
                    this.dirty = false;
                  },
                  walkAsc: function (walker) {
                    var elem = this.versionTree.first();
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).next();
                    }
                  },
                  walkDesc: function (walker) {
                    var elem = this.versionTree.last();
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).previous();
                    }
                  },
                  walkRangeAsc: function (walker, from, to) {
                    var from2 = from;
                    var to2 = to;
                    if (from > to) {
                      from2 = to;
                      to2 = from;
                    }
                    var elem;
                    elem = this.versionTree.previousOrEqual(from2);
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).next();
                      if (elem != null) {
                        if ((elem != null ? elem : Kotlin.throwNPE()).key >= to2) {
                          return;
                        }
                      }
                    }
                  },
                  walkRangeDesc: function (walker, from, to) {
                    var from2 = from;
                    var to2 = to;
                    if (from > to) {
                      from2 = to;
                      to2 = from;
                    }
                    var elem;
                    elem = this.versionTree.previousOrEqual(to2);
                    while (elem != null) {
                      walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                      elem = (elem != null ? elem : Kotlin.throwNPE()).previous();
                      if (elem != null) {
                        if ((elem != null ? elem : Kotlin.throwNPE()).key <= from2) {
                          walker.walk((elem != null ? elem : Kotlin.throwNPE()).key);
                          return;
                        }
                      }
                    }
                  }
                }, /** @lends _.org.kevoree.modeling.api.time.blob.TimeMeta */ {
                  object_initializer$: function () {
                    return Kotlin.createObject(null, function () {
                      this.GO_DOWN_LEFT = 0;
                      this.GO_DOWN_RIGHT = 1;
                      this.PROCESS_PREFIX = 2;
                      this.PROCESS_INFIX = 3;
                      this.PROCESS_POSTFIX = 4;
                    });
                  }
                }),
                Color: Kotlin.createClass(function () {
                  return [Kotlin.Enum];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, null, /** @lends _.org.kevoree.modeling.api.time.blob.Color */ {
                  object_initializer$: function () {
                    return Kotlin.createEnumEntries({
                      RED: new _.org.kevoree.modeling.api.time.blob.Color(),
                      BLACK: new _.org.kevoree.modeling.api.time.blob.Color()
                    });
                  }
                }),
                STATE: Kotlin.createClass(function () {
                  return [Kotlin.Enum];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, null, /** @lends _.org.kevoree.modeling.api.time.blob.STATE */ {
                  object_initializer$: function () {
                    return Kotlin.createEnumEntries({
                      EXISTS: new _.org.kevoree.modeling.api.time.blob.STATE(),
                      DELETED: new _.org.kevoree.modeling.api.time.blob.STATE()
                    });
                  }
                }),
                Node: Kotlin.createClass(null, function (key, value, color, left, right) {
                  this.key = key;
                  this.value = value;
                  this.color = color;
                  this.left = left;
                  this.right = right;
                  this.parent = null;
                  if (this.left != null) {
                    var tmp$0;
                    ((tmp$0 = this.left) != null ? tmp$0 : Kotlin.throwNPE()).parent = this;
                  }
                  if (this.right != null) {
                    var tmp$1;
                    ((tmp$1 = this.right) != null ? tmp$1 : Kotlin.throwNPE()).parent = this;
                  }
                  this.parent = null;
                }, /** @lends _.org.kevoree.modeling.api.time.blob.Node.prototype */ {
                  grandparent: function () {
                    var tmp$0;
                    return (tmp$0 = this.parent) != null ? tmp$0.parent : null;
                  },
                  sibling: function () {
                    var tmp$0;
                    if (Kotlin.equals(this, (tmp$0 = this.parent) != null ? tmp$0.left : null)) {
                      var tmp$1;
                      return (tmp$1 = this.parent) != null ? tmp$1.right : null;
                    }
                     else {
                      var tmp$2;
                      return (tmp$2 = this.parent) != null ? tmp$2.left : null;
                    }
                  },
                  uncle: function () {
                    var tmp$0;
                    return (tmp$0 = this.parent) != null ? tmp$0.sibling() : null;
                  },
                  serialize: function (builder) {
                    builder.append('|');
                    if (Kotlin.equals(this.value, _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED)) {
                      if (Kotlin.equals(this.color, _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_DELETE);
                      }
                       else {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.RED_DELETE);
                      }
                    }
                     else {
                      if (Kotlin.equals(this.color, _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_EXISTS);
                      }
                       else {
                        builder.append(_.org.kevoree.modeling.api.time.blob.RBCONST.RED_EXISTS);
                      }
                    }
                    builder.append(this.key);
                    if (this.left == null && this.right == null) {
                      builder.append('%');
                    }
                     else {
                      if (this.left != null) {
                        var tmp$0;
                        (tmp$0 = this.left) != null ? tmp$0.serialize(builder) : null;
                      }
                       else {
                        builder.append('#');
                      }
                      if (this.right != null) {
                        var tmp$1;
                        (tmp$1 = this.right) != null ? tmp$1.serialize(builder) : null;
                      }
                       else {
                        builder.append('#');
                      }
                    }
                  },
                  next: function () {
                    var p = this;
                    if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                      var tmp$0;
                      p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$0 : Kotlin.throwNPE();
                      while ((p != null ? p : Kotlin.throwNPE()).left != null) {
                        var tmp$1;
                        p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$1 : Kotlin.throwNPE();
                      }
                      return p;
                    }
                     else {
                      if ((p != null ? p : Kotlin.throwNPE()).parent != null) {
                        var tmp$2;
                        if (Kotlin.equals(p, ((tmp$2 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$2 : Kotlin.throwNPE()).left)) {
                          var tmp$3;
                          return (tmp$3 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$3 : Kotlin.throwNPE();
                        }
                         else {
                          var tmp$4;
                          while ((p != null ? p : Kotlin.throwNPE()).parent != null && Kotlin.equals(p, ((tmp$4 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$4 : Kotlin.throwNPE()).right)) {
                            var tmp$5;
                            p = (tmp$5 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                          return (p != null ? p : Kotlin.throwNPE()).parent;
                        }
                      }
                       else {
                        return null;
                      }
                    }
                  },
                  previous: function () {
                    var p = this;
                    if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                      var tmp$0;
                      p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                      while ((p != null ? p : Kotlin.throwNPE()).right != null) {
                        var tmp$1;
                        p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$1 : Kotlin.throwNPE();
                      }
                      return p;
                    }
                     else {
                      if ((p != null ? p : Kotlin.throwNPE()).parent != null) {
                        var tmp$2;
                        if (Kotlin.equals(p, ((tmp$2 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$2 : Kotlin.throwNPE()).right)) {
                          var tmp$3;
                          return (tmp$3 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$3 : Kotlin.throwNPE();
                        }
                         else {
                          var tmp$4;
                          while ((p != null ? p : Kotlin.throwNPE()).parent != null && Kotlin.equals(p, ((tmp$4 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$4 : Kotlin.throwNPE()).left)) {
                            var tmp$5;
                            p = (tmp$5 = (p != null ? p : Kotlin.throwNPE()).parent) != null ? tmp$5 : Kotlin.throwNPE();
                          }
                          return (p != null ? p : Kotlin.throwNPE()).parent;
                        }
                      }
                       else {
                        return null;
                      }
                    }
                  }
                }),
                ReaderContext: Kotlin.createClass(null, function (payload, offset) {
                  this.payload = payload;
                  this.offset = offset;
                }, /** @lends _.org.kevoree.modeling.api.time.blob.ReaderContext.prototype */ {
                  unserialize: function (rightBranch) {
                    if (this.offset >= this.payload.length) {
                      return null;
                    }
                    var tokenBuild = new Kotlin.StringBuilder();
                    var ch = this.payload.charAt(this.offset);
                    if (ch === '%') {
                      if (rightBranch) {
                        this.offset = this.offset + 1;
                      }
                      return null;
                    }
                    if (ch === '#') {
                      this.offset = this.offset + 1;
                      return null;
                    }
                    if (ch !== '|') {
                      throw new Error('Error while loading BTree');
                    }
                    this.offset = this.offset + 1;
                    ch = this.payload.charAt(this.offset);
                    var color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    var state = _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS;
                    {
                      if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_DELETE) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED;
                      }
                       else if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.BLACK_EXISTS) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS;
                      }
                       else if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.RED_DELETE) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.DELETED;
                      }
                       else if (ch === _.org.kevoree.modeling.api.time.blob.RBCONST.RED_EXISTS) {
                        color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                        state = _.org.kevoree.modeling.api.time.blob.STATE.object.EXISTS;
                      }
                    }
                    this.offset = this.offset + 1;
                    ch = this.payload.charAt(this.offset);
                    while (this.offset + 1 < this.payload.length && ch !== '|' && ch !== '#' && ch !== '%') {
                      tokenBuild.append(ch);
                      this.offset = this.offset + 1;
                      ch = this.payload.charAt(this.offset);
                    }
                    if (ch !== '|' && ch !== '#' && ch !== '%') {
                      tokenBuild.append(ch);
                    }
                    var p = new _.org.kevoree.modeling.api.time.blob.Node(_.java.lang.Long.parseLong(tokenBuild.toString()), state, color, null, null);
                    var left = this.unserialize(false);
                    if (left != null) {
                      left.parent = p;
                    }
                    var right = this.unserialize(true);
                    if (right != null) {
                      right.parent = p;
                    }
                    p.left = left;
                    p.right = right;
                    return p;
                  }
                }),
                RBTree: Kotlin.createClass(null, function () {
                  this.root = null;
                  this.size_pjslhb$ = 0;
                }, /** @lends _.org.kevoree.modeling.api.time.blob.RBTree.prototype */ {
                  size: function () {
                    return this.size_pjslhb$;
                  },
                  serialize: function () {
                    var builder = new Kotlin.StringBuilder();
                    builder.append(this.size_pjslhb$);
                    var tmp$0;
                    (tmp$0 = this.root) != null ? tmp$0.serialize(builder) : null;
                    return builder.toString();
                  },
                  unserialize: function (payload) {
                    if (_.kotlin.get_size_0(payload) === 0) {
                      return;
                    }
                    var i = 0;
                    var buffer = new Kotlin.StringBuilder();
                    var ch = payload.charAt(i);
                    while (i < payload.length && ch !== '|') {
                      buffer.append(ch);
                      i = i + 1;
                      ch = payload.charAt(i);
                    }
                    this.size_pjslhb$ = _.java.lang.Integer.parseInt(buffer.toString());
                    this.root = (new _.org.kevoree.modeling.api.time.blob.ReaderContext(payload, i)).unserialize(true);
                  },
                  previousOrEqual: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key === (p != null ? p : Kotlin.throwNPE()).key) {
                        return p;
                      }
                      if (key > (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).right;
                        }
                         else {
                          return p;
                        }
                      }
                       else {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).left;
                        }
                         else {
                          var parent = (p != null ? p : Kotlin.throwNPE()).parent;
                          var ch = p;
                          while (parent != null && Kotlin.equals(ch, (parent != null ? parent : Kotlin.throwNPE()).left)) {
                            ch = parent;
                            parent = (parent != null ? parent : Kotlin.throwNPE()).parent;
                          }
                          return parent;
                        }
                      }
                    }
                    return null;
                  },
                  nextOrEqual: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key === (p != null ? p : Kotlin.throwNPE()).key) {
                        return p;
                      }
                      if (key < (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).left;
                        }
                         else {
                          return p;
                        }
                      }
                       else {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          p = (p != null ? p : Kotlin.throwNPE()).right;
                        }
                         else {
                          var parent = (p != null ? p : Kotlin.throwNPE()).parent;
                          var ch = p;
                          while (parent != null && Kotlin.equals(ch, (parent != null ? parent : Kotlin.throwNPE()).right)) {
                            ch = parent;
                            parent = (parent != null ? parent : Kotlin.throwNPE()).parent;
                          }
                          return parent;
                        }
                      }
                    }
                    return null;
                  },
                  previous: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key < (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          var tmp$0;
                          p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                        }
                         else {
                          return (p != null ? p : Kotlin.throwNPE()).previous();
                        }
                      }
                       else if (key > (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          var tmp$1;
                          p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                         else {
                          return p;
                        }
                      }
                       else {
                        return (p != null ? p : Kotlin.throwNPE()).previous();
                      }
                    }
                    return null;
                  },
                  previousWhileNot: function (key, until) {
                    var elm = this.previousOrEqual(key);
                    if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      if ((elm != null ? elm : Kotlin.throwNPE()).key === key) {
                        elm = (elm != null ? elm : Kotlin.throwNPE()).previous();
                      }
                    }
                    if (elm == null || Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      return elm;
                    }
                  },
                  next: function (key) {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if (key < (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                          var tmp$0;
                          p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                        }
                         else {
                          return p;
                        }
                      }
                       else if (key > (p != null ? p : Kotlin.throwNPE()).key) {
                        if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                          var tmp$1;
                          p = (tmp$1 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                         else {
                          return (p != null ? p : Kotlin.throwNPE()).next();
                        }
                      }
                       else {
                        return (p != null ? p : Kotlin.throwNPE()).next();
                      }
                    }
                    return null;
                  },
                  nextWhileNot: function (key, until) {
                    var elm = this.nextOrEqual(key);
                    if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      if ((elm != null ? elm : Kotlin.throwNPE()).key === key) {
                        elm = (elm != null ? elm : Kotlin.throwNPE()).next();
                      }
                    }
                    if (elm == null || Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                     else {
                      return elm;
                    }
                  },
                  first: function () {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if ((p != null ? p : Kotlin.throwNPE()).left != null) {
                        var tmp$0;
                        p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                      }
                       else {
                        return p;
                      }
                    }
                    return null;
                  },
                  last: function () {
                    var p = this.root;
                    if (p == null) {
                      return null;
                    }
                    while (p != null) {
                      if ((p != null ? p : Kotlin.throwNPE()).right != null) {
                        var tmp$0;
                        p = (tmp$0 = (p != null ? p : Kotlin.throwNPE()).right) != null ? tmp$0 : Kotlin.throwNPE();
                      }
                       else {
                        return p;
                      }
                    }
                    return null;
                  },
                  firstWhileNot: function (key, until) {
                    var elm = this.previousOrEqual(key);
                    if (elm == null) {
                      return null;
                    }
                     else if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                    var prev;
                    do {
                      prev = (elm != null ? elm : Kotlin.throwNPE()).previous();
                      if (prev == null || Kotlin.equals((prev != null ? prev : Kotlin.throwNPE()).value, until)) {
                        return elm;
                      }
                       else {
                        elm = prev;
                      }
                    }
                     while (elm != null);
                    return prev;
                  },
                  lastWhileNot: function (key, until) {
                    var elm = this.previousOrEqual(key);
                    if (elm == null) {
                      return null;
                    }
                     else if (Kotlin.equals((elm != null ? elm : Kotlin.throwNPE()).value, until)) {
                      return null;
                    }
                    var next;
                    do {
                      next = (elm != null ? elm : Kotlin.throwNPE()).next();
                      if (next == null || Kotlin.equals((next != null ? next : Kotlin.throwNPE()).value, until)) {
                        return elm;
                      }
                       else {
                        elm = next;
                      }
                    }
                     while (elm != null);
                    return next;
                  },
                  lookupNode: function (key) {
                    var n = this.root;
                    if (n == null) {
                      return null;
                    }
                    while (n != null) {
                      if (key === (n != null ? n : Kotlin.throwNPE()).key) {
                        return n;
                      }
                       else {
                        if (key < (n != null ? n : Kotlin.throwNPE()).key) {
                          n = (n != null ? n : Kotlin.throwNPE()).left;
                        }
                         else {
                          n = (n != null ? n : Kotlin.throwNPE()).right;
                        }
                      }
                    }
                    return n;
                  },
                  lookup: function (key) {
                    var n = this.lookupNode(key);
                    if (n == null) {
                      return null;
                    }
                     else {
                      return n.value;
                    }
                  },
                  rotateLeft: function (n) {
                    var r = n.right;
                    this.replaceNode(n, r != null ? r : Kotlin.throwNPE());
                    n.right = r.left;
                    if (r.left != null) {
                      var tmp$0;
                      ((tmp$0 = r.left) != null ? tmp$0 : Kotlin.throwNPE()).parent = n;
                    }
                    r.left = n;
                    n.parent = r;
                  },
                  rotateRight: function (n) {
                    var l = n.left;
                    this.replaceNode(n, l != null ? l : Kotlin.throwNPE());
                    n.left = l.right;
                    if (l.right != null) {
                      var tmp$0;
                      ((tmp$0 = l.right) != null ? tmp$0 : Kotlin.throwNPE()).parent = n;
                    }
                    l.right = n;
                    n.parent = l;
                  },
                  replaceNode: function (oldn, newn) {
                    if (oldn.parent == null) {
                      this.root = newn;
                    }
                     else {
                      var tmp$0;
                      if (Kotlin.equals(oldn, ((tmp$0 = oldn.parent) != null ? tmp$0 : Kotlin.throwNPE()).left)) {
                        var tmp$1;
                        ((tmp$1 = oldn.parent) != null ? tmp$1 : Kotlin.throwNPE()).left = newn;
                      }
                       else {
                        var tmp$2;
                        ((tmp$2 = oldn.parent) != null ? tmp$2 : Kotlin.throwNPE()).right = newn;
                      }
                    }
                    if (newn != null) {
                      newn.parent = oldn.parent;
                    }
                  },
                  insert: function (key, value) {
                    var insertedNode = new _.org.kevoree.modeling.api.time.blob.Node(key, value, _.org.kevoree.modeling.api.time.blob.Color.object.RED, null, null);
                    if (this.root == null) {
                      this.size_pjslhb$++;
                      this.root = insertedNode;
                    }
                     else {
                      var n = this.root;
                      while (true) {
                        if (key === (n != null ? n : Kotlin.throwNPE()).key) {
                          (n != null ? n : Kotlin.throwNPE()).value = value;
                          return;
                        }
                         else if (key < (n != null ? n : Kotlin.throwNPE()).key) {
                          if ((n != null ? n : Kotlin.throwNPE()).left == null) {
                            (n != null ? n : Kotlin.throwNPE()).left = insertedNode;
                            this.size_pjslhb$++;
                            break;
                          }
                           else {
                            var tmp$0;
                            n = (tmp$0 = (n != null ? n : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                          }
                        }
                         else {
                          if ((n != null ? n : Kotlin.throwNPE()).right == null) {
                            (n != null ? n : Kotlin.throwNPE()).right = insertedNode;
                            this.size_pjslhb$++;
                            break;
                          }
                           else {
                            n = (n != null ? n : Kotlin.throwNPE()).right;
                          }
                        }
                      }
                      insertedNode.parent = n;
                    }
                    this.insertCase1(insertedNode);
                  },
                  insertCase1: function (n) {
                    if (n.parent == null) {
                      n.color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    }
                     else {
                      this.insertCase2(n);
                    }
                  },
                  insertCase2: function (n) {
                    if (Kotlin.equals(this.nodeColor(n.parent), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      return;
                    }
                     else {
                      this.insertCase3(n);
                    }
                  },
                  insertCase3: function (n) {
                    if (Kotlin.equals(this.nodeColor(n.uncle()), _.org.kevoree.modeling.api.time.blob.Color.object.RED)) {
                      var tmp$0, tmp$1, tmp$2, tmp$3;
                      ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      ((tmp$1 = n.uncle()) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      ((tmp$2 = n.grandparent()) != null ? tmp$2 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      this.insertCase1((tmp$3 = n.grandparent()) != null ? tmp$3 : Kotlin.throwNPE());
                    }
                     else {
                      this.insertCase4(n);
                    }
                  },
                  insertCase4: function (n_n) {
                    var n = n_n;
                    var tmp$0, tmp$1;
                    if (Kotlin.equals(n, ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).right) && Kotlin.equals(n.parent, ((tmp$1 = n.grandparent()) != null ? tmp$1 : Kotlin.throwNPE()).left)) {
                      var tmp$2, tmp$3;
                      this.rotateLeft((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE());
                      n = (tmp$3 = n.left) != null ? tmp$3 : Kotlin.throwNPE();
                    }
                     else {
                      var tmp$4, tmp$5;
                      if (Kotlin.equals(n, ((tmp$4 = n.parent) != null ? tmp$4 : Kotlin.throwNPE()).left) && Kotlin.equals(n.parent, ((tmp$5 = n.grandparent()) != null ? tmp$5 : Kotlin.throwNPE()).right)) {
                        var tmp$6, tmp$7;
                        this.rotateRight((tmp$6 = n.parent) != null ? tmp$6 : Kotlin.throwNPE());
                        n = (tmp$7 = n.right) != null ? tmp$7 : Kotlin.throwNPE();
                      }
                    }
                    this.insertCase5(n);
                  },
                  insertCase5: function (n) {
                    var tmp$0, tmp$1, tmp$2, tmp$3;
                    ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    ((tmp$1 = n.grandparent()) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                    if (Kotlin.equals(n, ((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE()).left) && Kotlin.equals(n.parent, ((tmp$3 = n.grandparent()) != null ? tmp$3 : Kotlin.throwNPE()).left)) {
                      var tmp$4;
                      this.rotateRight((tmp$4 = n.grandparent()) != null ? tmp$4 : Kotlin.throwNPE());
                    }
                     else {
                      var tmp$5;
                      this.rotateLeft((tmp$5 = n.grandparent()) != null ? tmp$5 : Kotlin.throwNPE());
                    }
                  },
                  delete: function (key) {
                    var n = this.lookupNode(key);
                    if (n == null) {
                      return;
                    }
                     else {
                      this.size_pjslhb$--;
                      if ((n != null ? n : Kotlin.throwNPE()).left != null && (n != null ? n : Kotlin.throwNPE()).right != null) {
                        var tmp$0;
                        var pred = (tmp$0 = (n != null ? n : Kotlin.throwNPE()).left) != null ? tmp$0 : Kotlin.throwNPE();
                        while (pred.right != null) {
                          var tmp$1;
                          pred = (tmp$1 = pred.right) != null ? tmp$1 : Kotlin.throwNPE();
                        }
                        (n != null ? n : Kotlin.throwNPE()).key = pred.key;
                        (n != null ? n : Kotlin.throwNPE()).value = pred.value;
                        n = pred;
                      }
                      var tmp$2;
                      if ((n != null ? n : Kotlin.throwNPE()).right == null) {
                        tmp$2 = (n != null ? n : Kotlin.throwNPE()).left;
                      }
                       else {
                        tmp$2 = (n != null ? n : Kotlin.throwNPE()).right;
                      }
                      var child = tmp$2;
                      if (Kotlin.equals(this.nodeColor(n), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                        (n != null ? n : Kotlin.throwNPE()).color = this.nodeColor(child);
                        this.deleteCase1(n != null ? n : Kotlin.throwNPE());
                      }
                      this.replaceNode(n != null ? n : Kotlin.throwNPE(), child);
                    }
                  },
                  deleteCase1: function (n) {
                    if (n.parent == null) {
                      return;
                    }
                     else {
                      this.deleteCase2(n);
                    }
                  },
                  deleteCase2: function (n) {
                    if (Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.RED)) {
                      var tmp$0, tmp$1, tmp$2;
                      ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      if (Kotlin.equals(n, ((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE()).left)) {
                        var tmp$3;
                        this.rotateLeft((tmp$3 = n.parent) != null ? tmp$3 : Kotlin.throwNPE());
                      }
                       else {
                        var tmp$4;
                        this.rotateRight((tmp$4 = n.parent) != null ? tmp$4 : Kotlin.throwNPE());
                      }
                    }
                    this.deleteCase3(n);
                  },
                  deleteCase3: function (n) {
                    var tmp$0, tmp$1;
                    if (Kotlin.equals(this.nodeColor(n.parent), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$0 = n.sibling()) != null ? tmp$0 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$2, tmp$3;
                      ((tmp$2 = n.sibling()) != null ? tmp$2 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      this.deleteCase1((tmp$3 = n.parent) != null ? tmp$3 : Kotlin.throwNPE());
                    }
                     else {
                      this.deleteCase4(n);
                    }
                  },
                  deleteCase4: function (n) {
                    var tmp$0, tmp$1;
                    if (Kotlin.equals(this.nodeColor(n.parent), _.org.kevoree.modeling.api.time.blob.Color.object.RED) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$0 = n.sibling()) != null ? tmp$0 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$2, tmp$3;
                      ((tmp$2 = n.sibling()) != null ? tmp$2 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$3 = n.parent) != null ? tmp$3 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    }
                     else {
                      this.deleteCase5(n);
                    }
                  },
                  deleteCase5: function (n) {
                    var tmp$0, tmp$1, tmp$2, tmp$7, tmp$8, tmp$9;
                    if (Kotlin.equals(n, ((tmp$0 = n.parent) != null ? tmp$0 : Kotlin.throwNPE()).left) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$1 = n.sibling()) != null ? tmp$1 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.RED) && Kotlin.equals(this.nodeColor(((tmp$2 = n.sibling()) != null ? tmp$2 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$3, tmp$4, tmp$5, tmp$6;
                      ((tmp$3 = n.sibling()) != null ? tmp$3 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$5 = ((tmp$4 = n.sibling()) != null ? tmp$4 : Kotlin.throwNPE()).left) != null ? tmp$5 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateRight((tmp$6 = n.sibling()) != null ? tmp$6 : Kotlin.throwNPE());
                    }
                     else if (Kotlin.equals(n, ((tmp$7 = n.parent) != null ? tmp$7 : Kotlin.throwNPE()).right) && Kotlin.equals(this.nodeColor(n.sibling()), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK) && Kotlin.equals(this.nodeColor(((tmp$8 = n.sibling()) != null ? tmp$8 : Kotlin.throwNPE()).right), _.org.kevoree.modeling.api.time.blob.Color.object.RED) && Kotlin.equals(this.nodeColor(((tmp$9 = n.sibling()) != null ? tmp$9 : Kotlin.throwNPE()).left), _.org.kevoree.modeling.api.time.blob.Color.object.BLACK)) {
                      var tmp$10, tmp$11, tmp$12, tmp$13;
                      ((tmp$10 = n.sibling()) != null ? tmp$10 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.RED;
                      ((tmp$12 = ((tmp$11 = n.sibling()) != null ? tmp$11 : Kotlin.throwNPE()).right) != null ? tmp$12 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateLeft((tmp$13 = n.sibling()) != null ? tmp$13 : Kotlin.throwNPE());
                    }
                    this.deleteCase6(n);
                  },
                  deleteCase6: function (n) {
                    var tmp$0, tmp$1, tmp$2;
                    ((tmp$0 = n.sibling()) != null ? tmp$0 : Kotlin.throwNPE()).color = this.nodeColor(n.parent);
                    ((tmp$1 = n.parent) != null ? tmp$1 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    if (Kotlin.equals(n, ((tmp$2 = n.parent) != null ? tmp$2 : Kotlin.throwNPE()).left)) {
                      var tmp$3, tmp$4, tmp$5;
                      ((tmp$4 = ((tmp$3 = n.sibling()) != null ? tmp$3 : Kotlin.throwNPE()).right) != null ? tmp$4 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateLeft((tmp$5 = n.parent) != null ? tmp$5 : Kotlin.throwNPE());
                    }
                     else {
                      var tmp$6, tmp$7, tmp$8;
                      ((tmp$7 = ((tmp$6 = n.sibling()) != null ? tmp$6 : Kotlin.throwNPE()).left) != null ? tmp$7 : Kotlin.throwNPE()).color = _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                      this.rotateRight((tmp$8 = n.parent) != null ? tmp$8 : Kotlin.throwNPE());
                    }
                  },
                  nodeColor: function (n) {
                    if (n == null) {
                      return _.org.kevoree.modeling.api.time.blob.Color.object.BLACK;
                    }
                     else {
                      return n.color;
                    }
                  }
                }),
                SharedCache: Kotlin.createClass(null, function () {
                  this.times_ynpjdh$ = new Kotlin.PrimitiveHashMap();
                  this.timeCache = new _.java.util.concurrent.ConcurrentHashMap();
                }, /** @lends _.org.kevoree.modeling.api.time.blob.SharedCache.prototype */ {
                  add: function (tp, tv) {
                    this.times_ynpjdh$.put_wn2jw4$(tp, tv);
                  },
                  get: function (tp) {
                    return this.times_ynpjdh$.get_za3rmp$(tp);
                  },
                  drop: function (tp) {
                    this.times_ynpjdh$.remove_za3rmp$(tp);
                  },
                  keys: function () {
                    return this.times_ynpjdh$.keySet();
                  },
                  flush: function () {
                    this.times_ynpjdh$.clear();
                    this.timeCache.clear();
                  }
                }),
                EntitiesMeta: Kotlin.createClass(null, function () {
                  this.isDirty = false;
                  this.sep = '#';
                  this.list = new Kotlin.PrimitiveHashMap();
                }, /** @lends _.org.kevoree.modeling.api.time.blob.EntitiesMeta.prototype */ {
                  toString: function () {
                    var stringBuilder = new Kotlin.StringBuilder();
                    var isFirst = true;
                    {
                      var tmp$0 = this.list.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var p = tmp$0.next();
                        if (!isFirst) {
                          stringBuilder.append(this.sep);
                        }
                        stringBuilder.append(p);
                        isFirst = false;
                      }
                    }
                    return stringBuilder.toString();
                  },
                  load: function (payload) {
                    if (Kotlin.equals(payload, '')) {
                      return;
                    }
                    var elements = Kotlin.splitString(payload, this.sep);
                    var tmp$0, tmp$1, tmp$2;
                    {
                      tmp$0 = elements, tmp$1 = tmp$0.length;
                      for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
                        var elem = tmp$0[tmp$2];
                        this.list.put_wn2jw4$(elem, true);
                      }
                    }
                    this.isDirty = false;
                  }
                }),
                EntityMeta: Kotlin.createClass(null, function () {
                  this.latestPersisted = null;
                  this.metatype = null;
                  this.sep = '/';
                }, /** @lends _.org.kevoree.modeling.api.time.blob.EntityMeta.prototype */ {
                  toString: function () {
                    var buidler = new Kotlin.StringBuilder();
                    buidler.append(this.latestPersisted);
                    buidler.append(this.sep);
                    buidler.append(this.metatype);
                    return buidler.toString();
                  },
                  load: function (payload) {
                    var elem = Kotlin.splitString(payload, this.sep);
                    if (elem.length === 2) {
                      var originPayload = elem[0];
                      if (!Kotlin.equals(originPayload, '')) {
                        this.latestPersisted = _.java.lang.Long.parseLong(originPayload);
                      }
                      this.metatype = elem[1];
                    }
                     else {
                      throw new Error('Bad EntityTimeMeta format');
                    }
                  }
                })
              })
            }),
            trace: Kotlin.definePackage(function () {
              this.ModelTraceConstants = Kotlin.createObject(null, function () {
                this.traceType = 't';
                this.src = 's';
                this.refname = 'r';
                this.previouspath = 'p';
                this.typename = 'n';
                this.objpath = 'o';
                this.content = 'c';
                this.openJSON = '{';
                this.closeJSON = '}';
                this.bb = '"';
                this.coma = ',';
                this.dp = ':';
              });
            }, /** @lends _.org.kevoree.modeling.api.trace */ {
              Event2Trace: Kotlin.createClass(null, function (compare) {
                this.compare = compare;
              }, /** @lends _.org.kevoree.modeling.api.trace.Event2Trace.prototype */ {
                convert: function (event) {
                  var result = new Kotlin.ArrayList();
                  {
                    var tmp$0 = event.etype;
                    if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      var tmp$1;
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$1 = event.previousPath) != null ? tmp$1 : Kotlin.throwNPE(), event.elementAttributeName, Kotlin.toString(event.previous_value)));
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      var tmp$2;
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace((tmp$2 = event.previousPath) != null ? tmp$2 : Kotlin.throwNPE(), event.elementAttributeName));
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      var tmp$3, tmp$4;
                      var casted = (tmp$3 = event.value) != null ? tmp$3 : Kotlin.throwNPE();
                      var traces = this.compare.inter(casted, casted);
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$4 = event.previousPath) != null ? tmp$4 : Kotlin.throwNPE(), event.elementAttributeName, casted.path(), casted.metaClassName()));
                      result.addAll_xeylzf$(traces.traces);
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      var tmp$5;
                      var casted_0 = (tmp$5 = event.value) != null ? tmp$5 : Kotlin.throwNPE();
                      {
                        var tmp$6 = casted_0.iterator();
                        while (tmp$6.hasNext()) {
                          var elem = tmp$6.next();
                          var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                          var traces_0 = this.compare.inter(elemCasted, elemCasted);
                          var tmp$7;
                          result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$7 = event.previousPath) != null ? tmp$7 : Kotlin.throwNPE(), event.elementAttributeName, elemCasted.path(), elemCasted.metaClassName()));
                          result.addAll_xeylzf$(traces_0.traces);
                        }
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      if (Kotlin.equals(event.elementAttributeType, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE)) {
                        var tmp$8;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$8 = event.previousPath) != null ? tmp$8 : Kotlin.throwNPE(), event.elementAttributeName, null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(event.value), null));
                      }
                       else {
                        var tmp$9, tmp$10;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$9 = event.previousPath) != null ? tmp$9 : Kotlin.throwNPE(), event.elementAttributeName, (tmp$10 = event.value) != null ? tmp$10.path() : null, null, null));
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error("Can't convert event : " + event);
                    }
                  }
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory)).populate(result);
                },
                inverse: function (event) {
                  var result = new Kotlin.ArrayList();
                  {
                    var tmp$0 = event.etype;
                    if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE) {
                      var tmp$1, tmp$2, tmp$3;
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$1 = event.previousPath) != null ? tmp$1 : Kotlin.throwNPE(), event.elementAttributeName, ((tmp$2 = event.value) != null ? tmp$2 : Kotlin.throwNPE()).path(), ((tmp$3 = event.value) != null ? tmp$3 : Kotlin.throwNPE()).metaClassName()));
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL) {
                      var tmp$4;
                      var casted = (tmp$4 = event.value) != null ? tmp$4 : Kotlin.throwNPE();
                      {
                        var tmp$5 = casted.iterator();
                        while (tmp$5.hasNext()) {
                          var elem = tmp$5.next();
                          var elemCasted = elem != null ? elem : Kotlin.throwNPE();
                          var traces = this.compare.inter(elemCasted, elemCasted);
                          var tmp$6;
                          result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace((tmp$6 = event.previousPath) != null ? tmp$6 : Kotlin.throwNPE(), event.elementAttributeName, elemCasted.path(), elemCasted.metaClassName()));
                          result.addAll_xeylzf$(traces.traces);
                        }
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD) {
                      var tmp$7, tmp$8;
                      var casted_0 = (tmp$7 = event.value) != null ? tmp$7 : Kotlin.throwNPE();
                      var traces_0 = this.compare.inter(casted_0, casted_0);
                      result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$8 = event.previousPath) != null ? tmp$8 : Kotlin.throwNPE(), event.elementAttributeName, casted_0.path()));
                      result.addAll_xeylzf$(traces_0.traces);
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL) {
                      var tmp$9;
                      var casted_1 = (tmp$9 = event.value) != null ? tmp$9 : Kotlin.throwNPE();
                      {
                        var tmp$10 = casted_1.iterator();
                        while (tmp$10.hasNext()) {
                          var elem_0 = tmp$10.next();
                          var elemCasted_0 = elem_0 != null ? elem_0 : Kotlin.throwNPE();
                          var traces_1 = this.compare.inter(elemCasted_0, elemCasted_0);
                          var tmp$11;
                          result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace((tmp$11 = event.previousPath) != null ? tmp$11 : Kotlin.throwNPE(), event.elementAttributeName, elemCasted_0.path()));
                          result.addAll_xeylzf$(traces_1.traces);
                        }
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.SET) {
                      if (Kotlin.equals(event.elementAttributeType, _.org.kevoree.modeling.api.util.ElementAttributeType.object.ATTRIBUTE)) {
                        var tmp$12;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$12 = event.previousPath) != null ? tmp$12 : Kotlin.throwNPE(), event.elementAttributeName, null, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(event.previous_value), null));
                      }
                       else {
                        var tmp$13, tmp$14;
                        result.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace((tmp$13 = event.previousPath) != null ? tmp$13 : Kotlin.throwNPE(), event.elementAttributeName, (tmp$14 = event.previous_value) != null ? tmp$14.path() : null, null, null));
                      }
                    }
                     else if (tmp$0 === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX) {
                    }
                     else {
                      throw new Error("Can't convert event : " + event);
                    }
                  }
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory)).populate(result);
                }
              }),
              DefaultTraceConverter: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.TraceConverter];
              }, function () {
                this.metaClassNameEquivalence_1_rqkn57$ = new Kotlin.PrimitiveHashMap();
                this.metaClassNameEquivalence_2_rqkn58$ = new Kotlin.PrimitiveHashMap();
                this.attNameEquivalence_1_vwmrr1$ = new Kotlin.PrimitiveHashMap();
                this.attNameEquivalence_2_vwmrr2$ = new Kotlin.PrimitiveHashMap();
              }, /** @lends _.org.kevoree.modeling.api.trace.DefaultTraceConverter.prototype */ {
                addMetaClassEquivalence: function (name1, name2) {
                  this.metaClassNameEquivalence_1_rqkn57$.put_wn2jw4$(name1, name2);
                  this.metaClassNameEquivalence_2_rqkn58$.put_wn2jw4$(name2, name2);
                },
                addAttEquivalence: function (name1, name2) {
                  var fqnArray_1 = Kotlin.splitString(name1, '#');
                  var fqnArray_2 = Kotlin.splitString(name1, '#');
                  this.attNameEquivalence_1_vwmrr1$.put_wn2jw4$(name1, name2);
                  this.attNameEquivalence_2_vwmrr2$.put_wn2jw4$(name2, name2);
                },
                convert: function (trace) {
                  {
                    if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                      var addTrace = trace;
                      var newTrace = new _.org.kevoree.modeling.api.trace.ModelAddTrace(addTrace.srcPath, addTrace.refName, addTrace.previousPath, this.tryConvertClassName(addTrace.typeName));
                      return newTrace;
                    }
                     else if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                      var setTrace = trace;
                      var newTrace_0 = new _.org.kevoree.modeling.api.trace.ModelSetTrace(setTrace.srcPath, setTrace.refName, setTrace.objPath, setTrace.content, this.tryConvertClassName(setTrace.typeName));
                      return newTrace_0;
                    }
                     else {
                      return trace;
                    }
                  }
                },
                tryConvertPath: function (previousPath) {
                  if (previousPath == null) {
                    return null;
                  }
                  return previousPath;
                },
                tryConvertClassName: function (previousClassName) {
                  if (previousClassName == null) {
                    return null;
                  }
                  if (this.metaClassNameEquivalence_1_rqkn57$.containsKey_za3rmp$(previousClassName)) {
                    var tmp$0;
                    return (tmp$0 = this.metaClassNameEquivalence_1_rqkn57$.get_za3rmp$(previousClassName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.metaClassNameEquivalence_2_rqkn58$.containsKey_za3rmp$(previousClassName)) {
                    var tmp$1;
                    return (tmp$1 = this.metaClassNameEquivalence_2_rqkn58$.get_za3rmp$(previousClassName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousClassName;
                },
                tryConvertAttName: function (previousAttName) {
                  if (previousAttName == null) {
                    return null;
                  }
                  var FQNattName = previousAttName;
                  if (this.attNameEquivalence_1_vwmrr1$.containsKey_za3rmp$(FQNattName)) {
                    var tmp$0;
                    return (tmp$0 = this.attNameEquivalence_1_vwmrr1$.get_za3rmp$(FQNattName)) != null ? tmp$0 : Kotlin.throwNPE();
                  }
                  if (this.attNameEquivalence_2_vwmrr2$.containsKey_za3rmp$(FQNattName)) {
                    var tmp$1;
                    return (tmp$1 = this.attNameEquivalence_2_vwmrr2$.get_za3rmp$(FQNattName)) != null ? tmp$1 : Kotlin.throwNPE();
                  }
                  return previousAttName;
                }
              }),
              TraceSequence: Kotlin.createClass(null, function (factory) {
                this.factory = factory;
                this.traces = new Kotlin.ArrayList();
              }, /** @lends _.org.kevoree.modeling.api.trace.TraceSequence.prototype */ {
                populate: function (addtraces) {
                  this.traces.addAll_xeylzf$(addtraces);
                  return this;
                },
                append: function (seq) {
                  this.traces.addAll_xeylzf$(seq.traces);
                },
                populateFromString: function (addtracesTxt) {
                  return this.populateFromStream(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(addtracesTxt));
                },
                populateFromStream: function (inputStream) {
                  var previousControlSrc = null;
                  var previousControlTypeName = null;
                  var lexer = new _.org.kevoree.modeling.api.json.Lexer(inputStream);
                  var currentToken = lexer.nextToken();
                  if (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                    throw new Error('Bad Format : expect [');
                  }
                  currentToken = lexer.nextToken();
                  var keys = new Kotlin.PrimitiveHashMap();
                  var previousName = null;
                  while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF && currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                    if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                      keys.clear();
                    }
                    if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                      if (previousName != null) {
                        keys.put_wn2jw4$(previousName != null ? previousName : Kotlin.throwNPE(), Kotlin.toString(currentToken.value));
                        previousName = null;
                      }
                       else {
                        previousName = Kotlin.toString(currentToken.value);
                      }
                    }
                    if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                      var traceTypeRead = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                      if (traceTypeRead == null) {
                        traceTypeRead = previousControlTypeName;
                      }
                      {
                        if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.CONTROL.code) {
                          var src = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (src != null) {
                            var tmp$0;
                            previousControlSrc = (tmp$0 = _.org.kevoree.modeling.api.json.JSONString.unescape(src)) != null ? tmp$0 : Kotlin.throwNPE();
                          }
                          var globalTypeName = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                          if (globalTypeName != null) {
                            previousControlTypeName = globalTypeName;
                          }
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.SET.code) {
                          var srcFound = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound == null) {
                            srcFound = previousControlSrc;
                          }
                           else {
                            srcFound = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound);
                          }
                          var tmp$1;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelSetTrace(srcFound != null ? srcFound : Kotlin.throwNPE(), (tmp$1 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$1 : Kotlin.throwNPE(), _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath)), _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.content)), _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename))));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.ADD.code) {
                          var srcFound_0 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_0 == null) {
                            srcFound_0 = previousControlSrc;
                          }
                           else {
                            srcFound_0 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_0);
                          }
                          var tmp$2, tmp$3;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(srcFound_0 != null ? srcFound_0 : Kotlin.throwNPE(), (tmp$2 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$2 : Kotlin.throwNPE(), _.org.kevoree.modeling.api.json.JSONString.unescape((tmp$3 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.previouspath)) != null ? tmp$3 : Kotlin.throwNPE()), keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename)));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL.code) {
                          var srcFound_1 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_1 == null) {
                            srcFound_1 = previousControlSrc;
                          }
                           else {
                            srcFound_1 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_1);
                          }
                          var tmp$4, tmp$5, tmp$6, tmp$7, tmp$8;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddAllTrace(srcFound_1 != null ? srcFound_1 : Kotlin.throwNPE(), (tmp$4 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$4 : Kotlin.throwNPE(), (tmp$6 = (tmp$5 = _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.content))) != null ? Kotlin.splitString(tmp$5, ';') : null) != null ? _.kotlin.toList_2hx8bi$(tmp$6) : null, (tmp$8 = (tmp$7 = _.org.kevoree.modeling.api.json.JSONString.unescape(keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename))) != null ? Kotlin.splitString(tmp$7, ';') : null) != null ? _.kotlin.toList_2hx8bi$(tmp$8) : null));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE.code) {
                          var srcFound_2 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_2 == null) {
                            srcFound_2 = previousControlSrc;
                          }
                           else {
                            srcFound_2 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_2);
                          }
                          var tmp$9, tmp$10, tmp$11;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(srcFound_2 != null ? srcFound_2 : Kotlin.throwNPE(), (tmp$9 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$9 : Kotlin.throwNPE(), (tmp$11 = _.org.kevoree.modeling.api.json.JSONString.unescape((tmp$10 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath)) != null ? tmp$10 : Kotlin.throwNPE())) != null ? tmp$11 : Kotlin.throwNPE()));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL.code) {
                          var srcFound_3 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                          if (srcFound_3 == null) {
                            srcFound_3 = previousControlSrc;
                          }
                           else {
                            srcFound_3 = _.org.kevoree.modeling.api.json.JSONString.unescape(srcFound_3);
                          }
                          var tmp$12;
                          this.traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace(srcFound_3 != null ? srcFound_3 : Kotlin.throwNPE(), (tmp$12 = keys.get_za3rmp$(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname)) != null ? tmp$12 : Kotlin.throwNPE()));
                        }
                         else if (traceTypeRead === _.org.kevoree.modeling.api.util.ActionType.object.RENEW_INDEX.code) {
                        }
                         else {
                          Kotlin.println('Trace lost !!!');
                        }
                      }
                    }
                    currentToken = lexer.nextToken();
                  }
                  return this;
                },
                exportToString: function () {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append('[');
                  var isFirst = true;
                  var previousSrc = null;
                  var previousType = null;
                  {
                    var tmp$0 = this.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(',\n');
                      }
                      if (previousSrc == null || !Kotlin.equals(previousSrc, trace.srcPath)) {
                        buffer.append((new _.org.kevoree.modeling.api.trace.ModelControlTrace(trace.srcPath, null)).toString());
                        buffer.append(',\n');
                        previousSrc = trace.srcPath;
                      }
                      if (previousType == null || !Kotlin.equals(previousType, trace.traceType.code)) {
                        buffer.append((new _.org.kevoree.modeling.api.trace.ModelControlTrace('', trace.traceType.code)).toString());
                        buffer.append(',\n');
                        previousType = trace.traceType.code;
                      }
                      buffer.append(trace.toCString(false, false));
                      isFirst = false;
                    }
                  }
                  buffer.append(']');
                  return buffer.toString();
                },
                toString: function () {
                  return this.exportToString();
                },
                applyOn: function (target) {
                  var traceApplicator = new _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, this.factory);
                  traceApplicator.applyTraceOnModel(this);
                  return true;
                },
                silentlyApplyOn: function (target) {
                  var traceApplicator = new _.org.kevoree.modeling.api.trace.ModelTraceApplicator(target, this.factory);
                  traceApplicator.fireEvents = false;
                  traceApplicator.applyTraceOnModel(this);
                  return true;
                },
                reverse: function () {
                  var reversed = new Kotlin.ArrayList();
                  var i = _.kotlin.get_size_1(this.traces);
                  while (i > 0) {
                    i = i - 1;
                    reversed.add_za3rmp$(this.traces.get_za3lpa$(i));
                  }
                  this.traces = reversed;
                }
              }),
              ModelTrace: Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.trace.ModelTrace.prototype */ {
                refName: {
                  get: function () {
                    return this.$refName_eb8jwl$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_cer0bq$;
                  }
                },
                srcPath: {
                  get: function () {
                    return this.$srcPath_z3ltm8$;
                  }
                },
                toString: function () {
                  return this.toCString(true, true);
                }
              }),
              ModelControlTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, traceTypeGlobal) {
                this.$srcPath_5kjq8d$ = srcPath;
                this.traceTypeGlobal = traceTypeGlobal;
                this.$refName_qcwzy0$ = '';
                this.$traceType_5dhonr$ = _.org.kevoree.modeling.api.util.ActionType.object.CONTROL;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelControlTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_5kjq8d$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_qcwzy0$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_5dhonr$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.CONTROL.code);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  if (this.traceTypeGlobal == null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                   else {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(this.traceTypeGlobal);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelAddTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, previousPath, typeName) {
                this.$srcPath_uvkbsf$ = srcPath;
                this.$refName_a3722s$ = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
                this.$traceType_2i989x$ = _.org.kevoree.modeling.api.util.ActionType.object.ADD;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_uvkbsf$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_a3722s$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_2i989x$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.ADD.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  if (this.previousPath != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.previouspath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.previousPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.typeName != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.typeName);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelAddAllTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, previousPath, typeName) {
                this.$srcPath_1h16pc$ = srcPath;
                this.$refName_m9egez$ = refName;
                this.previousPath = previousPath;
                this.typeName = typeName;
                this.$traceType_pralmu$ = _.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelAddAllTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_1h16pc$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_m9egez$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_pralmu$;
                  }
                },
                mkString: function (ss) {
                  if (ss == null) {
                    return null;
                  }
                  var buffer = new Kotlin.StringBuilder();
                  var isFirst = true;
                  {
                    var tmp$0 = ss.iterator();
                    while (tmp$0.hasNext()) {
                      var s = tmp$0.next();
                      if (!isFirst) {
                        buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                      }
                      buffer.append(s);
                      isFirst = false;
                    }
                  }
                  return buffer.toString();
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.ADD_ALL.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  if (this.previousPath != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.previouspath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.mkString(this.previousPath));
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.typeName != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.mkString(this.typeName));
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelRemoveTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, objPath) {
                this.$srcPath_7kbv2k$ = srcPath;
                this.$refName_d81en3$ = refName;
                this.objPath = objPath;
                this.$traceType_po7rum$ = _.org.kevoree.modeling.api.util.ActionType.object.REMOVE;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_7kbv2k$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_d81en3$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_po7rum$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.objPath);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelRemoveAllTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName) {
                this.$srcPath_mobmwd$ = srcPath;
                this.$refName_rkf5d4$ = refName;
                this.$traceType_z0g113$ = _.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_mobmwd$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_rkf5d4$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_z0g113$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              ModelSetTrace: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.trace.ModelTrace];
              }, function (srcPath, refName, objPath, content, typeName) {
                this.$srcPath_guqstu$ = srcPath;
                this.$refName_xdzzfn$ = refName;
                this.objPath = objPath;
                this.content = content;
                this.typeName = typeName;
                this.$traceType_j5yedg$ = _.org.kevoree.modeling.api.util.ActionType.object.SET;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelSetTrace.prototype */ {
                srcPath: {
                  get: function () {
                    return this.$srcPath_guqstu$;
                  }
                },
                refName: {
                  get: function () {
                    return this.$refName_xdzzfn$;
                  }
                },
                traceType: {
                  get: function () {
                    return this.$traceType_j5yedg$;
                  }
                },
                toCString: function (withTypeName, withSrcPath) {
                  var buffer = new Kotlin.StringBuilder();
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.openJSON);
                  if (withTypeName) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.traceType);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.util.ActionType.object.SET.code);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  if (withSrcPath) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.src);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.srcPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.refname);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  buffer.append(this.refName);
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  if (this.objPath != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.objpath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.objPath);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.content != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.content);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.content);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  if (this.typeName != null) {
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.coma);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.typename);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.dp);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                    _.org.kevoree.modeling.api.json.JSONString.encodeBuffer(buffer, this.typeName);
                    buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.bb);
                  }
                  buffer.append(_.org.kevoree.modeling.api.trace.ModelTraceConstants.closeJSON);
                  return buffer.toString();
                }
              }),
              TraceConverter: Kotlin.createTrait(null),
              ModelTraceApplicator: Kotlin.createClass(null, function (targetModel, factory) {
                this.targetModel = targetModel;
                this.factory = factory;
                this.pendingObj = null;
                this.pendingParent = null;
                this.pendingParentRefName = null;
                this.pendingObjPath = null;
                this.fireEvents = true;
              }, /** @lends _.org.kevoree.modeling.api.trace.ModelTraceApplicator.prototype */ {
                tryClosePending: function (srcPath) {
                  if (this.pendingObj != null && !Kotlin.equals(this.pendingObjPath, srcPath)) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.pendingParent) != null ? tmp$0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, (tmp$1 = this.pendingParentRefName) != null ? tmp$1 : Kotlin.throwNPE(), this.pendingObj, true, this.fireEvents);
                    this.pendingObj = null;
                    this.pendingObjPath = null;
                    this.pendingParentRefName = null;
                    this.pendingParent = null;
                  }
                },
                createOrAdd: function (previousPath, target, refName, potentialTypeName) {
                  var targetElem = null;
                  if (previousPath != null) {
                    targetElem = this.targetModel.findByPath(previousPath);
                  }
                  if (targetElem != null) {
                    target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refName, targetElem, true, this.fireEvents);
                  }
                   else {
                    if (potentialTypeName == null) {
                      throw new Error('Unknow typeName for potential path ' + Kotlin.toString(previousPath) + ', to store in ' + refName + ', unconsistency error');
                    }
                    this.pendingObj = this.factory.create(potentialTypeName);
                    this.pendingObjPath = previousPath;
                    this.pendingParentRefName = refName;
                    this.pendingParent = target;
                  }
                },
                applyTraceOnModel: function (traceSeq) {
                  {
                    var tmp$0 = traceSeq.traces.iterator();
                    while (tmp$0.hasNext()) {
                      var trace = tmp$0.next();
                      var target = this.targetModel;
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddTrace)) {
                        this.tryClosePending(null);
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          var resolvedTarget = this.targetModel.findByPath(trace.srcPath);
                          if (resolvedTarget == null) {
                            throw new Error('Add Trace source not found for path : ' + trace.srcPath + ' pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = resolvedTarget != null ? resolvedTarget : Kotlin.throwNPE();
                        }
                        this.createOrAdd(trace.previousPath, target, trace.refName, trace.typeName);
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelAddAllTrace)) {
                        this.tryClosePending(null);
                        var i = 0;
                        var tmp$1;
                        {
                          var tmp$2 = ((tmp$1 = trace.previousPath) != null ? tmp$1 : Kotlin.throwNPE()).iterator();
                          while (tmp$2.hasNext()) {
                            var path = tmp$2.next();
                            var tmp$3;
                            this.createOrAdd(path, target, trace.refName, ((tmp$3 = trace.typeName) != null ? tmp$3 : Kotlin.throwNPE()).get_za3lpa$(i));
                            i++;
                          }
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveTrace)) {
                        this.tryClosePending(trace.srcPath);
                        var tempTarget = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget = this.targetModel.findByPath(trace.srcPath);
                        }
                        if (tempTarget != null) {
                          (tempTarget != null ? tempTarget : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE, trace.refName, this.targetModel.findByPath(trace.objPath), true, this.fireEvents);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelRemoveAllTrace)) {
                        this.tryClosePending(trace.srcPath);
                        var tempTarget_0 = this.targetModel;
                        if (!Kotlin.equals(trace.srcPath, '')) {
                          tempTarget_0 = this.targetModel.findByPath(trace.srcPath);
                        }
                        if (tempTarget_0 != null) {
                          (tempTarget_0 != null ? tempTarget_0 : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.REMOVE_ALL, trace.refName, null, true, this.fireEvents);
                        }
                      }
                      if (Kotlin.isType(trace, _.org.kevoree.modeling.api.trace.ModelSetTrace)) {
                        this.tryClosePending(trace.srcPath);
                        if (!Kotlin.equals(trace.srcPath, '') && !Kotlin.equals(trace.srcPath, this.pendingObjPath)) {
                          var tempObject = this.targetModel.findByPath(trace.srcPath);
                          if (tempObject == null) {
                            throw new Error('Set Trace source not found for path : ' + trace.srcPath + ' pending ' + this.pendingObjPath + '\n' + trace.toString());
                          }
                          target = tempObject != null ? tempObject : Kotlin.throwNPE();
                        }
                         else {
                          if (Kotlin.equals(trace.srcPath, this.pendingObjPath) && this.pendingObj != null) {
                            var tmp$4;
                            target = (tmp$4 = this.pendingObj) != null ? tmp$4 : Kotlin.throwNPE();
                          }
                        }
                        if (trace.content != null) {
                          target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, trace.content, true, this.fireEvents);
                        }
                         else {
                          var tmp$5;
                          if (trace.objPath != null) {
                            tmp$5 = this.targetModel.findByPath(trace.objPath);
                          }
                           else {
                            tmp$5 = null;
                          }
                          var targetContentPath = tmp$5;
                          if (targetContentPath != null) {
                            target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, targetContentPath, true, this.fireEvents);
                          }
                           else {
                            if (trace.typeName != null && !Kotlin.equals(trace.typeName, '')) {
                              this.createOrAdd(trace.objPath, target, trace.refName, trace.typeName);
                            }
                             else {
                              target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, trace.refName, targetContentPath, true, this.fireEvents);
                            }
                          }
                        }
                      }
                    }
                  }
                  this.tryClosePending(null);
                }
              })
            }),
            compare: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.compare */ {
              ModelCompare: Kotlin.createClass(null, function (factory) {
                this.factory = factory;
              }, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare.prototype */ {
                diff: function (origin, target) {
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(this.internal_diff(origin, target, false, false));
                },
                merge: function (origin, target) {
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(this.internal_diff(origin, target, false, true));
                },
                inter: function (origin, target) {
                  return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(this.internal_diff(origin, target, true, false));
                },
                internal_diff: function (origin, target, inter, merge) {
                  var traces = new Kotlin.ArrayList();
                  var tracesRef = new Kotlin.ArrayList();
                  var objectsMap = new Kotlin.PrimitiveHashMap();
                  traces.addAll_xeylzf$(origin.createTraces(target, inter, merge, false, true));
                  tracesRef.addAll_xeylzf$(origin.createTraces(target, inter, merge, true, false));
                  var visitor = _.org.kevoree.modeling.api.compare.ModelCompare.internal_diff$f(objectsMap);
                  origin.visit(visitor, true, true, false);
                  var visitor2 = _.org.kevoree.modeling.api.compare.ModelCompare.internal_diff$f_0(objectsMap, inter, traces, merge, tracesRef);
                  target.visit(visitor2, true, true, false);
                  traces.addAll_xeylzf$(tracesRef);
                  if (!inter) {
                    if (!merge) {
                      {
                        var tmp$0 = objectsMap.keySet().iterator();
                        while (tmp$0.hasNext()) {
                          var diffChildKey = tmp$0.next();
                          var tmp$1, tmp$3, tmp$5;
                          var diffChild = (tmp$1 = objectsMap.get_za3rmp$(diffChildKey)) != null ? tmp$1 : Kotlin.throwNPE();
                          if (diffChild.eContainer() != null) {
                            var tmp$2;
                            tmp$3 = ((tmp$2 = diffChild.eContainer()) != null ? tmp$2 : Kotlin.throwNPE()).path();
                          }
                           else {
                            tmp$3 = 'null';
                          }
                          var src = tmp$3;
                          if (diffChild.getRefInParent() != null) {
                            var tmp$4;
                            tmp$5 = (tmp$4 = diffChild.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE();
                          }
                           else {
                            tmp$5 = 'null';
                          }
                          var refNameInParent = tmp$5;
                          traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelRemoveTrace(src, refNameInParent, diffChild.path()));
                        }
                      }
                    }
                  }
                  return traces;
                }
              }, /** @lends _.org.kevoree.modeling.api.compare.ModelCompare */ {
                internal_diff$f: function (objectsMap) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                  }, {
                    visit: function (elem, refNameInParent, parent) {
                      var childPath = elem.path();
                      if (childPath != null) {
                        objectsMap.put_wn2jw4$(childPath, elem);
                      }
                       else {
                        throw new Error('Null child path ' + elem);
                      }
                    }
                  });
                },
                internal_diff$f_0: function (objectsMap, inter, traces, merge, tracesRef) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                  }, {
                    visit: function (elem, refNameInParent, parent) {
                      var childPath = elem.path();
                      if (objectsMap.containsKey_za3rmp$(childPath)) {
                        if (inter) {
                          traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(parent.path(), refNameInParent, elem.path(), elem.metaClassName()));
                        }
                        var tmp$0, tmp$1;
                        traces.addAll_xeylzf$(((tmp$0 = objectsMap.get_za3rmp$(childPath)) != null ? tmp$0 : Kotlin.throwNPE()).createTraces(elem, inter, merge, false, true));
                        tracesRef.addAll_xeylzf$(((tmp$1 = objectsMap.get_za3rmp$(childPath)) != null ? tmp$1 : Kotlin.throwNPE()).createTraces(elem, inter, merge, true, false));
                        objectsMap.remove_za3rmp$(childPath);
                      }
                       else {
                        if (!inter) {
                          traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(parent.path(), refNameInParent, elem.path(), elem.metaClassName()));
                          traces.addAll_xeylzf$(elem.createTraces(elem, true, merge, false, true));
                          tracesRef.addAll_xeylzf$(elem.createTraces(elem, true, merge, true, false));
                        }
                      }
                    }
                  });
                }
              })
            }),
            events: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.events */ {
              ModelEvent: Kotlin.createClass(null, function (etype, elementAttributeType, elementAttributeName, value, previous_value, source, previousPath) {
                this.etype = etype;
                this.elementAttributeType = elementAttributeType;
                this.elementAttributeName = elementAttributeName;
                this.value = value;
                this.previous_value = previous_value;
                this.source = source;
                this.previousPath = previousPath;
              }, /** @lends _.org.kevoree.modeling.api.events.ModelEvent.prototype */ {
                toString: function () {
                  if (Kotlin.isType(this.source, _.org.kevoree.modeling.api.time.TimeAwareKMFContainer)) {
                    return 'ModelEvent[src:[' + this.source.now + ']' + this.source.path() + ', type:' + this.etype + ', elementAttributeType:' + this.elementAttributeType + ', elementAttributeName:' + this.elementAttributeName + ', value:' + Kotlin.toString(this.value) + ', previousValue:' + Kotlin.toString(this.previous_value) + ']';
                  }
                   else {
                    var tmp$0;
                    return 'ModelEvent[src:' + Kotlin.toString((tmp$0 = this.source) != null ? tmp$0.path() : null) + ', type:' + this.etype + ', elementAttributeType:' + this.elementAttributeType + ', elementAttributeName:' + this.elementAttributeName + ', value:' + Kotlin.toString(this.value) + ', previousValue:' + Kotlin.toString(this.previous_value) + ']';
                  }
                }
              }),
              ModelElementListener: Kotlin.createTrait(null)
            }),
            ModelPruner: Kotlin.createClass(null, function (factory) {
              this.factory = factory;
            }, /** @lends _.org.kevoree.modeling.api.ModelPruner.prototype */ {
              prune: function (elems) {
                var traces = new Kotlin.ArrayList();
                var tempMap = new Kotlin.PrimitiveHashMap();
                var parentMap = new Kotlin.PrimitiveHashMap();
                {
                  var tmp$0 = elems.iterator();
                  while (tmp$0.hasNext()) {
                    var elem = tmp$0.next();
                    this.internal_prune(elem, traces, tempMap, parentMap);
                  }
                }
                {
                  var tmp$1 = tempMap.keySet().iterator();
                  while (tmp$1.hasNext()) {
                    var toLinkKey = tmp$1.next();
                    var tmp$2;
                    var toLink = (tmp$2 = tempMap.get_za3rmp$(toLinkKey)) != null ? tmp$2 : Kotlin.throwNPE();
                    traces.addAll_xeylzf$(toLink.toTraces(false, true));
                  }
                }
                return (new _.org.kevoree.modeling.api.trace.TraceSequence(this.factory)).populate(traces);
              },
              internal_prune: function (elem, traces, cache, parentMap) {
                var parents = new Kotlin.ArrayList();
                var currentParent = elem.eContainer();
                while (currentParent != null && parentMap.get_za3rmp$((currentParent != null ? currentParent : Kotlin.throwNPE()).path()) == null && cache.get_za3rmp$((currentParent != null ? currentParent : Kotlin.throwNPE()).path()) == null) {
                  parents.add_za3rmp$(currentParent != null ? currentParent : Kotlin.throwNPE());
                  currentParent = (currentParent != null ? currentParent : Kotlin.throwNPE()).eContainer();
                }
                {
                  var tmp$0 = _.kotlin.reverse_h3panj$(parents).iterator();
                  while (tmp$0.hasNext()) {
                    var parent = tmp$0.next();
                    if (parent.eContainer() != null) {
                      var tmp$1, tmp$2;
                      traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(((tmp$1 = parent.eContainer()) != null ? tmp$1 : Kotlin.throwNPE()).path(), (tmp$2 = parent.getRefInParent()) != null ? tmp$2 : Kotlin.throwNPE(), parent.path(), parent.metaClassName()));
                    }
                    traces.addAll_xeylzf$(parent.toTraces(true, false));
                    parentMap.put_wn2jw4$(parent.path(), parent);
                  }
                }
                if (cache.get_za3rmp$(elem.path()) == null && parentMap.get_za3rmp$(elem.path()) == null) {
                  if (elem.eContainer() != null) {
                    var tmp$3, tmp$4;
                    traces.add_za3rmp$(new _.org.kevoree.modeling.api.trace.ModelAddTrace(((tmp$3 = elem.eContainer()) != null ? tmp$3 : Kotlin.throwNPE()).path(), (tmp$4 = elem.getRefInParent()) != null ? tmp$4 : Kotlin.throwNPE(), elem.path(), elem.metaClassName()));
                  }
                  traces.addAll_xeylzf$(elem.toTraces(true, false));
                }
                cache.put_wn2jw4$(elem.path(), elem);
                elem.visitReferences(_.org.kevoree.modeling.api.ModelPruner.internal_prune$f(cache, this, traces, parentMap));
              }
            }, /** @lends _.org.kevoree.modeling.api.ModelPruner */ {
              internal_prune$f: function (cache, this$ModelPruner, traces, parentMap) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (cache.get_za3rmp$(elem.path()) == null) {
                      this$ModelPruner.internal_prune(elem, traces, cache, parentMap);
                    }
                  }
                });
              }
            }),
            ModelLoader: Kotlin.createTrait(null),
            TimedContainer: Kotlin.createTrait(function () {
              return [_.org.kevoree.modeling.api.KMFContainer];
            }, /** @lends _.org.kevoree.modeling.api.TimedContainer.prototype */ {
              now: {
                get: function () {
                  return this.$now_2vpa82$;
                },
                set: function (tmp$0) {
                  this.$now_2vpa82$ = tmp$0;
                }
              }
            }),
            ModelCloner: Kotlin.createClass(null, function (factory) {
              this.factory = factory;
            }, /** @lends _.org.kevoree.modeling.api.ModelCloner.prototype */ {
              createContext: function () {
                return new _.java.util.IdentityHashMap();
              },
              clone: function (o) {
                return this.clone_1(o, false);
              },
              clone_1: function (o, readOnly) {
                return this.clone_2(o, readOnly, false);
              },
              cloneMutableOnly: function (o, readOnly) {
                return this.clone_2(o, readOnly, true);
              },
              cloneModelElem: function (src) {
                var tmp$0;
                var clonedSrc = (tmp$0 = this.factory.create(src.metaClassName())) != null ? tmp$0 : Kotlin.throwNPE();
                var attributesCloner = _.org.kevoree.modeling.api.ModelCloner.cloneModelElem$f(clonedSrc);
                src.visitAttributes(attributesCloner);
                return clonedSrc;
              },
              resolveModelElem: function (src, target, context, mutableOnly) {
                var refResolver = _.org.kevoree.modeling.api.ModelCloner.resolveModelElem$f(mutableOnly, target, context);
                src.visit(refResolver, false, true, true);
              },
              clone_2: function (o, readOnly, mutableOnly) {
                var context = this.createContext();
                var clonedObject = this.cloneModelElem(o);
                context.put_wn2jw4$(o, clonedObject);
                var cloneGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.clone_2$f(mutableOnly, context, this);
                o.visit(cloneGraphVisitor, true, true, false);
                var resolveGraphVisitor = _.org.kevoree.modeling.api.ModelCloner.clone_2$f_0(mutableOnly, context, this, readOnly);
                this.resolveModelElem(o, clonedObject, context, mutableOnly);
                o.visit(resolveGraphVisitor, true, true, false);
                if (readOnly) {
                  clonedObject.setInternalReadOnly();
                }
                if (o.isRoot()) {
                  this.factory.root(clonedObject);
                }
                return clonedObject;
              }
            }, /** @lends _.org.kevoree.modeling.api.ModelCloner */ {
              cloneModelElem$f: function (clonedSrc) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                }, null, {
                  visit: function (value, name, parent) {
                    if (value != null) {
                      if (Kotlin.isType(value, Kotlin.ArrayList)) {
                        var clonedList = new Kotlin.ArrayList();
                        clonedList.addAll_xeylzf$(value != null ? value : Kotlin.throwNPE());
                        clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, name, clonedList, false, false);
                      }
                       else {
                        clonedSrc.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, name, value, false, false);
                      }
                    }
                  }
                });
              },
              resolveModelElem$f: function (mutableOnly, target, context) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (mutableOnly && elem.isRecursiveReadOnly()) {
                      target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refNameInParent, elem, false, false);
                    }
                     else {
                      var elemResolved = context.get_za3rmp$(elem);
                      if (elemResolved == null) {
                        throw new Error('Cloner error, not self-contain model, the element ' + elem.path() + ' is contained in the root element');
                      }
                      target.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, refNameInParent, elemResolved, false, false);
                    }
                  }
                });
              },
              clone_2$f: function (mutableOnly, context, this$ModelCloner) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (mutableOnly && elem.isRecursiveReadOnly()) {
                      this.noChildrenVisit();
                    }
                     else {
                      context.put_wn2jw4$(elem, this$ModelCloner.cloneModelElem(elem));
                    }
                  }
                });
              },
              clone_2$f_0: function (mutableOnly, context, this$ModelCloner, readOnly) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  visit: function (elem, refNameInParent, parent) {
                    if (mutableOnly && elem.isRecursiveReadOnly()) {
                    }
                     else {
                      var tmp$0;
                      var clonedObj = (tmp$0 = context.get_za3rmp$(elem)) != null ? tmp$0 : Kotlin.throwNPE();
                      this$ModelCloner.resolveModelElem(elem, clonedObj, context, mutableOnly);
                      if (readOnly) {
                        clonedObj.setInternalReadOnly();
                      }
                    }
                  }
                });
              }
            }),
            TransactionManager: Kotlin.createTrait(null),
            Transaction: Kotlin.createTrait(null),
            TimeTransaction: Kotlin.createTrait(function () {
              return [_.org.kevoree.modeling.api.Transaction];
            }),
            KMFFactory: Kotlin.createTrait(null),
            KMFContainer: Kotlin.createTrait(null),
            ModelSerializer: Kotlin.createTrait(null),
            util: Kotlin.definePackage(function () {
              this.KevURLEncoder = Kotlin.createObject(null, function () {
                this.nonEscaped_rysd1l$ = new Kotlin.PrimitiveHashMap();
                this.escaped_qojrqa$ = new Kotlin.PrimitiveHashMap();
                this.rescaped_9ikhle$ = new Kotlin.PrimitiveHashMap();
                var i = 'a';
                while (i < 'z') {
                  this.nonEscaped_rysd1l$.put_wn2jw4$(i, true);
                  i++;
                }
                i = 'A';
                while (i < 'Z') {
                  this.nonEscaped_rysd1l$.put_wn2jw4$(i, true);
                  i++;
                }
                i = '0';
                while (i < '9') {
                  this.nonEscaped_rysd1l$.put_wn2jw4$(i, true);
                  i++;
                }
                this.escaped_qojrqa$.put_wn2jw4$('!', '%21');
                this.escaped_qojrqa$.put_wn2jw4$('"', '%22');
                this.escaped_qojrqa$.put_wn2jw4$('#', '%23');
                this.escaped_qojrqa$.put_wn2jw4$('$', '%24');
                this.escaped_qojrqa$.put_wn2jw4$('%', '%25');
                this.escaped_qojrqa$.put_wn2jw4$('&', '%26');
                this.escaped_qojrqa$.put_wn2jw4$('*', '%2A');
                this.escaped_qojrqa$.put_wn2jw4$(',', '%2C');
                this.escaped_qojrqa$.put_wn2jw4$('/', '%2F');
                this.escaped_qojrqa$.put_wn2jw4$(']', '%5B');
                this.escaped_qojrqa$.put_wn2jw4$('\\', '%5c');
                this.escaped_qojrqa$.put_wn2jw4$('[', '%5D');
                {
                  var tmp$0 = this.escaped_qojrqa$.keySet().iterator();
                  while (tmp$0.hasNext()) {
                    var c = tmp$0.next();
                    var tmp$1;
                    this.rescaped_9ikhle$.put_wn2jw4$((tmp$1 = this.escaped_qojrqa$.get_za3rmp$(c)) != null ? tmp$1 : Kotlin.throwNPE(), c);
                  }
                }
              }, {
                encode: function (chain) {
                  if (chain == null) {
                    return null;
                  }
                  var buffer = null;
                  var i = 0;
                  while (i < chain.length) {
                    var ch = chain.charAt(i);
                    if (_.kotlin.contains_6halgi$(this.nonEscaped_rysd1l$, ch)) {
                      if (buffer != null) {
                        (buffer != null ? buffer : Kotlin.throwNPE()).append(ch);
                      }
                    }
                     else {
                      var resolved = this.escaped_qojrqa$.get_za3rmp$(ch);
                      if (resolved != null) {
                        if (buffer == null) {
                          buffer = new Kotlin.StringBuilder();
                          (buffer != null ? buffer : Kotlin.throwNPE()).append(chain.substring(0, i));
                        }
                        (buffer != null ? buffer : Kotlin.throwNPE()).append(resolved);
                      }
                    }
                    i = i + 1;
                  }
                  if (buffer != null) {
                    return Kotlin.toString(buffer);
                  }
                   else {
                    return chain;
                  }
                },
                decode: function (src) {
                  if (src == null) {
                    return null;
                  }
                  if (src.length === 0) {
                    return src;
                  }
                  var builder = null;
                  var i = 0;
                  while (i < src.length) {
                    var current = src.charAt(i);
                    if (current === '%') {
                      if (builder == null) {
                        builder = new Kotlin.StringBuilder();
                        builder != null ? builder.append(src.substring(0, i)) : null;
                      }
                      var key = current.toString() + src.charAt(i + 1) + src.charAt(i + 2);
                      var resolved = this.rescaped_9ikhle$.get_za3rmp$(key);
                      if (resolved == null) {
                        builder = builder != null ? builder.append(key) : null;
                      }
                       else {
                        builder = builder != null ? builder.append(resolved) : null;
                      }
                      i = i + 2;
                    }
                     else {
                      if (builder != null) {
                        builder = builder != null ? builder.append(current) : null;
                      }
                    }
                    i++;
                  }
                  if (builder != null) {
                    return (builder != null ? builder : Kotlin.throwNPE()).toString();
                  }
                   else {
                    return src;
                  }
                }
              });
              this.AttConverter = Kotlin.createObject(null, null, {
                convFlatAtt: function (value) {
                  if (value == null) {
                    return null;
                  }
                  if (Kotlin.isType(value, Kotlin.ArrayList)) {
                    var isF = true;
                    var buffer = new Kotlin.StringBuilder();
                    {
                      var tmp$0 = value.iterator();
                      while (tmp$0.hasNext()) {
                        var v = tmp$0.next();
                        if (!isF) {
                          buffer.append('$');
                        }
                        buffer.append(Kotlin.toString(v));
                        isF = false;
                      }
                    }
                    return buffer.toString();
                  }
                   else {
                    return value.toString();
                  }
                },
                convAttFlat: function (value) {
                  return Kotlin.splitString(value.toString(), '$');
                }
              });
              this.ByteConverter = Kotlin.createObject(null, null, {
                toChar: function (b) {
                  return b;
                },
                fromChar: function (b) {
                  return b;
                },
                byteArrayInputStreamFromString: function (str) {
                  var bytes = Kotlin.numberArrayOfSize(str.length);
                  var i = 0;
                  while (i < str.length) {
                    bytes[i] = str.charAt(i);
                    i = i + 1;
                  }
                  return new _.java.io.ByteArrayInputStream(bytes);
                }
              });
              this.Selector = Kotlin.createObject(null, null, {
                select: function (root, query) {
                  var extractedQuery = this.extractFirstQuery(query);
                  var result = new Kotlin.ArrayList();
                  var tempResult = {v: new Kotlin.PrimitiveHashMap()};
                  tempResult.v.put_wn2jw4$(root.path(), root);
                  while (extractedQuery != null) {
                    var staticExtractedQuery = extractedQuery != null ? extractedQuery : Kotlin.throwNPE();
                    for (var key in staticExtractedQuery.params.map) {
                      staticExtractedQuery.params.map[key].value = '^'+staticExtractedQuery.params.map[key].value+'$';
                    }
                    var clonedRound = tempResult.v;
                    tempResult.v = new Kotlin.PrimitiveHashMap();
                    {
                      var tmp$0 = clonedRound.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var currentRootKey = tmp$0.next();
                        var tmp$1;
                        var currentRoot = (tmp$1 = clonedRound.get_za3rmp$(currentRootKey)) != null ? tmp$1 : Kotlin.throwNPE();
                        var resolved = null;
                        if (!staticExtractedQuery.oldString.contains('*')) {
                          resolved = currentRoot.findByPath(staticExtractedQuery.oldString);
                        }
                        if (resolved != null) {
                          tempResult.v.put_wn2jw4$((resolved != null ? resolved : Kotlin.throwNPE()).path(), resolved != null ? resolved : Kotlin.throwNPE());
                        }
                         else {
                          var alreadyVisited = {v: new Kotlin.PrimitiveHashMap()};
                          var visitor = _.org.kevoree.modeling.api.util.select$f(staticExtractedQuery, alreadyVisited, tempResult);
                          if (staticExtractedQuery.previousIsDeep) {
                            currentRoot.visit(visitor, false, true, staticExtractedQuery.previousIsRefDeep);
                          }
                           else {
                            currentRoot.visit(visitor, false, true, true);
                          }
                        }
                      }
                    }
                    if (staticExtractedQuery.subQuery == null) {
                      extractedQuery = null;
                    }
                     else {
                      extractedQuery = this.extractFirstQuery(staticExtractedQuery.subQuery);
                    }
                  }
                  {
                    var tmp$2 = tempResult.v.keySet().iterator();
                    while (tmp$2.hasNext()) {
                      var v = tmp$2.next();
                      var tmp$3;
                      result.add_za3rmp$((tmp$3 = tempResult.v.get_za3rmp$(v)) != null ? tmp$3 : Kotlin.throwNPE());
                    }
                  }
                  return result;
                },
                extractFirstQuery: function (query) {
                  if (query.charAt(0) === '/') {
                    var subQuery = null;
                    if (query.length > 1) {
                      subQuery = query.substring(1);
                    }
                    var params = new Kotlin.PrimitiveHashMap();
                    return new _.org.kevoree.modeling.api.util.KmfQuery('', params, subQuery, '/', false, false);
                  }
                  if (query.startsWith('**/')) {
                    if (query.length > 3) {
                      var next = this.extractFirstQuery(query.substring(3));
                      if (next != null) {
                        next.previousIsDeep = true;
                        next.previousIsRefDeep = false;
                      }
                      return next;
                    }
                     else {
                      return null;
                    }
                  }
                  if (query.startsWith('***/')) {
                    if (query.length > 4) {
                      var next_0 = this.extractFirstQuery(query.substring(4));
                      if (next_0 != null) {
                        next_0.previousIsDeep = true;
                        next_0.previousIsRefDeep = true;
                      }
                      return next_0;
                    }
                     else {
                      return null;
                    }
                  }
                  var i = 0;
                  var relationNameEnd = 0;
                  var attsEnd = 0;
                  var escaped = false;
                  while (i < query.length && (query.charAt(i) !== '/' || escaped)) {
                    if (escaped) {
                      escaped = false;
                    }
                    if (query.charAt(i) === '[') {
                      relationNameEnd = i;
                    }
                     else {
                      if (query.charAt(i) === ']') {
                        attsEnd = i;
                      }
                       else {
                        if (query.charAt(i) === '\\') {
                          escaped = true;
                        }
                      }
                    }
                    i = i + 1;
                  }
                  if (i > 0 && relationNameEnd > 0) {
                    var oldString = query.substring(0, i);
                    var subQuery_0 = null;
                    if (i + 1 < query.length) {
                      subQuery_0 = query.substring(i + 1);
                    }
                    var relName = query.substring(0, relationNameEnd);
                    var params_0 = new Kotlin.PrimitiveHashMap();
                    relName = relName.replace('\\', '');
                    if (attsEnd !== 0) {
                      var paramString = query.substring(relationNameEnd + 1, attsEnd);
                      var iParam = 0;
                      var lastStart = iParam;
                      escaped = false;
                      while (iParam < paramString.length) {
                        if (paramString.charAt(iParam) === ',' && !escaped) {
                          var p = paramString.substring(lastStart, iParam).trim();
                          if (!Kotlin.equals(p, '') && !Kotlin.equals(p, '*')) {
                            if (p.endsWith('=')) {
                              p = p + '*';
                            }
                            var pArray = Kotlin.splitString(p, '=');
                            var pObject;
                            if (pArray.length > 1) {
                              var paramKey = pArray[0].trim();
                              var negative = paramKey.endsWith('!');
                              pObject = new _.org.kevoree.modeling.api.util.KmfQueryParam(paramKey.replace('!', ''), pArray[1].trim(), _.kotlin.get_size(params_0), negative);
                              var tmp$0;
                              params_0.put_wn2jw4$((tmp$0 = pObject.name) != null ? tmp$0 : Kotlin.throwNPE(), pObject);
                            }
                             else {
                              pObject = new _.org.kevoree.modeling.api.util.KmfQueryParam(null, p, _.kotlin.get_size(params_0), false);
                              params_0.put_wn2jw4$('@id', pObject);
                            }
                          }
                          lastStart = iParam + 1;
                        }
                         else {
                          if (paramString.charAt(iParam) === '\\') {
                            escaped = true;
                          }
                           else {
                            escaped = false;
                          }
                        }
                        iParam = iParam + 1;
                      }
                      var lastParam = paramString.substring(lastStart, iParam).trim();
                      if (!Kotlin.equals(lastParam, '') && !Kotlin.equals(lastParam, '*')) {
                        if (lastParam.endsWith('=')) {
                          lastParam = lastParam + '*';
                        }
                        var pArray_0 = Kotlin.splitString(lastParam, '=');
                        var pObject_0;
                        if (pArray_0.length > 1) {
                          var paramKey_0 = pArray_0[0].trim();
                          var negative_0 = paramKey_0.endsWith('!');
                          pObject_0 = new _.org.kevoree.modeling.api.util.KmfQueryParam(paramKey_0.replace('!', ''), pArray_0[1].trim(), _.kotlin.get_size(params_0), negative_0);
                          var tmp$1;
                          params_0.put_wn2jw4$((tmp$1 = pObject_0.name) != null ? tmp$1 : Kotlin.throwNPE(), pObject_0);
                        }
                         else {
                          pObject_0 = new _.org.kevoree.modeling.api.util.KmfQueryParam(null, lastParam, _.kotlin.get_size(params_0), false);
                          params_0.put_wn2jw4$('@id', pObject_0);
                        }
                      }
                    }
                    return new _.org.kevoree.modeling.api.util.KmfQuery(relName, params_0, subQuery_0, oldString, false, false);
                  }
                  return null;
                }
              });
            }, /** @lends _.org.kevoree.modeling.api.util */ {
              ModelVisitor: Kotlin.createClass(null, function () {
                this.visitStopped = false;
                this.visitChildren = true;
                this.visitReferences = true;
                this.alreadyVisited = null;
              }, /** @lends _.org.kevoree.modeling.api.util.ModelVisitor.prototype */ {
                stopVisit: function () {
                  this.visitStopped = true;
                },
                noChildrenVisit: function () {
                  this.visitChildren = false;
                },
                noReferencesVisit: function () {
                  this.visitReferences = false;
                },
                beginVisitElem: function (elem) {
                },
                endVisitElem: function (elem) {
                },
                beginVisitRef: function (refName, refType) {
                  return true;
                },
                endVisitRef: function (refName) {
                }
              }),
              ElementAttributeType: Kotlin.createClass(function () {
                return [Kotlin.Enum];
              }, function $fun() {
                $fun.baseInitializer.call(this);
              }, null, /** @lends _.org.kevoree.modeling.api.util.ElementAttributeType */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    ATTRIBUTE: new _.org.kevoree.modeling.api.util.ElementAttributeType(),
                    REFERENCE: new _.org.kevoree.modeling.api.util.ElementAttributeType(),
                    CONTAINMENT: new _.org.kevoree.modeling.api.util.ElementAttributeType()
                  });
                }
              }),
              ActionType: Kotlin.createClass(function () {
                return [Kotlin.Enum];
              }, function $fun(code) {
                $fun.baseInitializer.call(this);
                this.code = code;
              }, null, /** @lends _.org.kevoree.modeling.api.util.ActionType */ {
                object_initializer$: function () {
                  return Kotlin.createEnumEntries({
                    SET: new _.org.kevoree.modeling.api.util.ActionType('S'),
                    ADD: new _.org.kevoree.modeling.api.util.ActionType('a'),
                    REMOVE: new _.org.kevoree.modeling.api.util.ActionType('r'),
                    ADD_ALL: new _.org.kevoree.modeling.api.util.ActionType('A'),
                    REMOVE_ALL: new _.org.kevoree.modeling.api.util.ActionType('R'),
                    RENEW_INDEX: new _.org.kevoree.modeling.api.util.ActionType('I'),
                    CONTROL: new _.org.kevoree.modeling.api.util.ActionType('C')
                  });
                }
              }),
              ModelAttributeVisitor: Kotlin.createTrait(null),
              InboundRefAware: Kotlin.createTrait(null, /** @lends _.org.kevoree.modeling.api.util.InboundRefAware.prototype */ {
                internal_inboundReferences: {
                  get: function () {
                    return this.$internal_inboundReferences_geftyz$;
                  },
                  set: function (tmp$0) {
                    this.$internal_inboundReferences_geftyz$ = tmp$0;
                  }
                }
              }),
              ModelTracker: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.events.ModelElementListener];
              }, function (compare) {
                this.compare = compare;
                this.convertor = new _.org.kevoree.modeling.api.trace.Event2Trace(this.compare);
                this.currentModel = null;
                this.invertedTraceSequence = null;
                this.traceSequence = null;
                this.activated = true;
              }, /** @lends _.org.kevoree.modeling.api.util.ModelTracker.prototype */ {
                elementChanged: function (evt) {
                  if (this.activated) {
                    var tmp$0, tmp$1;
                    ((tmp$0 = this.traceSequence) != null ? tmp$0 : Kotlin.throwNPE()).append(this.convertor.convert(evt));
                    ((tmp$1 = this.invertedTraceSequence) != null ? tmp$1 : Kotlin.throwNPE()).append(this.convertor.inverse(evt));
                  }
                },
                track: function (model) {
                  this.currentModel = model;
                  var tmp$0;
                  ((tmp$0 = this.currentModel) != null ? tmp$0 : Kotlin.throwNPE()).addModelTreeListener(this);
                  this.traceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                  this.invertedTraceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                },
                untrack: function () {
                  var tmp$0;
                  (tmp$0 = this.currentModel) != null ? tmp$0.removeModelTreeListener(this) : null;
                },
                redo: function () {
                  if (this.currentModel != null && this.traceSequence != null) {
                    this.activated = false;
                    try {
                      var tmp$0, tmp$1;
                      ((tmp$0 = this.traceSequence) != null ? tmp$0 : Kotlin.throwNPE()).applyOn((tmp$1 = this.currentModel) != null ? tmp$1 : Kotlin.throwNPE());
                    }
                    finally {
                      this.activated = true;
                    }
                  }
                },
                undo: function () {
                  if (this.currentModel != null && this.invertedTraceSequence != null) {
                    this.activated = false;
                    var tmp$0;
                    ((tmp$0 = this.invertedTraceSequence) != null ? tmp$0 : Kotlin.throwNPE()).reverse();
                    try {
                      var tmp$1, tmp$2;
                      ((tmp$1 = this.invertedTraceSequence) != null ? tmp$1 : Kotlin.throwNPE()).applyOn((tmp$2 = this.currentModel) != null ? tmp$2 : Kotlin.throwNPE());
                    }
                    finally {
                      var tmp$3;
                      ((tmp$3 = this.invertedTraceSequence) != null ? tmp$3 : Kotlin.throwNPE()).reverse();
                      this.activated = true;
                    }
                  }
                },
                reset: function () {
                  this.traceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                  this.invertedTraceSequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this.compare.factory);
                }
              }),
              visit$f: function (i) {
                return false;
              },
              visit$f_0: function (staticExtractedQuery, subResult) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                }, null, {
                  visit: function (value, name, parent) {
                    {
                      var tmp$0 = staticExtractedQuery.params.keySet().iterator();
                      while (tmp$0.hasNext()) {
                        var att = tmp$0.next();
                        if (Kotlin.equals(att, '@id')) {
                          throw new Error('Malformed KMFQuery, bad selector attribute without attribute name : ' + staticExtractedQuery.params.get_za3rmp$(att));
                        }
                         else {
                          var keySelected = false;
                          if (Kotlin.equals(att, name)) {
                            keySelected = true;
                          }
                           else {
                            if (att.contains('*') && _.js.matches_94jgcu$(name, att.replace('*', '.*'))) {
                              keySelected = true;
                            }
                          }
                          var tmp$1;
                          var attvalue = (tmp$1 = staticExtractedQuery.params.get_za3rmp$(att)) != null ? tmp$1 : Kotlin.throwNPE();
                          if (keySelected) {
                            if (value == null) {
                              if (attvalue.negative) {
                                if (!Kotlin.equals(attvalue.value, 'null')) {
                                  subResult[attvalue.idParam] = true;
                                }
                              }
                               else {
                                if (Kotlin.equals(attvalue.value, 'null')) {
                                  subResult[attvalue.idParam] = true;
                                }
                              }
                            }
                             else {
                              if (attvalue.negative) {
                                if (!attvalue.value.contains('*') && !Kotlin.equals(value, attvalue.value)) {
                                  subResult[attvalue.idParam] = true;
                                }
                                 else {
                                  if (!_.js.matches_94jgcu$(value.toString(), attvalue.value.replace('*', '.*'))) {
                                    subResult[attvalue.idParam] = true;
                                  }
                                }
                              }
                               else {
                                if (Kotlin.equals(value, attvalue.value)) {
                                  subResult[attvalue.idParam] = true;
                                }
                                 else {
                                  if (_.js.matches_94jgcu$(value.toString(), attvalue.value.replace('*', '.*'))) {
                                    subResult[attvalue.idParam] = true;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                });
              },
              select$f: function (staticExtractedQuery, alreadyVisited, tempResult) {
                return Kotlin.createObject(function () {
                  return [_.org.kevoree.modeling.api.util.ModelVisitor];
                }, function $fun() {
                  $fun.baseInitializer.call(this);
                }, {
                  beginVisitRef: function (refName, refType) {
                    if (staticExtractedQuery.previousIsDeep) {
                      return true;
                    }
                     else {
                      if (Kotlin.equals(refName, staticExtractedQuery.relationName)) {
                        return true;
                      }
                       else {
                        if (staticExtractedQuery.relationName.contains('*')) {
                          if (_.js.matches_94jgcu$(refName, staticExtractedQuery.relationName.replace('*', '.*'))) {
                            return true;
                          }
                        }
                      }
                      return false;
                    }
                  },
                  visit: function (elem, refNameInParent, parent) {
                    if (staticExtractedQuery.previousIsRefDeep) {
                      if (alreadyVisited.v.containsKey_za3rmp$(parent.path() + '/' + refNameInParent + '[' + elem.internalGetKey() + ']')) {
                        return;
                      }
                    }
                    if (staticExtractedQuery.previousIsDeep && !staticExtractedQuery.previousIsRefDeep) {
                      if (alreadyVisited.v.containsKey_za3rmp$(elem.path())) {
                        return;
                      }
                    }
                    var selected = true;
                    if (staticExtractedQuery.previousIsDeep) {
                      selected = false;
                      if (Kotlin.equals(refNameInParent, staticExtractedQuery.relationName)) {
                        selected = true;
                      }
                       else {
                        if (staticExtractedQuery.relationName.contains('*')) {
                          if (_.js.matches_94jgcu$(refNameInParent, staticExtractedQuery.relationName.replace('*', '.*'))) {
                            selected = true;
                          }
                        }
                      }
                    }
                    if (selected) {
                      var tmp$0;
                      if (_.kotlin.get_size(staticExtractedQuery.params) === 1 && staticExtractedQuery.params.get_za3rmp$('@id') != null && ((tmp$0 = staticExtractedQuery.params.get_za3rmp$('@id')) != null ? tmp$0 : Kotlin.throwNPE()).name == null) {
                        var tmp$1;
                        if (Kotlin.equals(elem.internalGetKey(), (tmp$1 = staticExtractedQuery.params.get_za3rmp$('@id')) != null ? tmp$1.value : null)) {
                          tempResult.v.put_wn2jw4$(elem.path(), elem);
                        }
                      }
                       else {
                        if (_.kotlin.get_size(staticExtractedQuery.params) > 0) {
                          var subResult = Kotlin.arrayFromFun(_.kotlin.get_size(staticExtractedQuery.params), _.org.kevoree.modeling.api.util.visit$f);
                          elem.visitAttributes(_.org.kevoree.modeling.api.util.visit$f_0(staticExtractedQuery, subResult));
                          var finalRes = true;
                          var tmp$2, tmp$3, tmp$4;
                          {
                            tmp$2 = subResult, tmp$3 = tmp$2.length;
                            for (var tmp$4 = 0; tmp$4 !== tmp$3; ++tmp$4) {
                              var sub = tmp$2[tmp$4];
                              if (!sub) {
                                finalRes = false;
                              }
                            }
                          }
                          if (finalRes) {
                            tempResult.v.put_wn2jw4$(elem.path(), elem);
                          }
                        }
                         else {
                          tempResult.v.put_wn2jw4$(elem.path(), elem);
                        }
                      }
                    }
                    if (staticExtractedQuery.previousIsDeep) {
                      if (staticExtractedQuery.previousIsRefDeep) {
                        alreadyVisited.v.put_wn2jw4$(parent.path() + '/' + refNameInParent + '[' + elem.internalGetKey() + ']', true);
                        elem.visit(this, false, true, true);
                      }
                       else {
                        alreadyVisited.v.put_wn2jw4$(elem.path(), true);
                        elem.visit(this, false, true, false);
                      }
                    }
                  }
                });
              },
              KmfQuery: Kotlin.createClass(null, function (relationName, params, subQuery, oldString, previousIsDeep, previousIsRefDeep) {
                this.relationName = relationName;
                this.params = params;
                this.subQuery = subQuery;
                this.oldString = oldString;
                this.previousIsDeep = previousIsDeep;
                this.previousIsRefDeep = previousIsRefDeep;
              }, /** @lends _.org.kevoree.modeling.api.util.KmfQuery.prototype */ {
                component1: function () {
                  return this.relationName;
                },
                component2: function () {
                  return this.params;
                },
                component3: function () {
                  return this.subQuery;
                },
                component4: function () {
                  return this.oldString;
                },
                component5: function () {
                  return this.previousIsDeep;
                },
                component6: function () {
                  return this.previousIsRefDeep;
                },
                copy: function (relationName, params, subQuery, oldString, previousIsDeep, previousIsRefDeep) {
                  return new _.org.kevoree.modeling.api.util.KmfQuery(relationName === void 0 ? this.relationName : relationName, params === void 0 ? this.params : params, subQuery === void 0 ? this.subQuery : subQuery, oldString === void 0 ? this.oldString : oldString, previousIsDeep === void 0 ? this.previousIsDeep : previousIsDeep, previousIsRefDeep === void 0 ? this.previousIsRefDeep : previousIsRefDeep);
                },
                toString: function () {
                  return 'KmfQuery(relationName=' + Kotlin.toString(this.relationName) + (', params=' + Kotlin.toString(this.params)) + (', subQuery=' + Kotlin.toString(this.subQuery)) + (', oldString=' + Kotlin.toString(this.oldString)) + (', previousIsDeep=' + Kotlin.toString(this.previousIsDeep)) + (', previousIsRefDeep=' + Kotlin.toString(this.previousIsRefDeep)) + ')';
                },
                hashCode: function () {
                  var result = -1987101201;
                  result = result * 31 + Kotlin.hashCode(this.relationName) | 0;
                  result = result * 31 + Kotlin.hashCode(this.params) | 0;
                  result = result * 31 + Kotlin.hashCode(this.subQuery) | 0;
                  result = result * 31 + Kotlin.hashCode(this.oldString) | 0;
                  result = result * 31 + Kotlin.hashCode(this.previousIsDeep) | 0;
                  result = result * 31 + Kotlin.hashCode(this.previousIsRefDeep) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.relationName, other.relationName) && Kotlin.equals(this.params, other.params) && Kotlin.equals(this.subQuery, other.subQuery) && Kotlin.equals(this.oldString, other.oldString) && Kotlin.equals(this.previousIsDeep, other.previousIsDeep) && Kotlin.equals(this.previousIsRefDeep, other.previousIsRefDeep))));
                }
              }),
              KmfQueryParam: Kotlin.createClass(null, function (name, value, idParam, negative) {
                this.name = name;
                this.value = value;
                this.idParam = idParam;
                this.negative = negative;
              }, /** @lends _.org.kevoree.modeling.api.util.KmfQueryParam.prototype */ {
                component1: function () {
                  return this.name;
                },
                component2: function () {
                  return this.value;
                },
                component3: function () {
                  return this.idParam;
                },
                component4: function () {
                  return this.negative;
                },
                copy: function (name, value, idParam, negative) {
                  return new _.org.kevoree.modeling.api.util.KmfQueryParam(name === void 0 ? this.name : name, value === void 0 ? this.value : value, idParam === void 0 ? this.idParam : idParam, negative === void 0 ? this.negative : negative);
                },
                toString: function () {
                  return 'KmfQueryParam(name=' + Kotlin.toString(this.name) + (', value=' + Kotlin.toString(this.value)) + (', idParam=' + Kotlin.toString(this.idParam)) + (', negative=' + Kotlin.toString(this.negative)) + ')';
                },
                hashCode: function () {
                  var result = -874887202;
                  result = result * 31 + Kotlin.hashCode(this.name) | 0;
                  result = result * 31 + Kotlin.hashCode(this.value) | 0;
                  result = result * 31 + Kotlin.hashCode(this.idParam) | 0;
                  result = result * 31 + Kotlin.hashCode(this.negative) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.name, other.name) && Kotlin.equals(this.value, other.value) && Kotlin.equals(this.idParam, other.idParam) && Kotlin.equals(this.negative, other.negative))));
                }
              })
            }),
            persistence: Kotlin.definePackage(null, /** @lends _.org.kevoree.modeling.api.persistence */ {
              PersistenceKMFFactory: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.events.ModelElementListener, _.org.kevoree.modeling.api.KMFFactory];
              }, /** @lends _.org.kevoree.modeling.api.persistence.PersistenceKMFFactory.prototype */ {
                datastore: {
                  get: function () {
                    return this.$datastore_xkqfe9$;
                  }
                },
                dirty: {
                  get: function () {
                    return this.$dirty_e66hhy$;
                  },
                  set: function (tmp$0) {
                    this.$dirty_e66hhy$ = tmp$0;
                  }
                },
                originTransaction: {
                  get: function () {
                    return this.$originTransaction_kdsx68$;
                  }
                },
                remove: function (elem) {
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elem.path());
                  this.datastore.remove('type', elem.path());
                  this.elem_cache.remove_za3rmp$(elem.path());
                  this.modified_elements.remove_za3rmp$(Kotlin.hashCode(elem).toString() + elem.internalGetKey());
                },
                elem_cache: {
                  get: function () {
                    return this.$elem_cache_55i3ba$;
                  }
                },
                elementsToBeRemoved: {
                  get: function () {
                    return this.$elementsToBeRemoved_qnzocd$;
                  }
                },
                modified_elements: {
                  get: function () {
                    return this.$modified_elements_qtc91h$;
                  }
                },
                notify: function (elem) {
                  if (elem.internalGetKey() != null) {
                    var key = Kotlin.hashCode(elem).toString() + elem.internalGetKey();
                    if (this.modified_elements.get_za3rmp$(key) == null) {
                      this.modified_elements.put_wn2jw4$(key, elem);
                    }
                    if (elem.path().startsWith('/')) {
                      this.elem_cache.put_wn2jw4$(elem.path(), elem);
                    }
                  }
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy) && !elem.isDirty) {
                    elem.isDirty = true;
                  }
                },
                cleanUnusedPaths: function (path) {
                  this.datastore.remove(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), path);
                  this.datastore.remove('type', path);
                  this.elem_cache.remove_za3rmp$(path);
                },
                persist: function (elem) {
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy) && !elem.isDirty) {
                    return;
                  }
                  var elemPath = elem.path();
                  if (Kotlin.equals(elemPath, '')) {
                    throw new Error('Internal error, empty path found during persist method ' + elem);
                  }
                  if (!elemPath.startsWith('/')) {
                    throw new Error('Cannot persist, because the path of the element do not refer to a root: ' + elemPath + ' -> ' + elem);
                  }
                  var traces = elem.toTraces(true, true);
                  var traceSeq = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  traceSeq.populate(traces);
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elemPath, traceSeq.exportToString());
                  var castedInBounds = elem;
                  var saved = _.org.kevoree.modeling.api.time.blob.MetaHelper.serialize(castedInBounds.internal_inboundReferences);
                  this.datastore.put(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elemPath + '#', saved);
                  this.datastore.put('type', elemPath, elem.metaClassName());
                  if (Kotlin.isType(elem, _.org.kevoree.modeling.api.persistence.KMFContainerProxy)) {
                    elem.originFactory = this;
                  }
                },
                endCommit: function () {
                  this.datastore.commit();
                },
                commit: function () {
                  if (!this.dirty) {
                    return;
                  }
                  var keys = _.kotlin.toList_h3panj$(this.modified_elements.keySet());
                  {
                    var tmp$0 = keys.iterator();
                    while (tmp$0.hasNext()) {
                      var elem = tmp$0.next();
                      var resolved = this.modified_elements.get_za3rmp$(elem);
                      if (resolved != null) {
                        if (!resolved.path().startsWith('/')) {
                          if (!resolved.isDeleted()) {
                            resolved.delete();
                          }
                          this.modified_elements.remove_za3rmp$(elem);
                        }
                      }
                    }
                  }
                  {
                    var tmp$1 = this.modified_elements.keySet().iterator();
                    while (tmp$1.hasNext()) {
                      var elemKey = tmp$1.next();
                      var tmp$2;
                      var elem_0 = (tmp$2 = this.modified_elements.get_za3rmp$(elemKey)) != null ? tmp$2 : Kotlin.throwNPE();
                      this.persist(elem_0);
                      this.elementsToBeRemoved.remove_za3rmp$(elem_0.path());
                    }
                  }
                  {
                    var tmp$3 = this.elementsToBeRemoved.iterator();
                    while (tmp$3.hasNext()) {
                      var e = tmp$3.next();
                      this.cleanUnusedPaths(e);
                    }
                  }
                },
                clear: function () {
                  {
                    var tmp$0 = this.elem_cache.keySet().iterator();
                    while (tmp$0.hasNext()) {
                      var elemKey = tmp$0.next();
                      var tmp$1;
                      var elem = (tmp$1 = this.elem_cache.get_za3rmp$(elemKey)) != null ? tmp$1 : Kotlin.throwNPE();
                      elem.removeModelElementListener(this);
                    }
                  }
                  this.elem_cache.clear();
                  this.modified_elements.clear();
                  this.elementsToBeRemoved.clear();
                },
                elementChanged: function (evt) {
                  var tmp$0;
                  ((tmp$0 = evt.source) != null ? tmp$0 : Kotlin.throwNPE()).isDirty = true;
                  this.notify(evt.source);
                },
                monitor: function (elem) {
                  if (!this.dirty) {
                    this.dirty = true;
                  }
                  elem.addModelElementListener(this);
                },
                lookup: function (path) {
                  if (Kotlin.equals(path, '')) {
                    return null;
                  }
                  if (this.elem_cache.containsKey_za3rmp$(path)) {
                    return this.elem_cache.get_za3rmp$(path);
                  }
                  var typeName = this.datastore.get('type', path);
                  if (typeName != null) {
                    var tmp$0;
                    var elem = (tmp$0 = this.create(typeName)) != null ? tmp$0 : Kotlin.throwNPE();
                    this.elem_cache.put_wn2jw4$(path, elem);
                    elem.isResolved = false;
                    elem.setOriginPath(path);
                    this.monitor(elem);
                    return elem;
                  }
                  return null;
                },
                getTraces: function (origin) {
                  var sequence = new _.org.kevoree.modeling.api.trace.TraceSequence(this);
                  var traces = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), origin.path());
                  if (traces != null) {
                    sequence.populateFromString(traces);
                    return sequence;
                  }
                  return null;
                },
                loadInbounds: function (elem) {
                  var castedInBounds = elem;
                  var payload = this.datastore.get(_.org.kevoree.modeling.api.time.TimeSegment.object.RAW.name(), elem.path() + '#');
                  if (payload != null) {
                    castedInBounds.internal_inboundReferences = _.org.kevoree.modeling.api.time.blob.MetaHelper.unserialize(payload, this);
                  }
                },
                select: function (query) {
                  var localRoot = this.lookup('/');
                  if (localRoot != null && Kotlin.equals(query, '/')) {
                    var result = new Kotlin.ArrayList();
                    result.add_za3rmp$(localRoot);
                    return result;
                  }
                  if (localRoot != null) {
                    return localRoot.select(query);
                  }
                   else {
                    return new Kotlin.ArrayList();
                  }
                }
              }),
              MemoryDataStore: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.persistence.DataStore];
              }, function () {
                this.selector_38kq2e$ = new _.org.kevoree.modeling.api.persistence.EventDispatcher();
                this.maps = new Kotlin.PrimitiveHashMap();
              }, /** @lends _.org.kevoree.modeling.api.persistence.MemoryDataStore.prototype */ {
                commit: function () {
                },
                register: function (listener, from, to, path) {
                  this.selector_38kq2e$.register(listener, from, to, path);
                },
                unregister: function (listener) {
                  this.selector_38kq2e$.unregister(listener);
                },
                notify: function (event) {
                  this.selector_38kq2e$.dispatch(event);
                },
                getSegmentKeys: function (segment) {
                  if (this.maps.containsKey_za3rmp$(segment)) {
                    var tmp$0;
                    ((tmp$0 = this.maps.get_za3rmp$(segment)) != null ? tmp$0 : Kotlin.throwNPE()).keySet();
                  }
                  return new Kotlin.PrimitiveHashSet();
                },
                getSegments: function () {
                  return this.maps.keySet();
                },
                close: function () {
                  this.selector_38kq2e$.clear();
                  this.maps.clear();
                },
                getOrCreateSegment: function (segment) {
                  if (!this.maps.containsKey_za3rmp$(segment)) {
                    this.maps.put_wn2jw4$(segment, new Kotlin.PrimitiveHashMap());
                  }
                  var tmp$0;
                  return (tmp$0 = this.maps.get_za3rmp$(segment)) != null ? tmp$0 : Kotlin.throwNPE();
                },
                put: function (segment, key, value) {
                  this.getOrCreateSegment(segment).put_wn2jw4$(key, value);
                },
                get: function (segment, key) {
                  return this.getOrCreateSegment(segment).get_za3rmp$(key);
                },
                remove: function (segment, key) {
                  this.getOrCreateSegment(segment).remove_za3rmp$(key);
                },
                dump: function () {
                  {
                    var tmp$0 = _.kotlin.iterator_s8ckw1$(this.maps);
                    while (tmp$0.hasNext()) {
                      var k = tmp$0.next();
                      Kotlin.println('Map ' + _.kotlin.get_key(k));
                      {
                        var tmp$1 = _.kotlin.iterator_s8ckw1$(_.kotlin.get_value(k));
                        while (tmp$1.hasNext()) {
                          var t = tmp$1.next();
                          Kotlin.println(_.kotlin.get_key(t) + '->' + _.kotlin.get_value(t));
                        }
                      }
                    }
                  }
                }
              }),
              EventDispatcher: Kotlin.createClass(null, function () {
                this.listeners_3hhuzx$ = new Kotlin.ComplexHashMap();
              }, /** @lends _.org.kevoree.modeling.api.persistence.EventDispatcher.prototype */ {
                register: function (listener, from, to, pathRegex) {
                  this.listeners_3hhuzx$.put_wn2jw4$(listener, new _.org.kevoree.modeling.api.persistence.TimedRegistration(from, to, pathRegex));
                },
                unregister: function (listener) {
                  this.listeners_3hhuzx$.remove_za3rmp$(listener);
                },
                dispatch: function (event) {
                  {
                    var tmp$0 = _.kotlin.iterator_s8ckw1$(this.listeners_3hhuzx$);
                    while (tmp$0.hasNext()) {
                      var l = tmp$0.next();
                      if (_.kotlin.get_value(l).covered(event)) {
                        _.kotlin.get_key(l).elementChanged(event);
                      }
                    }
                  }
                },
                clear: function () {
                  this.listeners_3hhuzx$.clear();
                }
              }),
              TimedRegistration: Kotlin.createClass(null, function (from, to, pathRegex) {
                this.from = from;
                this.to = to;
                this.pathRegex = pathRegex;
              }, /** @lends _.org.kevoree.modeling.api.persistence.TimedRegistration.prototype */ {
                covered: function (event) {
                  if (Kotlin.isType(event.source, _.org.kevoree.modeling.api.time.TimeAwareKMFContainer)) {
                    if (this.from != null) {
                      if (this.from < event.source.now) {
                        return false;
                      }
                    }
                    if (this.to != null) {
                      if (this.to < event.source.now) {
                        return false;
                      }
                    }
                  }
                  if (event.source != null) {
                    if (this.pathRegex.contains('*')) {
                      var regexPath = this.pathRegex.replace('*', '.*');
                      return _.js.matches_94jgcu$(event.source.path(), regexPath);
                    }
                     else {
                      return Kotlin.equals(event.source.path(), this.pathRegex);
                    }
                  }
                   else {
                    return false;
                  }
                },
                component1: function () {
                  return this.from;
                },
                component2: function () {
                  return this.to;
                },
                component3: function () {
                  return this.pathRegex;
                },
                copy: function (from, to, pathRegex) {
                  return new _.org.kevoree.modeling.api.persistence.TimedRegistration(from === void 0 ? this.from : from, to === void 0 ? this.to : to, pathRegex === void 0 ? this.pathRegex : pathRegex);
                },
                toString: function () {
                  return 'TimedRegistration(from=' + Kotlin.toString(this.from) + (', to=' + Kotlin.toString(this.to)) + (', pathRegex=' + Kotlin.toString(this.pathRegex)) + ')';
                },
                hashCode: function () {
                  var result = -551475360;
                  result = result * 31 + Kotlin.hashCode(this.from) | 0;
                  result = result * 31 + Kotlin.hashCode(this.to) | 0;
                  result = result * 31 + Kotlin.hashCode(this.pathRegex) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.from, other.from) && Kotlin.equals(this.to, other.to) && Kotlin.equals(this.pathRegex, other.pathRegex))));
                }
              }),
              DataStore: Kotlin.createTrait(null),
              KMFContainerProxy: Kotlin.createTrait(function () {
                return [_.org.kevoree.modeling.api.KMFContainer];
              }, /** @lends _.org.kevoree.modeling.api.persistence.KMFContainerProxy.prototype */ {
                isResolved: {
                  get: function () {
                    return this.$isResolved_q9gcci$;
                  },
                  set: function (tmp$0) {
                    this.$isResolved_q9gcci$ = tmp$0;
                  }
                },
                inResolution: {
                  get: function () {
                    return this.$inResolution_fvhr0z$;
                  },
                  set: function (tmp$0) {
                    this.$inResolution_fvhr0z$ = tmp$0;
                  }
                },
                isDirty: {
                  get: function () {
                    return this.$isDirty_z1d6gk$;
                  },
                  set: function (tmp$0) {
                    this.$isDirty_z1d6gk$ = tmp$0;
                  }
                },
                originFactory: {
                  get: function () {
                    return this.$originFactory_8fzws8$;
                  },
                  set: function (tmp$0) {
                    this.$originFactory_8fzws8$ = tmp$0;
                  }
                },
                relativeLookupFrom: function (base, relationInParent, key) {
                  var currentPath = base.path();
                  if (Kotlin.equals(currentPath, '/')) {
                    var tmp$0;
                    return (tmp$0 = this.originFactory) != null ? tmp$0.lookup('/' + relationInParent + '[' + key + ']') : null;
                  }
                   else {
                    var tmp$1;
                    return (tmp$1 = this.originFactory) != null ? tmp$1.lookup(currentPath + '/' + relationInParent + '[' + key + ']') : null;
                  }
                }
              }),
              AbstractDataStore: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.persistence.DataStore];
              }, function () {
                this.selector_6kse09$ = new _.org.kevoree.modeling.api.persistence.EventDispatcher();
              }, /** @lends _.org.kevoree.modeling.api.persistence.AbstractDataStore.prototype */ {
                register: function (listener, from, to, path) {
                  this.selector_6kse09$.register(listener, from, to, path);
                },
                unregister: function (listener) {
                  this.selector_6kse09$.unregister(listener);
                },
                notify: function (event) {
                  this.selector_6kse09$.dispatch(event);
                }
              })
            }),
            json: Kotlin.definePackage(function () {
              this.JSONString = Kotlin.createObject(null, function () {
                this.escapeChar_iwx5i$ = '\\';
              }, {
                encodeBuffer: function (buffer, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  while (i < chain.length) {
                    var ch = chain.charAt(i);
                    if (ch === '"') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('"');
                    }
                     else if (ch === this.escapeChar_iwx5i$) {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append(this.escapeChar_iwx5i$);
                    }
                     else if (ch === '\n') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('n');
                    }
                     else if (ch === '\r') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('r');
                    }
                     else if (ch === '\t') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('t');
                    }
                     else if (ch === '\u2028') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('u');
                      buffer.append('2');
                      buffer.append('0');
                      buffer.append('2');
                      buffer.append('8');
                    }
                     else if (ch === '\u2029') {
                      buffer.append(this.escapeChar_iwx5i$);
                      buffer.append('u');
                      buffer.append('2');
                      buffer.append('0');
                      buffer.append('2');
                      buffer.append('9');
                    }
                     else {
                      buffer.append(ch);
                    }
                    i = i + 1;
                  }
                },
                encode: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  while (i < chain.length) {
                    var ch = chain.charAt(i);
                    if (ch === '"') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('"');
                    }
                     else if (ch === this.escapeChar_iwx5i$) {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1(this.escapeChar_iwx5i$);
                    }
                     else if (ch === '\n') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('n');
                    }
                     else if (ch === '\r') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('r');
                    }
                     else if (ch === '\t') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('t');
                    }
                     else if (ch === '\u2028') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('u');
                      ostream.print_1('2');
                      ostream.print_1('0');
                      ostream.print_1('2');
                      ostream.print_1('8');
                    }
                     else if (ch === '\u2029') {
                      ostream.print_1(this.escapeChar_iwx5i$);
                      ostream.print_1('u');
                      ostream.print_1('2');
                      ostream.print_1('0');
                      ostream.print_1('2');
                      ostream.print_1('9');
                    }
                     else {
                      ostream.print_1(ch);
                    }
                    i = i + 1;
                  }
                },
                unescape: function (src) {
                  if (src == null) {
                    return null;
                  }
                  if (src.length === 0) {
                    return src;
                  }
                  var builder = null;
                  var i = 0;
                  while (i < src.length) {
                    var current = src.charAt(i);
                    if (current === this.escapeChar_iwx5i$) {
                      if (builder == null) {
                        builder = new Kotlin.StringBuilder();
                        builder != null ? builder.append(src.substring(0, i)) : null;
                      }
                      i++;
                      var current2 = src.charAt(i);
                      {
                        if (current2 === '"') {
                          builder != null ? builder.append('"') : null;
                        }
                         else if (current2 === '\\') {
                          builder != null ? builder.append(current2) : null;
                        }
                         else if (current2 === '/') {
                          builder != null ? builder.append(current2) : null;
                        }
                         else if (current2 === 'b') {
                          builder != null ? builder.append('\b') : null;
                        }
                         else if (current2 === 'f') {
                          builder != null ? builder.append((12).toChar()) : null;
                        }
                         else if (current2 === 'n') {
                          builder != null ? builder.append('\n') : null;
                        }
                         else if (current2 === 'r') {
                          builder != null ? builder.append('\r') : null;
                        }
                         else if (current2 === 't') {
                          builder != null ? builder.append('\t') : null;
                        }
                         else if (current2 === 'u') {
                          throw new Error('Bad char to escape ');
                        }
                      }
                    }
                     else {
                      if (builder != null) {
                        builder = builder != null ? builder.append(current) : null;
                      }
                    }
                    i++;
                  }
                  if (builder != null) {
                    return (builder != null ? builder : Kotlin.throwNPE()).toString();
                  }
                   else {
                    return src;
                  }
                }
              });
              this.Type = Kotlin.createObject(null, function () {
                this.VALUE = 0;
                this.LEFT_BRACE = 1;
                this.RIGHT_BRACE = 2;
                this.LEFT_BRACKET = 3;
                this.RIGHT_BRACKET = 4;
                this.COMMA = 5;
                this.COLON = 6;
                this.EOF = 42;
              });
            }, /** @lends _.org.kevoree.modeling.api.json */ {
              JSONModelLoader: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelLoader];
              }, function (factory) {
                this.factory = factory;
              }, /** @lends _.org.kevoree.modeling.api.json.JSONModelLoader.prototype */ {
                loadModelFromString: function (str) {
                  return this.deserialize(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
                },
                loadModelFromStream: function (inputStream) {
                  return this.deserialize(inputStream);
                },
                deserialize: function (instream) {
                  if (instream == null) {
                    throw new Error('Null input Stream');
                  }
                  var resolverCommands = new Kotlin.ArrayList();
                  var roots = new Kotlin.ArrayList();
                  var lexer = new _.org.kevoree.modeling.api.json.Lexer(instream);
                  var currentToken = lexer.nextToken();
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                    this.loadObject(lexer, null, null, roots, resolverCommands);
                  }
                   else {
                    throw new Error('Bad Format / {\xA0expected');
                  }
                  {
                    var tmp$0 = resolverCommands.iterator();
                    while (tmp$0.hasNext()) {
                      var resol = tmp$0.next();
                      resol.run();
                    }
                  }
                  return roots;
                },
                loadObject: function (lexer, nameInParent, parent, roots, commands) {
                  var currentToken = lexer.nextToken();
                  var currentObject = null;
                  if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                    if (Kotlin.equals(currentToken.value, 'class')) {
                      lexer.nextToken();
                      currentToken = lexer.nextToken();
                      var tmp$0, tmp$1;
                      var name = (tmp$1 = (tmp$0 = currentToken.value) != null ? tmp$0.toString() : null) != null ? tmp$1 : Kotlin.throwNPE();
                      var typeName = null;
                      var isRoot = false;
                      if (name.startsWith('root:')) {
                        isRoot = true;
                        name = name.substring('root:'.length);
                      }
                      if (name.contains('@')) {
                        typeName = name.substring(0, name.indexOf('@'));
                        var key = name.substring(name.indexOf('@') + 1);
                        if (parent == null) {
                          if (isRoot) {
                            currentObject = this.factory.lookup('/');
                          }
                        }
                         else {
                          var path = parent.path() + '/' + nameInParent + '[' + key + ']';
                          currentObject = this.factory.lookup(path);
                        }
                      }
                       else {
                        typeName = name;
                      }
                      if (currentObject == null) {
                        currentObject = this.factory.create(typeName != null ? typeName : Kotlin.throwNPE());
                      }
                      if (isRoot) {
                        this.factory.root(currentObject != null ? currentObject : Kotlin.throwNPE());
                      }
                      if (parent == null) {
                        roots.add_za3rmp$(currentObject != null ? currentObject : Kotlin.throwNPE());
                      }
                      var currentNameAttOrRef = null;
                      var refModel = false;
                      currentToken = lexer.nextToken();
                      while (currentToken.tokenType !== _.org.kevoree.modeling.api.json.Type.EOF) {
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                          this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.COMMA) {
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                          if (currentNameAttOrRef == null) {
                            currentNameAttOrRef = Kotlin.toString(currentToken.value);
                          }
                           else {
                            if (refModel) {
                              var tmp$2;
                              commands.add_za3rmp$(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, ((tmp$2 = currentToken.value) != null ? tmp$2 : Kotlin.throwNPE()).toString(), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                            }
                             else {
                              var unscaped = _.org.kevoree.modeling.api.json.JSONString.unescape(Kotlin.toString(currentToken.value));
                              (currentObject != null ? currentObject : Kotlin.throwNPE()).reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.SET, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), unscaped, false, false);
                              currentNameAttOrRef = null;
                            }
                          }
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET) {
                          currentToken = lexer.nextToken();
                          if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.LEFT_BRACE) {
                            this.loadObject(lexer, currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE(), currentObject, roots, commands);
                          }
                           else {
                            refModel = true;
                            if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.VALUE) {
                              var tmp$3;
                              commands.add_za3rmp$(new _.org.kevoree.modeling.api.json.ResolveCommand(roots, ((tmp$3 = currentToken.value) != null ? tmp$3 : Kotlin.throwNPE()).toString(), currentObject != null ? currentObject : Kotlin.throwNPE(), currentNameAttOrRef != null ? currentNameAttOrRef : Kotlin.throwNPE()));
                            }
                          }
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET) {
                          currentNameAttOrRef = null;
                          refModel = false;
                        }
                        if (currentToken.tokenType === _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE) {
                          if (parent != null) {
                            parent.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, nameInParent != null ? nameInParent : Kotlin.throwNPE(), currentObject, false, false);
                          }
                          return;
                        }
                        currentToken = lexer.nextToken();
                      }
                    }
                     else {
                      throw new Error('Bad Format / eClass att must be first');
                    }
                  }
                   else {
                    throw new Error('Bad Format');
                  }
                }
              }),
              ResolveCommand: Kotlin.createClass(null, function (roots, ref, currentRootElem, refName) {
                this.roots = roots;
                this.ref = ref;
                this.currentRootElem = currentRootElem;
                this.refName = refName;
              }, /** @lends _.org.kevoree.modeling.api.json.ResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = null;
                  var i = 0;
                  while (referencedElement == null && i < this.roots.size()) {
                    referencedElement = this.roots.get_za3lpa$(i++).findByPath(this.ref);
                  }
                  if (referencedElement != null) {
                    this.currentRootElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, this.refName, referencedElement, false, false);
                  }
                   else {
                    throw new Error('Unresolved ' + this.ref);
                  }
                }
              }),
              Token: Kotlin.createClass(null, function (tokenType, value) {
                this.tokenType = tokenType;
                this.value = value;
              }, /** @lends _.org.kevoree.modeling.api.json.Token.prototype */ {
                toString: function () {
                  var tmp$0;
                  if (this.value != null) {
                    tmp$0 = ' (' + this.value + ')';
                  }
                   else {
                    tmp$0 = '';
                  }
                  var v = tmp$0;
                  var result = this.tokenType.toString() + v;
                  return result;
                }
              }),
              Lexer: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes = this.inputStream.readBytes();
                this.EOF = new _.org.kevoree.modeling.api.json.Token(_.org.kevoree.modeling.api.json.Type.EOF, null);
                this.index = 0;
                this.BOOLEAN_LETTERS = null;
                this.DIGIT = null;
              }, /** @lends _.org.kevoree.modeling.api.json.Lexer.prototype */ {
                isSpace: function (c) {
                  return c === ' ' || c === '\r' || c === '\n' || c === '\t';
                },
                nextChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index++]);
                },
                peekChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes[this.index]);
                },
                isDone: function () {
                  return this.index >= this.bytes.length;
                },
                isBooleanLetter: function (c) {
                  if (this.BOOLEAN_LETTERS == null) {
                    this.BOOLEAN_LETTERS = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7;
                    ((tmp$0 = this.BOOLEAN_LETTERS) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$('f');
                    ((tmp$1 = this.BOOLEAN_LETTERS) != null ? tmp$1 : Kotlin.throwNPE()).add_za3rmp$('a');
                    ((tmp$2 = this.BOOLEAN_LETTERS) != null ? tmp$2 : Kotlin.throwNPE()).add_za3rmp$('l');
                    ((tmp$3 = this.BOOLEAN_LETTERS) != null ? tmp$3 : Kotlin.throwNPE()).add_za3rmp$('s');
                    ((tmp$4 = this.BOOLEAN_LETTERS) != null ? tmp$4 : Kotlin.throwNPE()).add_za3rmp$('e');
                    ((tmp$5 = this.BOOLEAN_LETTERS) != null ? tmp$5 : Kotlin.throwNPE()).add_za3rmp$('t');
                    ((tmp$6 = this.BOOLEAN_LETTERS) != null ? tmp$6 : Kotlin.throwNPE()).add_za3rmp$('r');
                    ((tmp$7 = this.BOOLEAN_LETTERS) != null ? tmp$7 : Kotlin.throwNPE()).add_za3rmp$('u');
                  }
                  var tmp$8;
                  return ((tmp$8 = this.BOOLEAN_LETTERS) != null ? tmp$8 : Kotlin.throwNPE()).contains_za3rmp$(c);
                },
                isDigit: function (c) {
                  if (this.DIGIT == null) {
                    this.DIGIT = new Kotlin.PrimitiveHashSet();
                    var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4, tmp$5, tmp$6, tmp$7, tmp$8, tmp$9;
                    ((tmp$0 = this.DIGIT) != null ? tmp$0 : Kotlin.throwNPE()).add_za3rmp$('0');
                    ((tmp$1 = this.DIGIT) != null ? tmp$1 : Kotlin.throwNPE()).add_za3rmp$('1');
                    ((tmp$2 = this.DIGIT) != null ? tmp$2 : Kotlin.throwNPE()).add_za3rmp$('2');
                    ((tmp$3 = this.DIGIT) != null ? tmp$3 : Kotlin.throwNPE()).add_za3rmp$('3');
                    ((tmp$4 = this.DIGIT) != null ? tmp$4 : Kotlin.throwNPE()).add_za3rmp$('4');
                    ((tmp$5 = this.DIGIT) != null ? tmp$5 : Kotlin.throwNPE()).add_za3rmp$('5');
                    ((tmp$6 = this.DIGIT) != null ? tmp$6 : Kotlin.throwNPE()).add_za3rmp$('6');
                    ((tmp$7 = this.DIGIT) != null ? tmp$7 : Kotlin.throwNPE()).add_za3rmp$('7');
                    ((tmp$8 = this.DIGIT) != null ? tmp$8 : Kotlin.throwNPE()).add_za3rmp$('8');
                    ((tmp$9 = this.DIGIT) != null ? tmp$9 : Kotlin.throwNPE()).add_za3rmp$('9');
                  }
                  var tmp$10;
                  return ((tmp$10 = this.DIGIT) != null ? tmp$10 : Kotlin.throwNPE()).contains_za3rmp$(c);
                },
                isValueLetter: function (c) {
                  return c === '-' || c === '+' || c === '.' || this.isDigit(c) || this.isBooleanLetter(c);
                },
                nextToken: function () {
                  if (this.isDone()) {
                    return this.EOF;
                  }
                  var tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  var c = this.nextChar();
                  var currentValue = new Kotlin.StringBuilder();
                  var jsonValue = null;
                  while (!this.isDone() && this.isSpace(c)) {
                    c = this.nextChar();
                  }
                  if ('"' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                    if (!this.isDone()) {
                      c = this.nextChar();
                      while (this.index < this.bytes.length && c !== '"') {
                        currentValue.append(c);
                        if (c === '\\' && this.index < this.bytes.length) {
                          c = this.nextChar();
                          currentValue.append(c);
                        }
                        c = this.nextChar();
                      }
                      jsonValue = currentValue.toString();
                    }
                     else {
                      throw new Kotlin.RuntimeException('Unterminated string');
                    }
                  }
                   else if ('{' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACE;
                  }
                   else if ('}' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACE;
                  }
                   else if ('[' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.LEFT_BRACKET;
                  }
                   else if (']' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.RIGHT_BRACKET;
                  }
                   else if (':' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COLON;
                  }
                   else if (',' === c) {
                    tokenType = _.org.kevoree.modeling.api.json.Type.COMMA;
                  }
                   else if (!this.isDone()) {
                    while (this.isValueLetter(c)) {
                      currentValue.append(c);
                      if (!this.isValueLetter(this.peekChar())) {
                        break;
                      }
                       else {
                        c = this.nextChar();
                      }
                    }
                    var v = currentValue.toString();
                    if (Kotlin.equals('true', v.toLowerCase())) {
                      jsonValue = true;
                    }
                     else if (Kotlin.equals('false', v.toLowerCase())) {
                      jsonValue = false;
                    }
                     else {
                      jsonValue = v.toLowerCase();
                    }
                    tokenType = _.org.kevoree.modeling.api.json.Type.VALUE;
                  }
                   else {
                    tokenType = _.org.kevoree.modeling.api.json.Type.EOF;
                  }
                  return new _.org.kevoree.modeling.api.json.Token(tokenType, jsonValue);
                }
              }),
              ModelReferenceVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(out) {
                $fun.baseInitializer.call(this);
                this.out = out;
                this.isFirst = true;
              }, /** @lends _.org.kevoree.modeling.api.json.ModelReferenceVisitor.prototype */ {
                beginVisitRef: function (refName, refType) {
                  this.out.print_4(',"' + refName + '":[');
                  this.isFirst = true;
                  return true;
                },
                endVisitRef: function (refName) {
                  this.out.print_4(']');
                },
                visit: function (elem, refNameInParent, parent) {
                  if (!this.isFirst) {
                    this.out.print_4(',');
                  }
                   else {
                    this.isFirst = false;
                  }
                  this.out.print_4('"' + elem.path() + '"');
                }
              }),
              JSONModelSerializer: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelSerializer];
              }, null, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer.prototype */ {
                serialize: function (model) {
                  var outstream = new _.java.io.ByteArrayOutputStream();
                  this.serializeToStream(model, outstream);
                  outstream.close();
                  return outstream.toString();
                },
                serializeToStream: function (model, raw) {
                  var out = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(raw), false);
                  var internalReferenceVisitor = new _.org.kevoree.modeling.api.json.ModelReferenceVisitor(out);
                  var masterVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.serializeToStream$f(out, this, internalReferenceVisitor);
                  model.visit(masterVisitor, true, true, false);
                  out.flush();
                },
                printAttName: function (elem, out) {
                  var isRoot = '';
                  if (Kotlin.equals(elem.path(), '/')) {
                    isRoot = 'root:';
                  }
                  out.print_4('\n{"class":"' + isRoot + elem.metaClassName() + '@' + elem.internalGetKey() + '"');
                  var attributeVisitor = _.org.kevoree.modeling.api.json.JSONModelSerializer.printAttName$f(out);
                  elem.visitAttributes(attributeVisitor);
                }
              }, /** @lends _.org.kevoree.modeling.api.json.JSONModelSerializer */ {
                serializeToStream$f: function (out, this$JSONModelSerializer, internalReferenceVisitor) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                    this.isFirstInRef = true;
                  }, {
                    beginVisitElem: function (elem) {
                      if (!this.isFirstInRef) {
                        out.print_4(',');
                        this.isFirstInRef = false;
                      }
                      this$JSONModelSerializer.printAttName(elem, out);
                      var tmp$0;
                      (tmp$0 = internalReferenceVisitor.alreadyVisited) != null ? tmp$0.clear() : null;
                      elem.visit(internalReferenceVisitor, false, false, true);
                    },
                    endVisitElem: function (elem) {
                      out.println_2('}');
                      this.isFirstInRef = false;
                    },
                    beginVisitRef: function (refName, refType) {
                      out.print_4(',"' + refName + '":[');
                      this.isFirstInRef = true;
                      return true;
                    },
                    endVisitRef: function (refName) {
                      out.print_4(']');
                      this.isFirstInRef = false;
                    },
                    visit: function (elem, refNameInParent, parent) {
                    }
                  });
                },
                printAttName$f: function (out) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                  }, null, {
                    visit: function (value, name, parent) {
                      if (value != null) {
                        out.print_4(',"' + name + '":"');
                        if (Kotlin.isType(value, Date)) {
                          _.org.kevoree.modeling.api.json.JSONString.encode(out, '' + value.getTime());
                        }
                         else {
                          _.org.kevoree.modeling.api.json.JSONString.encode(out, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
                        }
                        out.print_4('"');
                      }
                    }
                  });
                }
              })
            }),
            xmi: Kotlin.definePackage(function () {
              this.Token = Kotlin.createObject(null, function () {
                this.XML_HEADER = 0;
                this.END_DOCUMENT = 1;
                this.START_TAG = 2;
                this.END_TAG = 3;
                this.COMMENT = 4;
                this.SINGLETON_TAG = 5;
              });
            }, /** @lends _.org.kevoree.modeling.api.xmi */ {
              ReferencesVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(ostream, addressTable, elementsCount, resourceSet) {
                $fun.baseInitializer.call(this);
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.resourceSet = resourceSet;
                this.value = null;
              }, /** @lends _.org.kevoree.modeling.api.xmi.ReferencesVisitor.prototype */ {
                endVisitRef: function (refName) {
                  if (this.value != null) {
                    this.ostream.print_4(' ' + refName + '="' + Kotlin.toString(this.value) + '"');
                    this.value = null;
                  }
                },
                visit: function (elem, refNameInParent, parent) {
                  var tmp$0;
                  var adjustedAddress = (tmp$0 = this.resourceSet) != null ? tmp$0.objToAddr(elem) : null;
                  if (adjustedAddress == null) {
                    adjustedAddress = this.addressTable.get_za3rmp$(elem);
                  }
                  if (this.value == null) {
                    this.value = adjustedAddress;
                  }
                   else {
                    var tmp$1, tmp$2;
                    this.value = ((tmp$1 = this.value) != null ? tmp$1 : Kotlin.throwNPE()) + ' ';
                    this.value = ((tmp$2 = this.value) != null ? tmp$2 : Kotlin.throwNPE()) + Kotlin.toString(adjustedAddress);
                  }
                }
              }),
              AttributesVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
              }, function (ostream, ignoreGeneratedID) {
                this.ostream = ostream;
                this.ignoreGeneratedID = ignoreGeneratedID;
              }, /** @lends _.org.kevoree.modeling.api.xmi.AttributesVisitor.prototype */ {
                visit: function (value, name, parent) {
                  if (value != null) {
                    if (this.ignoreGeneratedID && Kotlin.equals(name, 'generated_KMF_ID')) {
                      return;
                    }
                    if (typeof value === 'string' && Kotlin.equals(value, '')) {
                      return;
                    }
                    this.ostream.print_4(' ' + name + '="');
                    if (Kotlin.isType(value, Date)) {
                      this.escapeXml(this.ostream, '' + value.getTime());
                    }
                     else {
                      this.escapeXml(this.ostream, _.org.kevoree.modeling.api.util.AttConverter.convFlatAtt(value));
                    }
                    this.ostream.print_4('"');
                  }
                },
                escapeXml: function (ostream, chain) {
                  if (chain == null) {
                    return;
                  }
                  var i = 0;
                  var max = chain.length;
                  while (i < max) {
                    var c = chain.charAt(i);
                    if (c === '"') {
                      ostream.print_4('&quot;');
                    }
                     else if (c === '&') {
                      ostream.print_4('&amp;');
                    }
                     else if (c === "'") {
                      ostream.print_4('&apos;');
                    }
                     else if (c === '<') {
                      ostream.print_4('&lt;');
                    }
                     else if (c === '>') {
                      ostream.print_4('&gt;');
                    }
                     else {
                      ostream.print_1(c);
                    }
                    i = i + 1;
                  }
                }
              }),
              ModelSerializationVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(ostream, addressTable, elementsCount, resourceSet, ignoreGeneratedID) {
                $fun.baseInitializer.call(this);
                this.ostream = ostream;
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.resourceSet = resourceSet;
                this.attributeVisitor = new _.org.kevoree.modeling.api.xmi.AttributesVisitor(this.ostream, ignoreGeneratedID);
                this.referenceVisitor = new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(this.ostream, this.addressTable, this.elementsCount, this.resourceSet);
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor.prototype */ {
                visit: function (elem, refNameInParent, parent) {
                  this.ostream.print_1('<');
                  this.ostream.print_4(refNameInParent);
                  this.ostream.print_4(' xsi:type="' + this.formatMetaClassName(elem.metaClassName()) + '"');
                  elem.visitAttributes(this.attributeVisitor);
                  elem.visit(this.referenceVisitor, false, false, true);
                  this.ostream.println_1('>');
                  elem.visit(this, false, true, false);
                  this.ostream.print_4('<\/');
                  this.ostream.print_4(refNameInParent);
                  this.ostream.print_1('>');
                  this.ostream.println();
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_960177$(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              ModelAddressVisitor: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.util.ModelVisitor];
              }, function $fun(addressTable, elementsCount, packageList) {
                $fun.baseInitializer.call(this);
                this.addressTable = addressTable;
                this.elementsCount = elementsCount;
                this.packageList = packageList;
              }, /** @lends _.org.kevoree.modeling.api.xmi.ModelAddressVisitor.prototype */ {
                visit: function (elem, refNameInParent, parent) {
                  var tmp$0, tmp$1;
                  var parentXmiAddress = (tmp$0 = this.addressTable.get_za3rmp$(parent)) != null ? tmp$0 : Kotlin.throwNPE();
                  var i = (tmp$1 = this.elementsCount.get_za3rmp$(parentXmiAddress + '/@' + refNameInParent)) != null ? tmp$1 : 0;
                  this.addressTable.put_wn2jw4$(elem, parentXmiAddress + '/@' + refNameInParent + '.' + i);
                  this.elementsCount.put_wn2jw4$(parentXmiAddress + '/@' + refNameInParent, i + 1);
                  var pack = elem.metaClassName().substring(0, _.js.lastIndexOf_960177$(elem.metaClassName(), '.'));
                  if (!this.packageList.contains_za3rmp$(pack))
                    this.packageList.add_za3rmp$(pack);
                }
              }),
              XMIModelSerializer: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelSerializer];
              }, function () {
                this.resourceSet = null;
                this.ignoreGeneratedID = false;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelSerializer.prototype */ {
                serialize: function (oMS) {
                  var oo = new _.java.io.ByteArrayOutputStream();
                  this.serializeToStream(oMS, oo);
                  oo.flush();
                  return oo.toString();
                },
                serializeToStream: function (oMS, ostream) {
                  var wt = new _.java.io.PrintStream(new _.java.io.BufferedOutputStream(ostream), false);
                  var addressTable = new Kotlin.ComplexHashMap();
                  var packageList = new Kotlin.ArrayList();
                  addressTable.put_wn2jw4$(oMS, '/');
                  var elementsCount = new Kotlin.PrimitiveHashMap();
                  var addressBuilderVisitor = new _.org.kevoree.modeling.api.xmi.ModelAddressVisitor(addressTable, elementsCount, packageList);
                  oMS.visit(addressBuilderVisitor, true, true, false);
                  var masterVisitor = new _.org.kevoree.modeling.api.xmi.ModelSerializationVisitor(wt, addressTable, elementsCount, this.resourceSet, this.ignoreGeneratedID);
                  wt.println_2('<?xml version="1.0" encoding="UTF-8"?>');
                  wt.print_4('<' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_'));
                  wt.print_4(' xmlns:xsi="http://wwww.w3.org/2001/XMLSchema-instance"');
                  wt.print_4(' xmi:version="2.0"');
                  wt.print_4(' xmlns:xmi="http://www.omg.org/XMI"');
                  var index = 0;
                  while (index < _.kotlin.get_size_1(packageList)) {
                    wt.print_4(' xmlns:' + packageList.get_za3lpa$(index).replace('.', '_') + '="http://' + packageList.get_za3lpa$(index) + '"');
                    index++;
                  }
                  oMS.visitAttributes(new _.org.kevoree.modeling.api.xmi.AttributesVisitor(wt, this.ignoreGeneratedID));
                  oMS.visit(new _.org.kevoree.modeling.api.xmi.ReferencesVisitor(wt, addressTable, elementsCount, this.resourceSet), false, false, true);
                  wt.println_2('>');
                  oMS.visit(masterVisitor, false, true, false);
                  wt.println_2('<\/' + this.formatMetaClassName(oMS.metaClassName()).replace('.', '_') + '>');
                  wt.flush();
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_960177$(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              ResourceSet: Kotlin.createClass(null, function () {
                this.resources_twji9r$ = new Kotlin.PrimitiveHashMap();
                this.invertedResources_583d58$ = new Kotlin.ComplexHashMap();
              }, /** @lends _.org.kevoree.modeling.api.xmi.ResourceSet.prototype */ {
                registerXmiAddrMappedObjects: function (nsuri, xmiAddrs) {
                  this.resources_twji9r$.put_wn2jw4$(nsuri, xmiAddrs);
                  {
                    var tmp$0 = _.kotlin.iterator_s8ckw1$(xmiAddrs);
                    while (tmp$0.hasNext()) {
                      var ad = tmp$0.next();
                      if (this.invertedResources_583d58$.containsKey_za3rmp$(_.kotlin.get_value(ad))) {
                        var alreadyVal = this.invertedResources_583d58$.get_za3rmp$(_.kotlin.get_value(ad));
                        if ((alreadyVal != null ? alreadyVal : Kotlin.throwNPE()).addr.contains('@')) {
                          this.invertedResources_583d58$.put_wn2jw4$(_.kotlin.get_value(ad), new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri, _.kotlin.get_key(ad)));
                        }
                      }
                       else {
                        this.invertedResources_583d58$.put_wn2jw4$(_.kotlin.get_value(ad), new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri, _.kotlin.get_key(ad)));
                      }
                    }
                  }
                },
                resolveObject: function (xmiAddr) {
                  var typeAndAddr = Kotlin.splitString(xmiAddr, ' ');
                  if (typeAndAddr.length > 1) {
                    var addrs = Kotlin.splitString(typeAndAddr[1], '#');
                    if (addrs.length === 2) {
                      var resolvedAddrs = this.resources_twji9r$.get_za3rmp$(addrs[0]);
                      var addr = addrs[1];
                      addr = '#' + addr;
                      addr = addr.replace('#//', '/0/');
                      return resolvedAddrs != null ? resolvedAddrs.get_za3rmp$(addr) : null;
                    }
                  }
                  return null;
                },
                objToAddr: function (obj) {
                  var resolved = this.invertedResources_583d58$.get_za3rmp$(obj);
                  if (resolved != null) {
                    var packName = this.formatMetaClassName(obj.metaClassName());
                    var nsURI = resolved.nsuri;
                    var addr = resolved.addr;
                    addr = addr.replace('/0/', '#//');
                    return packName + ' ' + nsURI + addr;
                  }
                  return null;
                },
                formatMetaClassName: function (metaClassName) {
                  var lastPoint = _.js.lastIndexOf_960177$(metaClassName, '.');
                  var pack = metaClassName.substring(0, lastPoint);
                  var cls = metaClassName.substring(lastPoint + 1);
                  return pack + ':' + cls;
                }
              }),
              XmiObjAddr: Kotlin.createClass(null, function (nsuri, addr) {
                this.nsuri = nsuri;
                this.addr = addr;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmiObjAddr.prototype */ {
                component1: function () {
                  return this.nsuri;
                },
                component2: function () {
                  return this.addr;
                },
                copy: function (nsuri, addr) {
                  return new _.org.kevoree.modeling.api.xmi.XmiObjAddr(nsuri === void 0 ? this.nsuri : nsuri, addr === void 0 ? this.addr : addr);
                },
                toString: function () {
                  return 'XmiObjAddr(nsuri=' + Kotlin.toString(this.nsuri) + (', addr=' + Kotlin.toString(this.addr)) + ')';
                },
                hashCode: function () {
                  var result = 977237871;
                  result = result * 31 + Kotlin.hashCode(this.nsuri) | 0;
                  result = result * 31 + Kotlin.hashCode(this.addr) | 0;
                  return result;
                },
                equals_za3rmp$: function (other) {
                  return this === other || (other !== null && (Object.getPrototypeOf(this) === Object.getPrototypeOf(other) && (Kotlin.equals(this.nsuri, other.nsuri) && Kotlin.equals(this.addr, other.addr))));
                }
              }),
              XMIModelLoader: Kotlin.createClass(function () {
                return [_.org.kevoree.modeling.api.ModelLoader];
              }, function (factory) {
                this.factory = factory;
                this.resourceSet = null;
                this.LOADER_XMI_LOCAL_NAME = 'type';
                this.LOADER_XMI_XSI = 'xsi';
                this.LOADER_XMI_NS_URI = 'nsURI';
                this.attributesHashmap_7wijs5$ = new Kotlin.PrimitiveHashMap();
                this.referencesHashmap_cc1kom$ = new Kotlin.PrimitiveHashMap();
                this.namedElementSupportActivated_71goxr$ = false;
                this.attributeVisitor_g67dla$ = _.org.kevoree.modeling.api.xmi.XMIModelLoader.XMIModelLoader$f(this);
                this.referencesVisitor_g5fzti$ = _.org.kevoree.modeling.api.xmi.XMIModelLoader.XMIModelLoader$f_0(this);
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader.prototype */ {
                activateSupportForNamedElements: function (activate) {
                  this.namedElementSupportActivated_71goxr$ = activate;
                },
                unescapeXml: function (src) {
                  var builder = null;
                  var i = 0;
                  while (i < src.length) {
                    var c = src.charAt(i);
                    if (c === '&') {
                      if (builder == null) {
                        builder = new Kotlin.StringBuilder();
                        (builder != null ? builder : Kotlin.throwNPE()).append(src.substring(0, i));
                      }
                      if (src.charAt(i + 1) === 'a') {
                        if (src.charAt(i + 2) === 'm') {
                          builder != null ? builder.append('&') : null;
                          i = i + 5;
                        }
                         else if (src.charAt(i + 2) === 'p') {
                          builder != null ? builder.append("'") : null;
                          i = i + 6;
                        }
                         else {
                          Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1) + src.charAt(i + 2));
                        }
                      }
                       else if (src.charAt(i + 1) === 'q') {
                        builder != null ? builder.append('"') : null;
                        i = i + 6;
                      }
                       else if (src.charAt(i + 1) === 'l') {
                        builder != null ? builder.append('<') : null;
                        i = i + 4;
                      }
                       else if (src.charAt(i + 1) === 'g') {
                        builder != null ? builder.append('>') : null;
                        i = i + 4;
                      }
                       else {
                        Kotlin.println('Could not unescaped chain:' + src.charAt(i) + src.charAt(i + 1));
                      }
                    }
                     else {
                      if (builder != null) {
                        builder != null ? builder.append(c) : null;
                      }
                      i++;
                    }
                  }
                  if (builder != null) {
                    return Kotlin.toString(builder);
                  }
                   else {
                    return src;
                  }
                },
                loadModelFromString: function (str) {
                  var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(_.org.kevoree.modeling.api.util.ByteConverter.byteArrayInputStreamFromString(str));
                  if (reader.hasNext()) {
                    return this.deserialize(reader);
                  }
                   else {
                    Kotlin.println('Loader::Nothing in the String !');
                    return null;
                  }
                },
                loadModelFromStream: function (inputStream) {
                  var reader = new _.org.kevoree.modeling.api.xmi.XmlParser(inputStream);
                  if (reader.hasNext()) {
                    return this.deserialize(reader);
                  }
                   else {
                    Kotlin.println('Loader::Nothing in the file !');
                    return null;
                  }
                },
                loadObject: function (ctx, xmiAddress, objectType) {
                  if (objectType === void 0)
                    objectType = null;
                  var tmp$0, tmp$12, tmp$13, tmp$14, tmp$15, tmp$16, tmp$17, tmp$18;
                  var elementTagName = ((tmp$0 = ctx.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getLocalName();
                  var modelElem;
                  if (objectType != null) {
                    var tmp$1;
                    modelElem = (tmp$1 = this.factory) != null ? tmp$1.create(objectType) : null;
                    if (modelElem == null) {
                      var xsiType = null;
                      var tmp$2, tmp$3, tmp$4, tmp$5, tmp$6;
                      {
                        tmp$3 = new Kotlin.NumberRange(0, ((tmp$2 = ctx.xmiReader) != null ? tmp$2 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$4 = tmp$3.start, tmp$5 = tmp$3.end, tmp$6 = tmp$3.increment;
                        for (var i = tmp$4; i <= tmp$5; i += tmp$6) {
                          var tmp$7, tmp$8;
                          var localName = ((tmp$7 = ctx.xmiReader) != null ? tmp$7 : Kotlin.throwNPE()).getAttributeLocalName(i);
                          var xsi = ((tmp$8 = ctx.xmiReader) != null ? tmp$8 : Kotlin.throwNPE()).getAttributePrefix(i);
                          if (Kotlin.equals(localName, this.LOADER_XMI_LOCAL_NAME) && Kotlin.equals(xsi, this.LOADER_XMI_XSI)) {
                            var tmp$9;
                            xsiType = ((tmp$9 = ctx.xmiReader) != null ? tmp$9 : Kotlin.throwNPE()).getAttributeValue(i);
                            break;
                          }
                        }
                      }
                      if (xsiType != null) {
                        var realTypeName = xsiType != null ? xsiType.substring(0, (xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':')) : null;
                        var realName = (xsiType != null ? xsiType : Kotlin.throwNPE()).substring((xsiType != null ? xsiType : Kotlin.throwNPE()).lastIndexOf(':') + 1, (xsiType != null ? xsiType : Kotlin.throwNPE()).length);
                        var tmp$10;
                        modelElem = (tmp$10 = this.factory) != null ? tmp$10.create(_.kotlin.plus_n7iowf$(realTypeName, '.') + realName) : null;
                      }
                    }
                  }
                   else {
                    var tmp$11;
                    modelElem = (tmp$11 = this.factory) != null ? tmp$11.create(elementTagName) : null;
                  }
                  if (modelElem == null) {
                    Kotlin.println('Could not create an object for local name ' + elementTagName);
                  }
                  ctx.map.put_wn2jw4$(xmiAddress, modelElem != null ? modelElem : Kotlin.throwNPE());
                  if (!this.attributesHashmap_7wijs5$.containsKey_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
                    modelElem != null ? modelElem.visitAttributes(this.attributeVisitor_g67dla$) : null;
                  }
                  var elemAttributesMap = (tmp$12 = this.attributesHashmap_7wijs5$.get_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$12 : Kotlin.throwNPE();
                  if (!this.referencesHashmap_cc1kom$.containsKey_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) {
                    modelElem != null ? modelElem.visit(this.referencesVisitor_g5fzti$, false, true, false) : null;
                  }
                  var elemReferencesMap = (tmp$13 = this.referencesHashmap_cc1kom$.get_za3rmp$((modelElem != null ? modelElem : Kotlin.throwNPE()).metaClassName())) != null ? tmp$13 : Kotlin.throwNPE();
                  {
                    tmp$15 = new Kotlin.NumberRange(0, ((tmp$14 = ctx.xmiReader) != null ? tmp$14 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$16 = tmp$15.start, tmp$17 = tmp$15.end, tmp$18 = tmp$15.increment;
                    for (var i_0 = tmp$16; i_0 <= tmp$17; i_0 += tmp$18) {
                      var tmp$19;
                      var prefix = ((tmp$19 = ctx.xmiReader) != null ? tmp$19 : Kotlin.throwNPE()).getAttributePrefix(i_0);
                      if (prefix == null || Kotlin.equals(prefix, '')) {
                        var tmp$20, tmp$21;
                        var attrName = ((tmp$20 = ctx.xmiReader) != null ? tmp$20 : Kotlin.throwNPE()).getAttributeLocalName(i_0).trim();
                        var valueAtt = ((tmp$21 = ctx.xmiReader) != null ? tmp$21 : Kotlin.throwNPE()).getAttributeValue(i_0).trim();
                        if (valueAtt != null) {
                          if (elemAttributesMap.containsKey_za3rmp$(attrName)) {
                            modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, this.unescapeXml(valueAtt), false, false) : null;
                            if (this.namedElementSupportActivated_71goxr$ && Kotlin.equals(attrName, 'name')) {
                              var parent = ctx.map.get_za3rmp$(xmiAddress.substring(0, xmiAddress.lastIndexOf('/')));
                              {
                                var tmp$22 = _.kotlin.toList_h3panj$(ctx.map.entrySet()).iterator();
                                while (tmp$22.hasNext()) {
                                  var entry = tmp$22.next();
                                  if (Kotlin.equals(_.kotlin.get_value(entry), parent)) {
                                    var refT = _.kotlin.get_key(entry) + '/' + this.unescapeXml(valueAtt);
                                    ctx.map.put_wn2jw4$(refT, modelElem != null ? modelElem : Kotlin.throwNPE());
                                  }
                                }
                              }
                            }
                          }
                           else {
                            if (!valueAtt.startsWith('#') && !valueAtt.startsWith('/')) {
                              if (this.resourceSet != null) {
                                var tmp$23;
                                var previousLoadedRef = ((tmp$23 = this.resourceSet) != null ? tmp$23 : Kotlin.throwNPE()).resolveObject(valueAtt);
                                if (previousLoadedRef != null) {
                                  modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, previousLoadedRef, true, false) : null;
                                }
                                 else {
                                  throw new Error('Unresolve NsURI based XMI reference ' + valueAtt);
                                }
                              }
                               else {
                                throw new Error('Bad XMI reference ' + valueAtt);
                              }
                            }
                             else {
                              var tmp$24, tmp$25, tmp$26;
                              {
                                tmp$24 = Kotlin.splitString(valueAtt, ' '), tmp$25 = tmp$24.length;
                                for (var tmp$26 = 0; tmp$26 !== tmp$25; ++tmp$26) {
                                  var xmiRef = tmp$24[tmp$26];
                                  var tmp$27, tmp$28;
                                  if (xmiRef.startsWith('#')) {
                                    tmp$27 = xmiRef.substring(1);
                                  }
                                   else {
                                    tmp$27 = xmiRef;
                                  }
                                  var adjustedRef = tmp$27;
                                  if (adjustedRef.startsWith('//')) {
                                    tmp$28 = '/0' + adjustedRef.substring(1);
                                  }
                                   else {
                                    tmp$28 = adjustedRef;
                                  }
                                  adjustedRef = tmp$28;
                                  adjustedRef = adjustedRef.replace('.0', '');
                                  var ref = ctx.map.get_za3rmp$(adjustedRef);
                                  if (ref != null) {
                                    modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, ref, true, false) : null;
                                  }
                                   else {
                                    ctx.resolvers.add_za3rmp$(new _.org.kevoree.modeling.api.xmi.XMIResolveCommand(ctx, modelElem != null ? modelElem : Kotlin.throwNPE(), _.org.kevoree.modeling.api.util.ActionType.object.ADD, attrName, adjustedRef, this.resourceSet));
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  var done = false;
                  while (!done) {
                    var tmp$29;
                    {
                      var tmp$30 = ((tmp$29 = ctx.xmiReader) != null ? tmp$29 : Kotlin.throwNPE()).next();
                      if (tmp$30 === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
                        var tmp$31, tmp$32, tmp$34;
                        var subElemName = ((tmp$31 = ctx.xmiReader) != null ? tmp$31 : Kotlin.throwNPE()).getLocalName();
                        var i_1 = (tmp$32 = ctx.elementsCount.get_za3rmp$(xmiAddress + '/@' + subElemName)) != null ? tmp$32 : 0;
                        var tmp$33 = xmiAddress + '/@' + subElemName;
                        if (i_1 !== 0) {
                          tmp$34 = '.' + i_1;
                        }
                         else {
                          tmp$34 = '';
                        }
                        var subElementId = tmp$33 + tmp$34;
                        var containedElement = this.loadObject(ctx, subElementId, elemReferencesMap.get_za3rmp$(subElemName));
                        modelElem != null ? modelElem.reflexiveMutator(_.org.kevoree.modeling.api.util.ActionType.object.ADD, subElemName, containedElement, true, false) : null;
                        ctx.elementsCount.put_wn2jw4$(xmiAddress + '/@' + subElemName, i_1 + 1);
                      }
                       else if (tmp$30 === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
                        var tmp$35;
                        if (Kotlin.equals(((tmp$35 = ctx.xmiReader) != null ? tmp$35 : Kotlin.throwNPE()).getLocalName(), elementTagName)) {
                          done = true;
                        }
                      }
                       else {
                      }
                    }
                  }
                  return modelElem != null ? modelElem : Kotlin.throwNPE();
                },
                deserialize: function (reader) {
                  var nsURI = null;
                  var context = new _.org.kevoree.modeling.api.xmi.LoadingContext();
                  context.xmiReader = reader;
                  while (reader.hasNext()) {
                    var nextTag = reader.next();
                    {
                      if (nextTag === _.org.kevoree.modeling.api.xmi.Token.START_TAG) {
                        var localName = reader.getLocalName();
                        if (localName != null) {
                          var loadedRootsSize = context.loadedRoots.size();
                          var ns = new Kotlin.PrimitiveHashMap();
                          var tmp$0, tmp$1, tmp$2, tmp$3, tmp$4;
                          {
                            tmp$1 = new Kotlin.NumberRange(0, ((tmp$0 = context.xmiReader) != null ? tmp$0 : Kotlin.throwNPE()).getAttributeCount() - 1), tmp$2 = tmp$1.start, tmp$3 = tmp$1.end, tmp$4 = tmp$1.increment;
                            for (var i = tmp$2; i <= tmp$3; i += tmp$4) {
                              var tmp$5, tmp$6;
                              var localName_0 = ((tmp$5 = context.xmiReader) != null ? tmp$5 : Kotlin.throwNPE()).getAttributeLocalName(i);
                              var localValue = ((tmp$6 = context.xmiReader) != null ? tmp$6 : Kotlin.throwNPE()).getAttributeValue(i);
                              if (Kotlin.equals(localName_0, this.LOADER_XMI_NS_URI)) {
                                nsURI = localValue;
                              }
                              ns.put_wn2jw4$(localName_0, localValue);
                            }
                          }
                          var xsiType = reader.tagPrefix;
                          var realTypeName = ns.get_za3rmp$(xsiType);
                          if (realTypeName == null) {
                            realTypeName = xsiType;
                          }
                          context.loadedRoots.add_za3rmp$(this.loadObject(context, '/' + loadedRootsSize, Kotlin.toString(xsiType) + '.' + localName));
                        }
                         else {
                          Kotlin.println('Tried to read a tag with null tag_name.');
                        }
                      }
                       else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_TAG) {
                        break;
                      }
                       else if (nextTag === _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT) {
                        break;
                      }
                       else {
                      }
                    }
                  }
                  {
                    var tmp$7 = context.resolvers.iterator();
                    while (tmp$7.hasNext()) {
                      var res = tmp$7.next();
                      res.run();
                    }
                  }
                  if (this.resourceSet != null && nsURI != null) {
                    var tmp$8;
                    ((tmp$8 = this.resourceSet) != null ? tmp$8 : Kotlin.throwNPE()).registerXmiAddrMappedObjects(nsURI != null ? nsURI : Kotlin.throwNPE(), context.map);
                  }
                  return context.loadedRoots;
                }
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIModelLoader */ {
                visit$f: function () {
                  return new Kotlin.PrimitiveHashMap();
                },
                XMIModelLoader$f: function (this$XMIModelLoader) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelAttributeVisitor];
                  }, null, {
                    visit: function (value, name, parent) {
                      _.kotlin.getOrPut_ynyybx$(this$XMIModelLoader.attributesHashmap_7wijs5$, parent.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.visit$f).put_wn2jw4$(name, true);
                    }
                  });
                },
                beginVisitElem$f: function () {
                  return new Kotlin.PrimitiveHashMap();
                },
                XMIModelLoader$f_0: function (this$XMIModelLoader) {
                  return Kotlin.createObject(function () {
                    return [_.org.kevoree.modeling.api.util.ModelVisitor];
                  }, function $fun() {
                    $fun.baseInitializer.call(this);
                    this.refMap = null;
                  }, {
                    beginVisitElem: function (elem) {
                      this.refMap = _.kotlin.getOrPut_ynyybx$(this$XMIModelLoader.referencesHashmap_cc1kom$, elem.metaClassName(), _.org.kevoree.modeling.api.xmi.XMIModelLoader.beginVisitElem$f);
                    },
                    endVisitElem: function (elem) {
                      this.refMap = null;
                    },
                    beginVisitRef: function (refName, refType) {
                      var tmp$0;
                      ((tmp$0 = this.refMap) != null ? tmp$0 : Kotlin.throwNPE()).put_wn2jw4$(refName, refType);
                      return true;
                    },
                    visit: function (elem, refNameInParent, parent) {
                    }
                  });
                }
              }),
              LoadingContext: Kotlin.createClass(null, function () {
                this.xmiReader = null;
                this.loadedRoots = new Kotlin.ArrayList();
                this.map = new Kotlin.PrimitiveHashMap();
                this.elementsCount = new Kotlin.PrimitiveHashMap();
                this.resolvers = new Kotlin.ArrayList();
                this.stats = new Kotlin.PrimitiveHashMap();
                this.oppositesAlreadySet = new Kotlin.PrimitiveHashMap();
              }, /** @lends _.org.kevoree.modeling.api.xmi.LoadingContext.prototype */ {
                isOppositeAlreadySet: function (localRef, oppositeRef) {
                  var res = this.oppositesAlreadySet.get_za3rmp$(oppositeRef + '_' + localRef) != null || this.oppositesAlreadySet.get_za3rmp$(localRef + '_' + oppositeRef) != null;
                  return res;
                },
                storeOppositeRelation: function (localRef, oppositeRef) {
                  this.oppositesAlreadySet.put_wn2jw4$(localRef + '_' + oppositeRef, true);
                }
              }),
              XMIResolveCommand: Kotlin.createClass(null, function (context, target, mutatorType, refName, ref, resourceSet) {
                this.context = context;
                this.target = target;
                this.mutatorType = mutatorType;
                this.refName = refName;
                this.ref = ref;
                this.resourceSet = resourceSet;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XMIResolveCommand.prototype */ {
                run: function () {
                  var referencedElement = this.context.map.get_za3rmp$(this.ref);
                  if (referencedElement != null) {
                    this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                    return;
                  }
                  if (Kotlin.equals(this.ref, '/0/') || Kotlin.equals(this.ref, '/')) {
                    referencedElement = this.context.map.get_za3rmp$('/0');
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  if (this.resourceSet != null) {
                    referencedElement = this.resourceSet.resolveObject(this.ref);
                    if (referencedElement != null) {
                      this.target.reflexiveMutator(this.mutatorType, this.refName, referencedElement, true, false);
                      return;
                    }
                  }
                  throw new Error('KMF Load error : reference ' + this.ref + ' not found in map when trying to  ' + this.mutatorType + ' ' + this.refName + '  on ' + this.target.metaClassName() + '(path:' + this.target.path() + ')');
                }
              }),
              XmlParser: Kotlin.createClass(null, function (inputStream) {
                this.inputStream = inputStream;
                this.bytes_gdnk4p$ = this.inputStream.readBytes();
                this.index_gharkg$ = -1;
                this.currentChar_x9b225$ = null;
                this.xmlVersion_ywy43n$ = null;
                this.xmlCharset_tph6x5$ = null;
                this.tagName_b61wcj$ = '';
                this.tagPrefix = null;
                this.attributesNames_b5o00h$ = new Kotlin.ArrayList();
                this.attributesPrefixes_hgbl8n$ = new Kotlin.ArrayList();
                this.attributesValues_d28x97$ = new Kotlin.ArrayList();
                this.attributeName_f9qnph$ = new Kotlin.StringBuilder();
                this.attributePrefix_r6drlg$ = null;
                this.attributeValue_npfmfd$ = new Kotlin.StringBuilder();
                this.readSingleton_h1okvh$ = false;
              }, /** @lends _.org.kevoree.modeling.api.xmi.XmlParser.prototype */ {
                hasNext: function () {
                  return this.bytes_gdnk4p$.length - this.index_gharkg$ > 2;
                },
                getLocalName: function () {
                  return this.tagName_b61wcj$;
                },
                getAttributeCount: function () {
                  return this.attributesNames_b5o00h$.size();
                },
                getAttributeLocalName: function (i) {
                  return this.attributesNames_b5o00h$.get_za3lpa$(i);
                },
                getAttributePrefix: function (i) {
                  return this.attributesPrefixes_hgbl8n$.get_za3lpa$(i);
                },
                getAttributeValue: function (i) {
                  return this.attributesValues_d28x97$.get_za3lpa$(i);
                },
                readChar: function () {
                  return _.org.kevoree.modeling.api.util.ByteConverter.toChar(this.bytes_gdnk4p$[++this.index_gharkg$]);
                },
                next: function () {
                  if (this.readSingleton_h1okvh$) {
                    this.readSingleton_h1okvh$ = false;
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                  if (!this.hasNext()) {
                    return _.org.kevoree.modeling.api.xmi.Token.END_DOCUMENT;
                  }
                  this.attributesNames_b5o00h$.clear();
                  this.attributesPrefixes_hgbl8n$.clear();
                  this.attributesValues_d28x97$.clear();
                  this.read_lessThan();
                  this.currentChar_x9b225$ = this.readChar();
                  if (this.currentChar_x9b225$ === '?') {
                    this.currentChar_x9b225$ = this.readChar();
                    this.read_xmlHeader();
                    return _.org.kevoree.modeling.api.xmi.Token.XML_HEADER;
                  }
                   else if (this.currentChar_x9b225$ === '!') {
                    do {
                      this.currentChar_x9b225$ = this.readChar();
                    }
                     while (this.currentChar_x9b225$ !== '>');
                    return _.org.kevoree.modeling.api.xmi.Token.COMMENT;
                  }
                   else if (this.currentChar_x9b225$ === '/') {
                    this.currentChar_x9b225$ = this.readChar();
                    this.read_closingTag();
                    return _.org.kevoree.modeling.api.xmi.Token.END_TAG;
                  }
                   else {
                    this.read_openTag();
                    if (this.currentChar_x9b225$ === '/') {
                      this.read_upperThan();
                      this.readSingleton_h1okvh$ = true;
                    }
                    return _.org.kevoree.modeling.api.xmi.Token.START_TAG;
                  }
                },
                read_lessThan: function () {
                  do {
                    this.currentChar_x9b225$ = this.readChar();
                  }
                   while (this.currentChar_x9b225$ !== '<');
                },
                read_upperThan: function () {
                  while (this.currentChar_x9b225$ !== '>') {
                    this.currentChar_x9b225$ = this.readChar();
                  }
                },
                read_xmlHeader: function () {
                  this.read_tagName();
                  this.read_attributes();
                  this.read_upperThan();
                },
                read_closingTag: function () {
                  this.read_tagName();
                  this.read_upperThan();
                },
                read_openTag: function () {
                  this.read_tagName();
                  if (this.currentChar_x9b225$ !== '>' && this.currentChar_x9b225$ !== '/') {
                    this.read_attributes();
                  }
                },
                read_tagName: function () {
                  this.tagName_b61wcj$ = '' + this.currentChar_x9b225$;
                  this.tagPrefix = null;
                  this.currentChar_x9b225$ = this.readChar();
                  while (this.currentChar_x9b225$ !== ' ' && this.currentChar_x9b225$ !== '>' && this.currentChar_x9b225$ !== '/') {
                    if (this.currentChar_x9b225$ === ':') {
                      this.tagPrefix = this.tagName_b61wcj$;
                      this.tagName_b61wcj$ = '';
                    }
                     else {
                      this.tagName_b61wcj$ += this.currentChar_x9b225$;
                    }
                    this.currentChar_x9b225$ = this.readChar();
                  }
                },
                read_attributes: function () {
                  var end_of_tag = false;
                  while (this.currentChar_x9b225$ === ' ') {
                    this.currentChar_x9b225$ = this.readChar();
                  }
                  while (!end_of_tag) {
                    while (this.currentChar_x9b225$ !== '=') {
                      if (this.currentChar_x9b225$ === ':') {
                        this.attributePrefix_r6drlg$ = this.attributeName_f9qnph$.toString();
                        this.attributeName_f9qnph$ = new Kotlin.StringBuilder();
                      }
                       else {
                        var tmp$0;
                        this.attributeName_f9qnph$.append((tmp$0 = this.currentChar_x9b225$) != null ? tmp$0 : Kotlin.throwNPE());
                      }
                      this.currentChar_x9b225$ = this.readChar();
                    }
                    do {
                      this.currentChar_x9b225$ = this.readChar();
                    }
                     while (this.currentChar_x9b225$ !== '"');
                    this.currentChar_x9b225$ = this.readChar();
                    while (this.currentChar_x9b225$ !== '"') {
                      var tmp$1;
                      this.attributeValue_npfmfd$.append((tmp$1 = this.currentChar_x9b225$) != null ? tmp$1 : Kotlin.throwNPE());
                      this.currentChar_x9b225$ = this.readChar();
                    }
                    this.attributesNames_b5o00h$.add_za3rmp$(this.attributeName_f9qnph$.toString());
                    this.attributesPrefixes_hgbl8n$.add_za3rmp$(this.attributePrefix_r6drlg$);
                    this.attributesValues_d28x97$.add_za3rmp$(this.attributeValue_npfmfd$.toString());
                    this.attributeName_f9qnph$ = new Kotlin.StringBuilder();
                    this.attributePrefix_r6drlg$ = null;
                    this.attributeValue_npfmfd$ = new Kotlin.StringBuilder();
                    do {
                      this.currentChar_x9b225$ = this.readChar();
                      if (this.currentChar_x9b225$ === '?' || this.currentChar_x9b225$ === '/' || this.currentChar_x9b225$ === '-' || this.currentChar_x9b225$ === '>') {
                        end_of_tag = true;
                      }
                    }
                     while (!end_of_tag && this.currentChar_x9b225$ === ' ');
                  }
                }
              })
            })
          })
        })
      }),
      w3c: Kotlin.definePackage(null, /** @lends _.org.w3c */ {
        dom: Kotlin.definePackage(null, /** @lends _.org.w3c.dom */ {
          events: Kotlin.definePackage(null, /** @lends _.org.w3c.dom.events */ {
            EventListener: Kotlin.createTrait(null)
          })
        })
      })
    }),
    java: Kotlin.definePackage(null, /** @lends _.java */ {
      util: Kotlin.definePackage(null, /** @lends _.java.util */ {
        concurrent: Kotlin.definePackage(null, /** @lends _.java.util.concurrent */ {
          ConcurrentHashMap: Kotlin.createClass(function () {
            return [Kotlin.HashMap];
          }, function $fun() {
            $fun.baseInitializer.call(this);
          })
        }),
        IdentityHashMap: Kotlin.createClass(function () {
          return [Kotlin.HashMap];
        }, function $fun() {
          $fun.baseInitializer.call(this);
        }),
        HashSet_xeylzf$: function (c) {
          var set = new Kotlin.ComplexHashSet(c.size());
          set.addAll_xeylzf$(c);
          return set;
        },
        LinkedHashSet_xeylzf$: function (c) {
          var set = new Kotlin.LinkedHashSet(c.size());
          set.addAll_xeylzf$(c);
          return set;
        },
        HashMap_za3j1t$: function (m) {
          var map = new Kotlin.ComplexHashMap(m.size());
          map.putAll_za3j1t$(m);
          return map;
        },
        LinkedHashMap_za3j1t$: function (m) {
          var map = new Kotlin.LinkedHashMap(m.size());
          map.putAll_za3j1t$(m);
          return map;
        }
      }),
      lang: Kotlin.definePackage(function () {
        this.Long = Kotlin.createObject(null, null, {
          parseLong: function (s) {
            return s;
          }
        });
        this.Integer = Kotlin.createObject(null, null, {
          parseInt: function (s) {
            return s;
          }
        });
      }, /** @lends _.java.lang */ {
      }),
      io: Kotlin.definePackage(null, /** @lends _.java.io */ {
        InputStream: Kotlin.createTrait(null),
        OutputStream: Kotlin.createTrait(null),
        BufferedOutputStream: Kotlin.createClass(function () {
          return [_.java.io.OutputStream];
        }, function (oo) {
          this.oo = oo;
        }, /** @lends _.java.io.BufferedOutputStream.prototype */ {
          write: function (s) {
            this.oo.result = s;
          }
        }),
        ByteArrayInputStream: Kotlin.createClass(function () {
          return [_.java.io.InputStream];
        }, function (inputBytes) {
          this.inputBytes = inputBytes;
        }, /** @lends _.java.io.ByteArrayInputStream.prototype */ {
          readBytes: function () {
            return this.inputBytes;
          }
        }),
        ByteArrayOutputStream: Kotlin.createClass(function () {
          return [_.java.io.OutputStream];
        }, function () {
          this.result = '';
        }, /** @lends _.java.io.ByteArrayOutputStream.prototype */ {
          flush: function () {
          },
          close: function () {
          },
          toString: function () {
            return this.result;
          }
        }),
        PrintStream: Kotlin.createClass(null, function (oo, autoflush) {
          this.oo = oo;
          this.result = '';
        }, /** @lends _.java.io.PrintStream.prototype */ {
          println: function () {
            this.result = this.result + '\n';
          },
          print_4: function (s) {
            this.result = this.result + s;
          },
          println_2: function (s) {
            this.print_4(s);
            this.println();
          },
          print_1: function (s) {
            this.result = this.result + s;
          },
          print_2: function (s) {
            this.result = this.result + s;
          },
          print_3: function (s) {
            this.result = this.result + s;
          },
          print: function (s) {
            if (s) {
              this.result = this.result + 'true';
            }
             else {
              this.result = this.result + 'false';
            }
          },
          println_1: function (s) {
            this.print_1(s);
            this.println();
          },
          flush: function () {
            this.oo.write(this.result);
          },
          close: function () {
          }
        })
      })
    }),
    js: Kotlin.definePackage(null, /** @lends _.js */ {
      toChar_mz3mef$: function ($receiver) {
        return $receiver;
      },
      lastIndexOf_orzsrp$: function ($receiver, ch, fromIndex) {
        return $receiver.lastIndexOf(ch.toString(), fromIndex);
      },
      lastIndexOf_960177$: function ($receiver, ch) {
        return $receiver.lastIndexOf(ch.toString());
      },
      indexOf_960177$: function ($receiver, ch) {
        return $receiver.indexOf(ch.toString());
      },
      indexOf_orzsrp$: function ($receiver, ch, fromIndex) {
        return $receiver.indexOf(ch.toString(), fromIndex);
      },
      matches_94jgcu$: function ($receiver, regex) {
        var result = $receiver.match(regex);
        return result != null && result.length > 0;
      },
      capitalize_pdl1w0$: function ($receiver) {
        return _.kotlin.isNotEmpty_pdl1w0$($receiver) ? $receiver.substring(0, 1).toUpperCase() + $receiver.substring(1) : $receiver;
      },
      decapitalize_pdl1w0$: function ($receiver) {
        return _.kotlin.isNotEmpty_pdl1w0$($receiver) ? $receiver.substring(0, 1).toLowerCase() + $receiver.substring(1) : $receiver;
      }
    }),
    kotlin: Kotlin.definePackage(function () {
      this.stdlib_emptyList_w9bu57$ = new Kotlin.ArrayList();
      this.stdlib_emptyMap_h2vi7z$ = new Kotlin.ComplexHashMap();
    }, /** @lends _.kotlin */ {
      dom: Kotlin.definePackage(null, /** @lends _.kotlin.dom */ {
        createDocument: function () {
          return document.implementation.createDocument(null, null, null);
        },
        toXmlString_asww5t$: function ($receiver) {
          return $receiver.outerHTML;
        },
        toXmlString_rq0l4m$: function ($receiver, xmlDeclaration) {
          return $receiver.outerHTML;
        },
        eventHandler: function (handler) {
          return new _.kotlin.dom.EventListenerHandler(handler);
        },
        EventListenerHandler: Kotlin.createClass(function () {
          return [_.org.w3c.dom.events.EventListener];
        }, function (handler) {
          this.handler = handler;
        }, /** @lends _.kotlin.dom.EventListenerHandler.prototype */ {
          handleEvent: function (e) {
            if (e != null) {
              this.handler(e);
            }
          }
        }),
        mouseEventHandler$f: function (handler) {
          return function (e) {
            if (Kotlin.isType(e, MouseEvent)) {
              handler(e);
            }
          };
        },
        mouseEventHandler: function (handler) {
          return _.kotlin.dom.eventHandler(_.kotlin.dom.mouseEventHandler$f(handler));
        },
        on_10gtds$: function ($receiver, name, capture, handler) {
          return _.kotlin.dom.on_edii0a$($receiver, name, capture, _.kotlin.dom.eventHandler(handler));
        },
        on_edii0a$: function ($receiver, name, capture, listener) {
          var tmp$0;
          if (Kotlin.isType($receiver, EventTarget)) {
            $receiver.addEventListener(name, listener, capture);
            tmp$0 = new _.kotlin.dom.CloseableEventListener($receiver, listener, name, capture);
          }
           else {
            tmp$0 = null;
          }
          return tmp$0;
        },
        CloseableEventListener: Kotlin.createClass(function () {
          return [Kotlin.Closeable];
        }, function (target, listener, name, capture) {
          this.target = target;
          this.listener = listener;
          this.name = name;
          this.capture = capture;
        }, /** @lends _.kotlin.dom.CloseableEventListener.prototype */ {
          close: function () {
            this.target.removeEventListener(this.name, this.listener, this.capture);
          }
        }),
        onClick_alenf6$: function ($receiver, capture, handler) {
          if (capture === void 0)
            capture = false;
          return _.kotlin.dom.on_edii0a$($receiver, 'click', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        onDoubleClick_alenf6$: function ($receiver, capture, handler) {
          if (capture === void 0)
            capture = false;
          return _.kotlin.dom.on_edii0a$($receiver, 'dblclick', capture, _.kotlin.dom.mouseEventHandler(handler));
        },
        emptyElementList: function () {
          return Kotlin.emptyList();
        },
        emptyNodeList: function () {
          return Kotlin.emptyList();
        },
        get_text: {value: function ($receiver) {
          return $receiver.textContent;
        }},
        set_text: {value: function ($receiver, value) {
          $receiver.textContent = value;
        }},
        get_childrenText: {value: function ($receiver) {
          var buffer = new Kotlin.StringBuilder();
          var nodeList = $receiver.childNodes;
          var i = 0;
          var size = nodeList.length;
          while (i < size) {
            var node = nodeList.item(i);
            if (node != null) {
              if (_.kotlin.dom.isText(node)) {
                buffer.append(node.nodeValue);
              }
            }
            i++;
          }
          return buffer.toString();
        }},
        set_childrenText: {value: function ($receiver, value) {
          var element = $receiver;
          {
            var tmp$0 = _.kotlin.dom.children(element).iterator();
            while (tmp$0.hasNext()) {
              var node = tmp$0.next();
              if (_.kotlin.dom.isText(node)) {
                $receiver.removeChild(node);
              }
            }
          }
          _.kotlin.dom.addText(element, value);
        }},
        get_id: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('id')) != null ? tmp$0 : '';
        }},
        set_id: {value: function ($receiver, value) {
          $receiver.setAttribute('id', value);
          $receiver.setIdAttribute('id', true);
        }},
        get_style: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('style')) != null ? tmp$0 : '';
        }},
        set_style: {value: function ($receiver, value) {
          $receiver.setAttribute('style', value);
        }},
        get_classes: {value: function ($receiver) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute('class')) != null ? tmp$0 : '';
        }},
        set_classes: {value: function ($receiver, value) {
          $receiver.setAttribute('class', value);
        }},
        hasClass: function ($receiver, cssClass) {
          var c = _.kotlin.dom.get_classes($receiver);
          return _.js.matches_94jgcu$(c, '(^|.*' + '\\' + 's+)' + cssClass + '(' + '$' + '|' + '\\' + 's+.*)');
        },
        children: function ($receiver) {
          return _.kotlin.dom.toList($receiver != null ? $receiver.childNodes : null);
        },
        childElements$f: function (it) {
          return it.nodeType === Node.ELEMENT_NODE;
        },
        childElements$f_0: function (it) {
          return it;
        },
        childElements: function ($receiver) {
          return _.kotlin.map_vqr6wr$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.children($receiver), _.kotlin.dom.childElements$f), _.kotlin.dom.childElements$f_0);
        },
        childElements_1$f: function (name) {
          return function (it) {
            return it.nodeType === Node.ELEMENT_NODE && Kotlin.equals(it.nodeName, name);
          };
        },
        childElements_1$f_0: function (it) {
          return it;
        },
        childElements_1: function ($receiver, name) {
          return _.kotlin.map_vqr6wr$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.children($receiver), _.kotlin.dom.childElements_1$f(name)), _.kotlin.dom.childElements_1$f_0);
        },
        get_elements: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        get_elements_0: {value: function ($receiver) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName('*') : null);
        }},
        elements_1: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_2: function ($receiver, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagName(localName) : null);
        },
        elements_3: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        elements_2_0: function ($receiver, namespaceUri, localName) {
          return _.kotlin.dom.toElementList($receiver != null ? $receiver.getElementsByTagNameNS(namespaceUri, localName) : null);
        },
        toList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = _.kotlin.dom.emptyNodeList();
          }
           else {
            tmp$0 = new _.kotlin.dom.NodeListAsList($receiver);
          }
          return tmp$0;
        },
        toElementList: function ($receiver) {
          var tmp$0;
          if ($receiver == null) {
            tmp$0 = new Kotlin.ArrayList();
          }
           else {
            tmp$0 = new _.kotlin.dom.ElementListAsList($receiver);
          }
          return tmp$0;
        },
        get$f: function (selector) {
          return function (it) {
            return _.kotlin.dom.hasClass(it, selector.substring(1));
          };
        },
        get: function ($receiver, selector) {
          var root = $receiver != null ? $receiver.documentElement : null;
          var tmp$0;
          if (root != null) {
            if (Kotlin.equals(selector, '*')) {
              tmp$0 = _.kotlin.dom.get_elements($receiver);
            }
             else if (selector.startsWith('.')) {
              tmp$0 = _.kotlin.toList_h3panj$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.get_elements($receiver), _.kotlin.dom.get$f(selector)));
            }
             else if (selector.startsWith('#')) {
              var id = selector.substring(1);
              var element = $receiver != null ? $receiver.getElementById(id) : null;
              return element != null ? _.kotlin.arrayListOf_mzrxf8$([element]) : _.kotlin.dom.emptyElementList();
            }
             else {
              tmp$0 = _.kotlin.dom.elements_2($receiver, selector);
            }
          }
           else {
            tmp$0 = _.kotlin.dom.emptyElementList();
          }
          return tmp$0;
        },
        get_1$f: function (selector) {
          return function (it) {
            return _.kotlin.dom.hasClass(it, selector.substring(1));
          };
        },
        get_1: function ($receiver, selector) {
          var tmp$1;
          if (Kotlin.equals(selector, '*')) {
            tmp$1 = _.kotlin.dom.get_elements_0($receiver);
          }
           else if (selector.startsWith('.')) {
            tmp$1 = _.kotlin.toList_h3panj$(_.kotlin.filter_vqr6wr$(_.kotlin.dom.get_elements_0($receiver), _.kotlin.dom.get_1$f(selector)));
          }
           else if (selector.startsWith('#')) {
            var tmp$0;
            var element = (tmp$0 = $receiver.ownerDocument) != null ? tmp$0.getElementById(selector.substring(1)) : null;
            return element != null ? _.kotlin.arrayListOf_mzrxf8$([element]) : _.kotlin.dom.emptyElementList();
          }
           else {
            tmp$1 = _.kotlin.dom.elements_1($receiver, selector);
          }
          return tmp$1;
        },
        NodeListAsList: Kotlin.createClass(function () {
          return [Kotlin.AbstractList];
        }, function $fun(nodeList) {
          $fun.baseInitializer.call(this);
          this.nodeList = nodeList;
        }, /** @lends _.kotlin.dom.NodeListAsList.prototype */ {
          get_za3lpa$: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else {
              return node;
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        ElementListAsList: Kotlin.createClass(function () {
          return [Kotlin.AbstractList];
        }, function $fun(nodeList) {
          $fun.baseInitializer.call(this);
          this.nodeList = nodeList;
        }, /** @lends _.kotlin.dom.ElementListAsList.prototype */ {
          get_za3lpa$: function (index) {
            var node = this.nodeList.item(index);
            if (node == null) {
              throw new RangeError('NodeList does not contain a node at index: ' + index);
            }
             else if (node.nodeType === Node.ELEMENT_NODE) {
              return node;
            }
             else {
              throw new Kotlin.IllegalArgumentException('Node is not an Element as expected but is ' + node);
            }
          },
          size: function () {
            return this.nodeList.length;
          }
        }),
        clear: function ($receiver) {
          while (true) {
            var child = $receiver.firstChild;
            if (child == null) {
              return;
            }
             else {
              $receiver.removeChild(child);
            }
          }
        },
        nextSiblings: function ($receiver) {
          return new _.kotlin.dom.NextSiblings($receiver);
        },
        NextSiblings: Kotlin.createClass(null, function (node) {
          this.node = node;
        }, /** @lends _.kotlin.dom.NextSiblings.prototype */ {
          iterator: function () {
            return _.kotlin.dom.NextSiblings.iterator$f(this);
          }
        }, /** @lends _.kotlin.dom.NextSiblings */ {
          iterator$f: function (this$NextSiblings) {
            return Kotlin.createObject(function () {
              return [_.kotlin.support.AbstractIterator];
            }, function $fun() {
              $fun.baseInitializer.call(this);
            }, {
              computeNext: function () {
                var nextValue = this$NextSiblings.node.nextSibling;
                if (nextValue != null) {
                  this.setNext_za3rmp$(nextValue);
                  this$NextSiblings.node = nextValue;
                }
                 else {
                  this.done();
                }
              }
            });
          }
        }),
        previousSiblings: function ($receiver) {
          return new _.kotlin.dom.PreviousSiblings($receiver);
        },
        PreviousSiblings: Kotlin.createClass(null, function (node) {
          this.node = node;
        }, /** @lends _.kotlin.dom.PreviousSiblings.prototype */ {
          iterator: function () {
            return _.kotlin.dom.PreviousSiblings.iterator$f(this);
          }
        }, /** @lends _.kotlin.dom.PreviousSiblings */ {
          iterator$f: function (this$PreviousSiblings) {
            return Kotlin.createObject(function () {
              return [_.kotlin.support.AbstractIterator];
            }, function $fun() {
              $fun.baseInitializer.call(this);
            }, {
              computeNext: function () {
                var nextValue = this$PreviousSiblings.node.previousSibling;
                if (nextValue != null) {
                  this.setNext_za3rmp$(nextValue);
                  this$PreviousSiblings.node = nextValue;
                }
                 else {
                  this.done();
                }
              }
            });
          }
        }),
        isText: function ($receiver) {
          var nt = $receiver.nodeType;
          return nt === Node.TEXT_NODE || nt === Node.CDATA_SECTION_NODE;
        },
        attribute: function ($receiver, name) {
          var tmp$0;
          return (tmp$0 = $receiver.getAttribute(name)) != null ? tmp$0 : '';
        },
        get_head: {value: function ($receiver) {
          return $receiver != null && $receiver.length > 0 ? $receiver.item(0) : null;
        }},
        get_first: {value: function ($receiver) {
          return _.kotlin.dom.get_head($receiver);
        }},
        get_tail: {value: function ($receiver) {
          if ($receiver == null) {
            return null;
          }
           else {
            var s = $receiver.length;
            return s > 0 ? $receiver.item(s - 1) : null;
          }
        }},
        get_last: {value: function ($receiver) {
          return _.kotlin.dom.get_tail($receiver);
        }},
        toXmlString_1: function ($receiver, xmlDeclaration) {
          if (xmlDeclaration === void 0)
            xmlDeclaration = false;
          var tmp$0;
          if ($receiver == null)
            tmp$0 = '';
          else {
            tmp$0 = _.kotlin.dom.nodesToXmlString_lwhwg8$(_.kotlin.dom.toList($receiver), xmlDeclaration);
          }
          return tmp$0;
        },
        nodesToXmlString_lwhwg8$: function (nodes, xmlDeclaration) {
          if (xmlDeclaration === void 0)
            xmlDeclaration = false;
          var builder = new Kotlin.StringBuilder();
          {
            var tmp$0 = nodes.iterator();
            while (tmp$0.hasNext()) {
              var n = tmp$0.next();
              builder.append(_.kotlin.dom.toXmlString_rq0l4m$(n, xmlDeclaration));
            }
          }
          return builder.toString();
        },
        plus_1: function ($receiver, child) {
          if (child != null) {
            $receiver.appendChild(child);
          }
          return $receiver;
        },
        plus: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text);
        },
        plusAssign: function ($receiver, text) {
          return _.kotlin.dom.addText($receiver, text);
        },
        createElement: function ($receiver, name, init) {
          var elem = $receiver.createElement(name);
          init.call(elem);
          return elem;
        },
        createElement_1: function ($receiver, name, doc, init) {
          if (doc === void 0)
            doc = null;
          var elem = _.kotlin.dom.ownerDocument($receiver, doc).createElement(name);
          init.call(elem);
          return elem;
        },
        ownerDocument: function ($receiver, doc) {
          if (doc === void 0)
            doc = null;
          var tmp$0;
          if ($receiver.nodeType === Node.DOCUMENT_NODE)
            tmp$0 = $receiver;
          else if (doc == null)
            tmp$0 = $receiver.ownerDocument;
          else
            tmp$0 = doc;
          var answer = tmp$0;
          if (answer == null) {
            throw new Kotlin.IllegalArgumentException('Element does not have an ownerDocument and none was provided for: ' + $receiver);
          }
           else {
            return answer;
          }
        },
        addElement: function ($receiver, name, init) {
          var child = _.kotlin.dom.createElement($receiver, name, init);
          $receiver.appendChild(child);
          return child;
        },
        addElement_1: function ($receiver, name, doc, init) {
          if (doc === void 0)
            doc = null;
          var child = _.kotlin.dom.createElement_1($receiver, name, doc, init);
          $receiver.appendChild(child);
          return child;
        },
        addText: function ($receiver, text, doc) {
          if (doc === void 0)
            doc = null;
          if (text != null) {
            var child = _.kotlin.dom.ownerDocument($receiver, doc).createTextNode(text);
            $receiver.appendChild(child);
          }
          return $receiver;
        }
      }),
      test: Kotlin.definePackage(function () {
        this.asserter = new _.kotlin.test.QUnitAsserter();
      }, /** @lends _.kotlin.test */ {
        todo_n8bj3p$: function (block) {
          Kotlin.println('TODO at ' + block);
        },
        QUnitAsserter: Kotlin.createClass(function () {
          return [_.kotlin.test.Asserter];
        }, null, /** @lends _.kotlin.test.QUnitAsserter.prototype */ {
          assertTrue_ivxn3r$: function (message, actual) {
            ok(actual, message);
          },
          assertEquals_a59ba6$: function (message, expected, actual) {
            ok(Kotlin.equals(expected, actual), message + '. Expected <' + Kotlin.toString(expected) + '> actual <' + Kotlin.toString(actual) + '>');
          },
          assertNotNull_bm4g0d$: function (message, actual) {
            ok(actual != null, message);
          },
          assertNull_bm4g0d$: function (message, actual) {
            ok(actual == null, message);
          },
          fail_61zpoe$: function (message) {
            ok(false, message);
          }
        }),
        assertTrue_2xfrrb$: function (message, block) {
          var actual = block();
          _.kotlin.test.asserter.assertTrue_ivxn3r$(message, actual);
        },
        assertTrue_n8bj3p$: function (block) {
          _.kotlin.test.assertTrue_2xfrrb$('expected true', block);
        },
        assertNot_2xfrrb$f: function (block) {
          return function () {
            return !block();
          };
        },
        assertNot_2xfrrb$: function (message, block) {
          _.kotlin.test.assertTrue_2xfrrb$(message, _.kotlin.test.assertNot_2xfrrb$f(block));
        },
        assertNot_n8bj3p$: function (block) {
          _.kotlin.test.assertNot_2xfrrb$('expected false', block);
        },
        assertTrue_8kj6y5$: function (actual, message) {
          if (message === void 0)
            message = '';
          return _.kotlin.test.assertEquals_8vv676$(true, actual, message);
        },
        assertFalse_8kj6y5$: function (actual, message) {
          if (message === void 0)
            message = '';
          return _.kotlin.test.assertEquals_8vv676$(false, actual, message);
        },
        assertEquals_8vv676$: function (expected, actual, message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.assertEquals_a59ba6$(message, expected, actual);
        },
        assertNotNull_hwpqgh$: function (actual, message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.assertNotNull_bm4g0d$(message, actual);
          return actual != null ? actual : Kotlin.throwNPE();
        },
        assertNotNull_74f9dl$: function (actual, block) {
          _.kotlin.test.assertNotNull_ll92s9$(actual, '', block);
        },
        assertNotNull_ll92s9$: function (actual, message, block) {
          _.kotlin.test.asserter.assertNotNull_bm4g0d$(message, actual);
          if (actual != null) {
            block(actual);
          }
        },
        assertNull_hwpqgh$: function (actual, message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.assertNull_bm4g0d$(message, actual);
        },
        fail_61zpoe$: function (message) {
          if (message === void 0)
            message = '';
          _.kotlin.test.asserter.fail_61zpoe$(message);
        },
        expect_74f9dk$: function (expected, block) {
          _.kotlin.test.expect_ll92sa$(expected, 'expected ' + expected, block);
        },
        expect_ll92sa$: function (expected, message, block) {
          var actual = block();
          _.kotlin.test.assertEquals_8vv676$(expected, actual, message);
        },
        fails_n8bj3p$: function (block) {
          try {
            block();
            _.kotlin.test.asserter.fail_61zpoe$('Expected an exception to be thrown');
            return null;
          }
           catch (e) {
            return e;
          }
        },
        Asserter: Kotlin.createTrait(null)
      }),
      Pair: Kotlin.createClass(null, function (first, second) {
        this.first = first;
        this.second = second;
      }, /** @lends _.kotlin.Pair.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ')';
        }
      }),
      Triple: Kotlin.createClass(null, function (first, second, third) {
        this.first = first;
        this.second = second;
        this.third = third;
      }, /** @lends _.kotlin.Triple.prototype */ {
        component1: function () {
          return this.first;
        },
        component2: function () {
          return this.second;
        },
        component3: function () {
          return this.third;
        },
        toString: function () {
          return '(' + this.first + ', ' + this.second + ', ' + this.third + ')';
        }
      }),
      toString_h3panj$: function ($receiver) {
        return _.kotlin.makeString_mc2pv1$($receiver, ', ', '[', ']');
      },
      mapValues_lh0hhz$: function ($receiver, transform) {
        return _.kotlin.mapValuesTo_7qivbo$($receiver, new Kotlin.ComplexHashMap(), transform);
      },
      iterator_rscjuh$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [Kotlin.Iterator];
        }, null, {
          hasNext: function () {
            return $receiver.hasMoreElements();
          },
          next: function () {
            return $receiver.nextElement();
          }
        });
      },
      iterator_h40uyb$: function ($receiver) {
        return $receiver;
      },
      EmptyIterableException: Kotlin.createClass(function () {
        return [Kotlin.RuntimeException];
      }, function $fun(it) {
        $fun.baseInitializer.call(this, it + ' is empty');
        this.it = it;
      }),
      DuplicateKeyException: Kotlin.createClass(function () {
        return [Kotlin.RuntimeException];
      }, function $fun(message) {
        if (message === void 0)
          message = 'Duplicate keys detected';
        $fun.baseInitializer.call(this, message);
      }),
      get_size: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      set_f7ra8x$: function ($receiver, key, value) {
        return $receiver.put_wn2jw4$(key, value);
      },
      orEmpty_s8ckw1$: function ($receiver) {
        return $receiver != null ? $receiver : _.kotlin.stdlib_emptyMap();
      },
      contains_6halgi$: function ($receiver, key) {
        return $receiver.containsKey_za3rmp$(key);
      },
      get_key: {value: function ($receiver) {
        return $receiver.getKey();
      }},
      get_value: {value: function ($receiver) {
        return $receiver.getValue();
      }},
      component1: function ($receiver) {
        return $receiver.getKey();
      },
      component2: function ($receiver) {
        return $receiver.getValue();
      },
      getOrElse_9bj33b$: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey_za3rmp$(key)) {
          return $receiver.get_za3rmp$(key);
        }
         else {
          return defaultValue();
        }
      },
      getOrPut_ynyybx$: function ($receiver, key, defaultValue) {
        if ($receiver.containsKey_za3rmp$(key)) {
          return $receiver.get_za3rmp$(key);
        }
         else {
          var answer = defaultValue();
          $receiver.put_wn2jw4$(key, answer);
          return answer;
        }
      },
      iterator_s8ckw1$: function ($receiver) {
        var entrySet = $receiver.entrySet();
        return entrySet.iterator();
      },
      mapValuesTo_7qivbo$: function ($receiver, result, transform) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var e = tmp$0.next();
            var newValue = transform(e);
            result.put_wn2jw4$(_.kotlin.get_key(e), newValue);
          }
        }
        return result;
      },
      putAll_nvpytz$: function ($receiver, values) {
        var tmp$1, tmp$2, tmp$3;
        {
          tmp$1 = values, tmp$2 = tmp$1.length;
          for (var tmp$3 = 0; tmp$3 !== tmp$2; ++tmp$3) {
            var tmp$0 = tmp$1[tmp$3]
            , key = tmp$0.component1()
            , value = tmp$0.component2();
            $receiver.put_wn2jw4$(key, value);
          }
        }
      },
      toMap_cj6vvg$: function ($receiver, map) {
        map.putAll_za3j1t$($receiver);
        return map;
      },
      toMap_uxbsj8$: function ($receiver, map) {
        {
          var tmp$1 = $receiver.iterator();
          while (tmp$1.hasNext()) {
            var tmp$0 = tmp$1.next()
            , key = tmp$0.component1()
            , value = tmp$0.component2();
            if (map.containsKey_za3rmp$(key)) {
              throw new _.kotlin.DuplicateKeyException();
            }
            map.put_wn2jw4$(key, value);
          }
        }
        return map;
      },
      toMap_h3panj$: function ($receiver) {
        return _.kotlin.toMap_uxbsj8$($receiver, new Kotlin.ComplexHashMap());
      },
      mapValues_gld13f$: function ($receiver, transform) {
        return _.kotlin.mapValuesTo_7qivbo$($receiver, new Kotlin.ComplexHashMap(_.kotlin.get_size($receiver)), transform);
      },
      get_lastIndex: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_0: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_1: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_2: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_3: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_4: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_5: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_6: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      get_lastIndex_7: {value: function ($receiver) {
        return $receiver.length - 1;
      }},
      Stream: Kotlin.createTrait(null),
      streamOf_mzrxf8$: function (elements) {
        return _.kotlin.stream_2hx8bi$(elements);
      },
      FilteringStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, sendWhen, predicate) {
        if (sendWhen === void 0)
          sendWhen = true;
        this.stream = stream;
        this.sendWhen = sendWhen;
        this.predicate = predicate;
      }, /** @lends _.kotlin.FilteringStream.prototype */ {
        iterator: function () {
          return _.kotlin.FilteringStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.FilteringStream */ {
        iterator$f: function (this$FilteringStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$FilteringStream.stream.iterator();
          }, {
            computeNext: function () {
              while (this.iterator.hasNext()) {
                var item = this.iterator.next();
                if (Kotlin.equals(this$FilteringStream.predicate(item), this$FilteringStream.sendWhen)) {
                  this.setNext_za3rmp$(item);
                  return;
                }
              }
              this.done();
            }
          });
        }
      }),
      TransformingStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, transformer) {
        this.stream = stream;
        this.transformer = transformer;
      }, /** @lends _.kotlin.TransformingStream.prototype */ {
        iterator: function () {
          return _.kotlin.TransformingStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.TransformingStream */ {
        iterator$f: function (this$TransformingStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$TransformingStream.stream.iterator();
          }, {
            computeNext: function () {
              if (this.iterator.hasNext()) {
                this.setNext_za3rmp$(this$TransformingStream.transformer(this.iterator.next()));
              }
               else {
                this.done();
              }
            }
          });
        }
      }),
      MergingStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream1, stream2, transform) {
        this.stream1 = stream1;
        this.stream2 = stream2;
        this.transform = transform;
      }, /** @lends _.kotlin.MergingStream.prototype */ {
        iterator: function () {
          return _.kotlin.MergingStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.MergingStream */ {
        iterator$f: function (this$MergingStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator1 = this$MergingStream.stream1.iterator();
            this.iterator2 = this$MergingStream.stream2.iterator();
          }, {
            computeNext: function () {
              if (this.iterator1.hasNext() && this.iterator2.hasNext()) {
                this.setNext_za3rmp$(this$MergingStream.transform(this.iterator1.next(), this.iterator2.next()));
              }
               else {
                this.done();
              }
            }
          });
        }
      }),
      FlatteningStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, transformer) {
        this.stream = stream;
        this.transformer = transformer;
      }, /** @lends _.kotlin.FlatteningStream.prototype */ {
        iterator: function () {
          return _.kotlin.FlatteningStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.FlatteningStream */ {
        iterator$f: function (this$FlatteningStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$FlatteningStream.stream.iterator();
            this.itemIterator = null;
          }, {
            computeNext: function () {
              while (this.itemIterator == null) {
                if (!this.iterator.hasNext()) {
                  this.done();
                  break;
                }
                 else {
                  var element = this.iterator.next();
                  var nextItemIterator = this$FlatteningStream.transformer(element).iterator();
                  if (nextItemIterator.hasNext())
                    this.itemIterator = nextItemIterator;
                }
              }
              var currentItemIterator = this.itemIterator;
              if (currentItemIterator == null) {
                this.done();
              }
               else {
                this.setNext_za3rmp$(currentItemIterator.next());
                if (!currentItemIterator.hasNext())
                  this.itemIterator = null;
              }
            }
          });
        }
      }),
      Multistream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (streams) {
        this.streams = streams;
      }, /** @lends _.kotlin.Multistream.prototype */ {
        iterator: function () {
          return _.kotlin.Multistream.iterator$f(this);
        }
      }, /** @lends _.kotlin.Multistream */ {
        iterator$f: function (this$Multistream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$Multistream.streams.iterator();
            this.streamIterator = null;
          }, {
            computeNext: function () {
              while (this.streamIterator == null) {
                if (!this.iterator.hasNext()) {
                  this.done();
                  break;
                }
                 else {
                  var stream = this.iterator.next();
                  var nextStreamIterator = stream.iterator();
                  if (nextStreamIterator.hasNext())
                    this.streamIterator = nextStreamIterator;
                }
              }
              var currentStreamIterator = this.streamIterator;
              if (currentStreamIterator == null) {
                this.done();
              }
               else {
                this.setNext_za3rmp$(currentStreamIterator.next());
                if (!currentStreamIterator.hasNext())
                  this.streamIterator = null;
              }
            }
          });
        }
      }),
      LimitedStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (stream, stopWhen, predicate) {
        if (stopWhen === void 0)
          stopWhen = true;
        this.stream = stream;
        this.stopWhen = stopWhen;
        this.predicate = predicate;
      }, /** @lends _.kotlin.LimitedStream.prototype */ {
        iterator: function () {
          return _.kotlin.LimitedStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.LimitedStream */ {
        iterator$f: function (this$LimitedStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
            this.iterator = this$LimitedStream.stream.iterator();
          }, {
            computeNext: function () {
              if (!this.iterator.hasNext()) {
                this.done();
              }
               else {
                var item = this.iterator.next();
                if (Kotlin.equals(this$LimitedStream.predicate(item), this$LimitedStream.stopWhen)) {
                  this.done();
                }
                 else {
                  this.setNext_za3rmp$(item);
                }
              }
            }
          });
        }
      }),
      FunctionStream: Kotlin.createClass(function () {
        return [_.kotlin.Stream];
      }, function (producer) {
        this.producer = producer;
      }, /** @lends _.kotlin.FunctionStream.prototype */ {
        iterator: function () {
          return _.kotlin.FunctionStream.iterator$f(this);
        }
      }, /** @lends _.kotlin.FunctionStream */ {
        iterator$f: function (this$FunctionStream) {
          return Kotlin.createObject(function () {
            return [_.kotlin.support.AbstractIterator];
          }, function $fun() {
            $fun.baseInitializer.call(this);
          }, {
            computeNext: function () {
              var item = this$FunctionStream.producer();
              if (item == null) {
                this.done();
              }
               else {
                this.setNext_za3rmp$(item);
              }
            }
          });
        }
      }),
      stream_n8bj3p$: function (nextFunction) {
        return new _.kotlin.FunctionStream(nextFunction);
      },
      stream_74f9dl$: function (initialValue, nextFunction) {
        return _.kotlin.stream_n8bj3p$(_.kotlin.toGenerator_n1mtj3$(nextFunction, initialValue));
      },
      stdlib_emptyListClass: Kotlin.createClass(function () {
        return [_.kotlin.List];
      }, null),
      stdlib_emptyList: function () {
        return _.kotlin.stdlib_emptyList_w9bu57$;
      },
      stdlib_emptyMapClass: Kotlin.createClass(function () {
        return [_.kotlin.Map];
      }, null),
      stdlib_emptyMap: function () {
        return _.kotlin.stdlib_emptyMap_h2vi7z$;
      },
      listOf_mzrxf8$: function (values) {
        return values.length === 0 ? _.kotlin.stdlib_emptyList() : _.kotlin.arrayListOf_mzrxf8$(values);
      },
      listOf: function () {
        return _.kotlin.stdlib_emptyList();
      },
      mapOf_mzrxf8$: function (values) {
        return values.length === 0 ? _.kotlin.stdlib_emptyMap() : _.kotlin.hashMapOf_mzrxf8$(values);
      },
      mapOf: function () {
        return _.kotlin.stdlib_emptyMap();
      },
      arrayListOf_mzrxf8$: function (values) {
        return _.kotlin.toCollection_xpmo5j$(values, new Kotlin.ArrayList(values.length));
      },
      hashSetOf_mzrxf8$: function (values) {
        return _.kotlin.toCollection_xpmo5j$(values, new Kotlin.ComplexHashSet(values.length));
      },
      hashMapOf_mzrxf8$: function (values) {
        var answer = new Kotlin.ComplexHashMap(values.length);
        _.kotlin.putAll_nvpytz$(answer, values);
        return answer;
      },
      get_size_1: {value: function ($receiver) {
        return $receiver.size();
      }},
      get_empty_0: {value: function ($receiver) {
        return $receiver.isEmpty();
      }},
      get_indices: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, _.kotlin.get_size_1($receiver) - 1);
      }},
      get_indices_0: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, $receiver - 1);
      }},
      isNotEmpty_tkvw3h$: function ($receiver) {
        return !$receiver.isEmpty();
      },
      get_notEmpty: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_tkvw3h$($receiver);
      }},
      orEmpty_tkvw3h$: function ($receiver) {
        return $receiver != null ? $receiver : _.kotlin.stdlib_emptyList();
      },
      orEmpty_mtvwn1$: function ($receiver) {
        return $receiver != null ? $receiver : _.kotlin.stdlib_emptyList();
      },
      get_first: {value: function ($receiver) {
        return _.kotlin.get_head($receiver);
      }},
      get_last: {value: function ($receiver) {
        var s = _.kotlin.get_size_1($receiver);
        return s > 0 ? $receiver.get_za3lpa$(s - 1) : null;
      }},
      get_lastIndex_8: {value: function ($receiver) {
        return _.kotlin.get_size_1($receiver) - 1;
      }},
      get_head: {value: function ($receiver) {
        return _.kotlin.isNotEmpty_tkvw3h$($receiver) ? $receiver.get_za3lpa$(0) : null;
      }},
      get_tail: {value: function ($receiver) {
        return _.kotlin.drop_odt3s5$($receiver, 1);
      }},
      addAll_wtmfso$: function ($receiver, iterable) {
        {
          if (Kotlin.isType(iterable, _.kotlin.Collection))
            $receiver.addAll_xeylzf$(iterable);
          else {
            var tmp$0 = iterable.iterator();
            while (tmp$0.hasNext()) {
              var item = tmp$0.next();
              $receiver.add_za3rmp$(item);
            }
          }
        }
      },
      addAll_ngcqne$: function ($receiver, stream) {
        {
          var tmp$0 = stream.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            $receiver.add_za3rmp$(item);
          }
        }
      },
      addAll_jl7u2r$: function ($receiver, array) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = array, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.add_za3rmp$(item);
          }
        }
      },
      removeAll_wtmfso$: function ($receiver, iterable) {
        {
          if (Kotlin.isType(iterable, _.kotlin.Collection))
            $receiver.removeAll_xeylzf$(iterable);
          else {
            var tmp$0 = iterable.iterator();
            while (tmp$0.hasNext()) {
              var item = tmp$0.next();
              $receiver.remove_za3rmp$(item);
            }
          }
        }
      },
      removeAll_ngcqne$: function ($receiver, stream) {
        {
          var tmp$0 = stream.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            $receiver.remove_za3rmp$(item);
          }
        }
      },
      removeAll_jl7u2r$: function ($receiver, array) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = array, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.remove_za3rmp$(item);
          }
        }
      },
      retainAll_wtmfso$: function ($receiver, iterable) {
        {
          if (Kotlin.isType(iterable, _.kotlin.Collection))
            $receiver.retainAll_xeylzf$(iterable);
          else
            $receiver.retainAll_xeylzf$(_.kotlin.toSet_h3panj$(iterable));
        }
      },
      retainAll_jl7u2r$: function ($receiver, array) {
        $receiver.retainAll_xeylzf$(_.kotlin.toSet_2hx8bi$(array));
      },
      drop_fdw77o$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_rz0vgy$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_ucmip8$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_cwi0e2$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_3qx2rv$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_2e964m$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_tb5gmf$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_x09c4g$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_7naycm$: function ($receiver, n) {
        if (n >= $receiver.length)
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList($receiver.length - n);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_odt3s5$: function ($receiver, n) {
        if (n >= _.kotlin.get_size_1($receiver))
          return new Kotlin.ArrayList();
        var count = 0;
        var list = new Kotlin.ArrayList(_.kotlin.get_size_1($receiver) - n);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_eq3vf5$: function ($receiver, n) {
        var count = 0;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ >= n)
              list.add_za3rmp$(item);
          }
        }
        return list;
      },
      drop_9ip83h$f: function (count, n) {
        return function (it) {
          return count.v++ >= n;
        };
      },
      drop_9ip83h$: function ($receiver, n) {
        var count = {v: 0};
        return new _.kotlin.FilteringStream($receiver, void 0, _.kotlin.drop_9ip83h$f(count, n));
      },
      drop_n7iutu$: function ($receiver, n) {
        return $receiver.substring(Math.min(n, _.kotlin.get_size_0($receiver)));
      },
      dropWhile_de9h66$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_50zxbw$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_x245au$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_h5ed0c$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_24jijj$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_im8pe8$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_1xntkt$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_3cuuyy$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_p67zio$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_vqr6wr$: function ($receiver, predicate) {
        var yielding = false;
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (yielding)
              list.add_za3rmp$(item);
            else if (!predicate(item)) {
              list.add_za3rmp$(item);
              yielding = true;
            }
          }
        }
        return list;
      },
      dropWhile_9fpnal$f: function (yielding, predicate) {
        return function (it) {
          if (yielding.v)
            return true;
          else if (!predicate(it)) {
            yielding.v = true;
            return true;
          }
           else
            return false;
        };
      },
      dropWhile_9fpnal$: function ($receiver, predicate) {
        var yielding = {v: false};
        return new _.kotlin.FilteringStream($receiver, void 0, _.kotlin.dropWhile_9fpnal$f(yielding, predicate));
      },
      dropWhile_t73kuc$: function ($receiver, predicate) {
        var tmp$0;
        {
          tmp$0 = $receiver.length - 1 + 1;
          for (var index = 0; index !== tmp$0; index++)
            if (!predicate($receiver.charAt(index))) {
              return $receiver.substring(index);
            }
        }
        return '';
      },
      filter_de9h66$: function ($receiver, predicate) {
        return _.kotlin.filterTo_1jm7xb$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_50zxbw$: function ($receiver, predicate) {
        return _.kotlin.filterTo_uoz9bj$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_x245au$: function ($receiver, predicate) {
        return _.kotlin.filterTo_o451x3$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_h5ed0c$: function ($receiver, predicate) {
        return _.kotlin.filterTo_xryfpz$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_24jijj$: function ($receiver, predicate) {
        return _.kotlin.filterTo_6s9ff2$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_im8pe8$: function ($receiver, predicate) {
        return _.kotlin.filterTo_lbhsbh$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_1xntkt$: function ($receiver, predicate) {
        return _.kotlin.filterTo_4m2m1i$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_3cuuyy$: function ($receiver, predicate) {
        return _.kotlin.filterTo_ru2r$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_p67zio$: function ($receiver, predicate) {
        return _.kotlin.filterTo_wion7n$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_vqr6wr$: function ($receiver, predicate) {
        return _.kotlin.filterTo_ywx4y6$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_gld13f$: function ($receiver, predicate) {
        return _.kotlin.filterTo_inv7mm$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filter_9fpnal$: function ($receiver, predicate) {
        return new _.kotlin.FilteringStream($receiver, true, predicate);
      },
      filter_t73kuc$: function ($receiver, predicate) {
        return _.kotlin.filterTo_2ngy80$($receiver, new Kotlin.StringBuilder(), predicate).toString();
      },
      filterNot_de9h66$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_1jm7xb$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_50zxbw$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_uoz9bj$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_x245au$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_o451x3$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_h5ed0c$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_xryfpz$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_24jijj$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_6s9ff2$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_im8pe8$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_lbhsbh$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_1xntkt$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_4m2m1i$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_3cuuyy$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_ru2r$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_p67zio$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_wion7n$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_vqr6wr$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_ywx4y6$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_gld13f$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_inv7mm$($receiver, new Kotlin.ArrayList(), predicate);
      },
      filterNot_9fpnal$: function ($receiver, predicate) {
        return new _.kotlin.FilteringStream($receiver, false, predicate);
      },
      filterNot_t73kuc$: function ($receiver, predicate) {
        return _.kotlin.filterNotTo_2ngy80$($receiver, new Kotlin.StringBuilder(), predicate).toString();
      },
      filterNotNull_2hx8bi$: function ($receiver) {
        return _.kotlin.filterNotNullTo_xpmo5j$($receiver, new Kotlin.ArrayList());
      },
      filterNotNull_h3panj$: function ($receiver) {
        return _.kotlin.filterNotNullTo_4jj70a$($receiver, new Kotlin.ArrayList());
      },
      filterNotNull_pdnvbz$f: function (it) {
        return it == null;
      },
      filterNotNull_pdnvbz$: function ($receiver) {
        return new _.kotlin.FilteringStream($receiver, false, _.kotlin.filterNotNull_pdnvbz$f);
      },
      filterNotNullTo_xpmo5j$: function ($receiver, destination) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null)
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotNullTo_4jj70a$: function ($receiver, destination) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotNullTo_791eew$: function ($receiver, destination) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null)
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_1jm7xb$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_uoz9bj$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_o451x3$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_xryfpz$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_6s9ff2$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_lbhsbh$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_4m2m1i$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_ru2r$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_wion7n$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_ywx4y6$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_inv7mm$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_ggat1c$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterNotTo_2ngy80$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              destination.append(element);
          }
        }
        return destination;
      },
      filterTo_1jm7xb$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_uoz9bj$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_o451x3$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_xryfpz$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_6s9ff2$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_lbhsbh$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_4m2m1i$: function ($receiver, destination, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_ru2r$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_wion7n$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_ywx4y6$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_inv7mm$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_ggat1c$: function ($receiver, destination, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              destination.add_za3rmp$(element);
          }
        }
        return destination;
      },
      filterTo_2ngy80$: function ($receiver, destination, predicate) {
        var tmp$0;
        {
          tmp$0 = $receiver.length - 1 + 1;
          for (var index = 0; index !== tmp$0; index++) {
            var element = $receiver.charAt(index);
            if (predicate(element))
              destination.append(element);
          }
        }
        return destination;
      },
      slice_qxrbi5$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_34aosx$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_dto1g5$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_ldb6x3$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_5ya7ho$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_t349z9$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_3cdrzs$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_cc6qan$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_w98n8l$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver[index]);
          }
        }
        return list;
      },
      slice_h9kosk$: function ($receiver, indices) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            list.add_za3rmp$($receiver.get_za3lpa$(index));
          }
        }
        return list;
      },
      slice_n9t38v$: function ($receiver, indices) {
        var result = new Kotlin.StringBuilder();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var i = tmp$0.next();
            result.append($receiver.charAt(i));
          }
        }
        return result.toString();
      },
      take_fdw77o$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_rz0vgy$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_ucmip8$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_cwi0e2$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_3qx2rv$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_2e964m$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_tb5gmf$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_x09c4g$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_7naycm$: function ($receiver, n) {
        var count = 0;
        var realN = n > $receiver.length ? $receiver.length : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_odt3s5$: function ($receiver, n) {
        var count = 0;
        var realN = n > _.kotlin.get_size_1($receiver) ? _.kotlin.get_size_1($receiver) : n;
        var list = new Kotlin.ArrayList(realN);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === realN)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_eq3vf5$: function ($receiver, n) {
        var count = 0;
        var list = new Kotlin.ArrayList(n);
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (count++ === n)
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      take_9ip83h$f: function (count, n) {
        return function (it) {
          return count.v++ === n;
        };
      },
      take_9ip83h$: function ($receiver, n) {
        var count = {v: 0};
        return new _.kotlin.LimitedStream($receiver, void 0, _.kotlin.take_9ip83h$f(count, n));
      },
      take_n7iutu$: function ($receiver, n) {
        return $receiver.substring(0, Math.min(n, _.kotlin.get_size_0($receiver)));
      },
      takeWhile_de9h66$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_50zxbw$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_x245au$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_h5ed0c$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_24jijj$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_im8pe8$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_1xntkt$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_3cuuyy$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_p67zio$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_vqr6wr$: function ($receiver, predicate) {
        var list = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (!predicate(item))
              break;
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      takeWhile_9fpnal$: function ($receiver, predicate) {
        return new _.kotlin.LimitedStream($receiver, false, predicate);
      },
      takeWhile_t73kuc$: function ($receiver, predicate) {
        var tmp$0;
        {
          tmp$0 = $receiver.length - 1 + 1;
          for (var index = 0; index !== tmp$0; index++)
            if (!predicate($receiver.charAt(index))) {
              return $receiver.substring(0, index);
            }
        }
        return $receiver;
      },
      stream_2hx8bi$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_l1lu5s$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_964n92$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_355nu0$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_bvy38t$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_rjqrz0$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_tmsbgp$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_se6h4y$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_i2lc78$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return Kotlin.arrayIterator($receiver);
          }
        });
      },
      stream_h3panj$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return $receiver.iterator();
          }
        });
      },
      stream_pdnvbz$: function ($receiver) {
        return $receiver;
      },
      stream_pdl1w0$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.Stream];
        }, null, {
          iterator: function () {
            return _.kotlin.iterator_gw00vq$($receiver);
          }
        });
      },
      requireNoNulls_2hx8bi$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver;
      },
      requireNoNulls_h3panj$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver;
      },
      requireNoNulls_mtvwn1$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element == null) {
              throw new Kotlin.IllegalArgumentException('null element found in ' + $receiver);
            }
          }
        }
        return $receiver;
      },
      requireNoNulls_pdnvbz$f: function (this$requireNoNulls) {
        return function (it) {
          if (it == null) {
            throw new Kotlin.IllegalArgumentException('null element found in ' + this$requireNoNulls);
          }
          return true;
        };
      },
      requireNoNulls_pdnvbz$: function ($receiver) {
        return new _.kotlin.FilteringStream($receiver, void 0, _.kotlin.requireNoNulls_pdnvbz$f($receiver));
      },
      flatMap_de9h66$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_1jm7xb$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_50zxbw$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_uoz9bj$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_x245au$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_o451x3$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_h5ed0c$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_xryfpz$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_24jijj$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_6s9ff2$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_im8pe8$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_lbhsbh$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_1xntkt$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_4m2m1i$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_3cuuyy$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_ru2r$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_p67zio$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_wion7n$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_vqr6wr$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_ywx4y6$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_gld13f$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_inv7mm$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_t73kuc$: function ($receiver, transform) {
        return _.kotlin.flatMapTo_caazm9$($receiver, new Kotlin.ArrayList(), transform);
      },
      flatMap_9fpnal$: function ($receiver, transform) {
        return new _.kotlin.FlatteningStream($receiver, transform);
      },
      flatMapTo_1jm7xb$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_uoz9bj$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_o451x3$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_xryfpz$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_6s9ff2$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_lbhsbh$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_4m2m1i$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_ru2r$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_wion7n$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_ywx4y6$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_inv7mm$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_caazm9$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_wtmfso$(destination, list);
          }
        }
        return destination;
      },
      flatMapTo_ggat1c$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var list = transform(element);
            _.kotlin.addAll_ngcqne$(destination, list);
          }
        }
        return destination;
      },
      groupBy_de9h66$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_dmnozt$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_50zxbw$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7i5ojf$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_x245au$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_du5x9d$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_h5ed0c$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_4mj9lf$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_24jijj$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_yr676w$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_im8pe8$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_fktjsp$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_1xntkt$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_8qaat0$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_3cuuyy$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_rnq9xv$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_p67zio$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_yb8vhj$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_vqr6wr$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_cyhgqk$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_gld13f$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_7qivbo$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_9fpnal$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_fsw8ae$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupBy_t73kuc$: function ($receiver, toKey) {
        return _.kotlin.groupByTo_16syit$($receiver, new Kotlin.ComplexHashMap(), toKey);
      },
      groupByTo_dmnozt$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_dmnozt$: function ($receiver, map, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_dmnozt$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_7i5ojf$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_7i5ojf$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_7i5ojf$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_du5x9d$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_du5x9d$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_du5x9d$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_4mj9lf$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_4mj9lf$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_4mj9lf$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_yr676w$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_yr676w$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_yr676w$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_fktjsp$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_fktjsp$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_fktjsp$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_8qaat0$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_8qaat0$: function ($receiver, map, toKey) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_8qaat0$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_rnq9xv$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_rnq9xv$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_rnq9xv$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_yb8vhj$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_yb8vhj$: function ($receiver, map, toKey) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_yb8vhj$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_cyhgqk$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_cyhgqk$: function ($receiver, map, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_cyhgqk$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_7qivbo$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_7qivbo$: function ($receiver, map, toKey) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_7qivbo$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_fsw8ae$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_fsw8ae$: function ($receiver, map, toKey) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_fsw8ae$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      groupByTo_16syit$f: function () {
        return new Kotlin.ArrayList();
      },
      groupByTo_16syit$: function ($receiver, map, toKey) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            var key = toKey(element);
            var list = _.kotlin.getOrPut_ynyybx$(map, key, _.kotlin.groupByTo_16syit$f);
            list.add_za3rmp$(element);
          }
        }
        return map;
      },
      map_de9h66$: function ($receiver, transform) {
        return _.kotlin.mapTo_1jm7xb$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_50zxbw$: function ($receiver, transform) {
        return _.kotlin.mapTo_uoz9bj$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_x245au$: function ($receiver, transform) {
        return _.kotlin.mapTo_o451x3$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_h5ed0c$: function ($receiver, transform) {
        return _.kotlin.mapTo_xryfpz$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_24jijj$: function ($receiver, transform) {
        return _.kotlin.mapTo_6s9ff2$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_im8pe8$: function ($receiver, transform) {
        return _.kotlin.mapTo_lbhsbh$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_1xntkt$: function ($receiver, transform) {
        return _.kotlin.mapTo_4m2m1i$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_3cuuyy$: function ($receiver, transform) {
        return _.kotlin.mapTo_ru2r$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_p67zio$: function ($receiver, transform) {
        return _.kotlin.mapTo_wion7n$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_vqr6wr$: function ($receiver, transform) {
        return _.kotlin.mapTo_ywx4y6$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_gld13f$: function ($receiver, transform) {
        return _.kotlin.mapTo_inv7mm$($receiver, new Kotlin.ArrayList(), transform);
      },
      map_9fpnal$: function ($receiver, transform) {
        return new _.kotlin.TransformingStream($receiver, transform);
      },
      map_t73kuc$: function ($receiver, transform) {
        return _.kotlin.mapTo_caazm9$($receiver, new Kotlin.ArrayList(), transform);
      },
      mapNotNull_de9h66$: function ($receiver, transform) {
        return _.kotlin.mapNotNullTo_1jm7xb$($receiver, new Kotlin.ArrayList(), transform);
      },
      mapNotNull_vqr6wr$: function ($receiver, transform) {
        return _.kotlin.mapNotNullTo_ywx4y6$($receiver, new Kotlin.ArrayList(), transform);
      },
      mapNotNull_9fpnal$f: function (it) {
        return it == null;
      },
      mapNotNull_9fpnal$: function ($receiver, transform) {
        return new _.kotlin.TransformingStream(new _.kotlin.FilteringStream($receiver, false, _.kotlin.mapNotNull_9fpnal$f), transform);
      },
      mapNotNullTo_1jm7xb$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (element != null) {
              destination.add_za3rmp$(transform(element));
            }
          }
        }
        return destination;
      },
      mapNotNullTo_ywx4y6$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null) {
              destination.add_za3rmp$(transform(element));
            }
          }
        }
        return destination;
      },
      mapNotNullTo_ggat1c$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (element != null) {
              destination.add_za3rmp$(transform(element));
            }
          }
        }
        return destination;
      },
      mapTo_1jm7xb$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_uoz9bj$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_o451x3$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_xryfpz$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_6s9ff2$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_lbhsbh$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_4m2m1i$: function ($receiver, destination, transform) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_ru2r$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_wion7n$: function ($receiver, destination, transform) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_ywx4y6$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_inv7mm$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_ggat1c$: function ($receiver, destination, transform) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      mapTo_caazm9$: function ($receiver, destination, transform) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            destination.add_za3rmp$(transform(item));
          }
        }
        return destination;
      },
      withIndices_2hx8bi$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_2hx8bi$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_1jm7xb$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_2hx8bi$f(index));
      },
      withIndices_l1lu5s$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_l1lu5s$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_uoz9bj$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_l1lu5s$f(index));
      },
      withIndices_964n92$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_964n92$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_o451x3$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_964n92$f(index));
      },
      withIndices_355nu0$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_355nu0$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_xryfpz$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_355nu0$f(index));
      },
      withIndices_bvy38t$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_bvy38t$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_6s9ff2$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_bvy38t$f(index));
      },
      withIndices_rjqrz0$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_rjqrz0$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_lbhsbh$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_rjqrz0$f(index));
      },
      withIndices_tmsbgp$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_tmsbgp$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_4m2m1i$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_tmsbgp$f(index));
      },
      withIndices_se6h4y$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_se6h4y$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_ru2r$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_se6h4y$f(index));
      },
      withIndices_i2lc78$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_i2lc78$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_wion7n$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_i2lc78$f(index));
      },
      withIndices_h3panj$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_h3panj$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_ywx4y6$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_h3panj$f(index));
      },
      withIndices_pdnvbz$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_pdnvbz$: function ($receiver) {
        var index = {v: 0};
        return new _.kotlin.TransformingStream($receiver, _.kotlin.withIndices_pdnvbz$f(index));
      },
      withIndices_pdl1w0$f: function (index) {
        return function (it) {
          return _.kotlin.to_l1ob02$(index.v++, it);
        };
      },
      withIndices_pdl1w0$: function ($receiver) {
        var index = {v: 0};
        return _.kotlin.mapTo_caazm9$($receiver, new Kotlin.ArrayList(), _.kotlin.withIndices_pdl1w0$f(index));
      },
      distinct_2hx8bi$: function ($receiver) {
        return _.kotlin.toMutableSet_2hx8bi$($receiver);
      },
      distinct_l1lu5s$: function ($receiver) {
        return _.kotlin.toMutableSet_l1lu5s$($receiver);
      },
      distinct_964n92$: function ($receiver) {
        return _.kotlin.toMutableSet_964n92$($receiver);
      },
      distinct_355nu0$: function ($receiver) {
        return _.kotlin.toMutableSet_355nu0$($receiver);
      },
      distinct_bvy38t$: function ($receiver) {
        return _.kotlin.toMutableSet_bvy38t$($receiver);
      },
      distinct_rjqrz0$: function ($receiver) {
        return _.kotlin.toMutableSet_rjqrz0$($receiver);
      },
      distinct_tmsbgp$: function ($receiver) {
        return _.kotlin.toMutableSet_tmsbgp$($receiver);
      },
      distinct_se6h4y$: function ($receiver) {
        return _.kotlin.toMutableSet_se6h4y$($receiver);
      },
      distinct_i2lc78$: function ($receiver) {
        return _.kotlin.toMutableSet_i2lc78$($receiver);
      },
      distinct_h3panj$: function ($receiver) {
        return _.kotlin.toMutableSet_h3panj$($receiver);
      },
      intersect_qxrbi5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_2hx8bi$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_34aosx$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_l1lu5s$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_dto1g5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_964n92$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_ldb6x3$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_355nu0$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_5ya7ho$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_bvy38t$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_t349z9$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_rjqrz0$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_3cdrzs$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_tmsbgp$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_cc6qan$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_se6h4y$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_w98n8l$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_i2lc78$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      intersect_975xw0$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_h3panj$($receiver);
        _.kotlin.retainAll_wtmfso$(set, other);
        return set;
      },
      subtract_qxrbi5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_2hx8bi$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_34aosx$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_l1lu5s$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_dto1g5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_964n92$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_ldb6x3$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_355nu0$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_5ya7ho$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_bvy38t$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_t349z9$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_rjqrz0$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_3cdrzs$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_tmsbgp$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_cc6qan$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_se6h4y$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_w98n8l$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_i2lc78$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      subtract_975xw0$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_h3panj$($receiver);
        _.kotlin.removeAll_wtmfso$(set, other);
        return set;
      },
      toMutableSet_2hx8bi$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_l1lu5s$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_964n92$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_355nu0$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_bvy38t$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_rjqrz0$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_tmsbgp$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_se6h4y$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_i2lc78$: function ($receiver) {
        var set = new Kotlin.LinkedHashSet($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            set.add_za3rmp$(item);
          }
        }
        return set;
      },
      toMutableSet_h3panj$: function ($receiver) {
        var tmp$0;
        if (Kotlin.isType($receiver, _.kotlin.Collection))
          tmp$0 = _.java.util.LinkedHashSet_xeylzf$($receiver);
        else
          tmp$0 = _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.LinkedHashSet());
        return tmp$0;
      },
      union_qxrbi5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_2hx8bi$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_34aosx$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_l1lu5s$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_dto1g5$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_964n92$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_ldb6x3$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_355nu0$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_5ya7ho$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_bvy38t$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_t349z9$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_rjqrz0$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_3cdrzs$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_tmsbgp$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_cc6qan$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_se6h4y$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_w98n8l$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_i2lc78$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      union_975xw0$: function ($receiver, other) {
        var set = _.kotlin.toMutableSet_h3panj$($receiver);
        _.kotlin.addAll_wtmfso$(set, other);
        return set;
      },
      f: function (this$toGenerator, nextValue) {
        return function (result) {
          nextValue.v = this$toGenerator(result);
          return result;
        };
      },
      toGenerator_n1mtj3$f: function (nextValue, this$toGenerator) {
        return function () {
          var tmp$0;
          return (tmp$0 = nextValue.v) != null ? _.kotlin.let_j58jph$(tmp$0, _.kotlin.f(this$toGenerator, nextValue)) : null;
        };
      },
      toGenerator_n1mtj3$: function ($receiver, initialValue) {
        var nextValue = {v: initialValue};
        return _.kotlin.toGenerator_n1mtj3$f(nextValue, $receiver);
      },
      to_l1ob02$: function ($receiver, that) {
        return new _.kotlin.Pair($receiver, that);
      },
      run_n8bj3p$: function (f) {
        return f();
      },
      with_rc1ekn$: function (receiver, f) {
        return f.call(receiver);
      },
      let_j58jph$: function ($receiver, f) {
        return f($receiver);
      },
      downTo_9q324c$: function ($receiver, to) {
        return new _.kotlin.ByteProgression($receiver, to, -1);
      },
      downTo_9q3c22$: function ($receiver, to) {
        return new _.kotlin.CharProgression($receiver.toChar(), to, -1);
      },
      downTo_hl85u0$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to, -1);
      },
      downTo_y20kcl$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_9q98fk$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_he5dns$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_tylosb$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_sd8xje$: function ($receiver, to) {
        return new _.kotlin.CharProgression($receiver, to.toChar(), -1);
      },
      downTo_sd97h4$: function ($receiver, to) {
        return new _.kotlin.CharProgression($receiver, to, -1);
      },
      downTo_radrzu$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver.toShort(), to, -1);
      },
      downTo_v5vllf$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver.toInt(), to, -1);
      },
      downTo_sdf3um$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_r3aztm$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_df7tnx$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_9r634a$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to, -1);
      },
      downTo_9r5t6k$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to.toShort(), -1);
      },
      downTo_i0qws2$: function ($receiver, to) {
        return new _.kotlin.ShortProgression($receiver, to, -1);
      },
      downTo_rt69vj$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_9qzwt2$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_i7toya$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_2lzxtr$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_2jcion$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_2jc8qx$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to.toInt(), -1);
      },
      downTo_7dmh8l$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_rksjo2$: function ($receiver, to) {
        return new Kotlin.NumberProgression($receiver, to, -1);
      },
      downTo_2j6cdf$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver.toLong(), to, -(1).toLong());
      },
      downTo_7kp9et$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_mmqya6$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_jzdo0$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_jznlq$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_hgibo4$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_mw85q1$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to.toLong(), -(1).toLong());
      },
      downTo_k5jz8$: function ($receiver, to) {
        return new _.kotlin.LongProgression($receiver, to, -(1).toLong());
      },
      downTo_h9fjhw$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver.toFloat(), to, -1);
      },
      downTo_y0unuv$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver.toDouble(), to, -1.0);
      },
      downTo_kquaae$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_kquk84$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_433x66$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_jyaijj$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_kr0glm$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to.toFloat(), -1);
      },
      downTo_3w14zy$: function ($receiver, to) {
        return new _.kotlin.FloatProgression($receiver, to, -1);
      },
      downTo_mdktgh$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_stl18b$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_stkral$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_u6e7j3$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_aiyy8i$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_steux3$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to.toDouble(), -1.0);
      },
      downTo_tzbfcv$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      downTo_541hxq$: function ($receiver, to) {
        return new _.kotlin.DoubleProgression($receiver, to, -1.0);
      },
      merge_91t4nf$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_zb2wxp$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_au6o65$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_resd0r$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_6lndoa$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_g5oapj$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_f32dm2$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_oi38kv$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_pn4jvt$: function ($receiver, array, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_tl80ny$: function ($receiver, array, transform) {
        var first = $receiver.iterator();
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_29xg59$: function ($receiver, array, transform) {
        var first = _.kotlin.iterator_gw00vq$($receiver);
        var second = Kotlin.arrayIterator(array);
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_7bg1pg$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_vzyamu$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_r76i9w$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_d5bgvi$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_d6i5gz$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_y6emce$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_k6l5td$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_ksuah4$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_eqb4ua$: function ($receiver, other, transform) {
        var first = Kotlin.arrayIterator($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_hqmbqh$: function ($receiver, other, transform) {
        var first = $receiver.iterator();
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_q03f9y$: function ($receiver, other, transform) {
        var first = _.kotlin.iterator_gw00vq$($receiver);
        var second = other.iterator();
        var list = _.kotlin.arrayListOf_mzrxf8$([]);
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(transform(first.next(), second.next()));
        }
        return list;
      },
      merge_28jw99$: function ($receiver, stream, transform) {
        return new _.kotlin.MergingStream($receiver, stream, transform);
      },
      partition_de9h66$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_50zxbw$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_x245au$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_h5ed0c$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_24jijj$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_im8pe8$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_1xntkt$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_3cuuyy$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_p67zio$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_vqr6wr$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_9fpnal$: function ($receiver, predicate) {
        var first = new Kotlin.ArrayList();
        var second = new Kotlin.ArrayList();
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.add_za3rmp$(element);
            }
             else {
              second.add_za3rmp$(element);
            }
          }
        }
        return new _.kotlin.Pair(first, second);
      },
      partition_t73kuc$: function ($receiver, predicate) {
        var first = new Kotlin.StringBuilder();
        var second = new Kotlin.StringBuilder();
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              first.append(element);
            }
             else {
              second.append(element);
            }
          }
        }
        return new _.kotlin.Pair(first.toString(), second.toString());
      },
      plus_bctcxa$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_2hx8bi$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_w5fksc$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_l1lu5s$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_qsh4fe$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_964n92$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_uy8ycc$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_355nu0$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_kvfz4v$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_bvy38t$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_tev20g$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_rjqrz0$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_wgl9xf$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_tmsbgp$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_v0fo6u$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_se6h4y$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_wshjbk$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_i2lc78$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_fnn263$: function ($receiver, array) {
        var answer = _.kotlin.toArrayList_h3panj$($receiver);
        _.kotlin.addAll_jl7u2r$(answer, array);
        return answer;
      },
      plus_qxrbi5$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_2hx8bi$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_34aosx$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_l1lu5s$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_dto1g5$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_964n92$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_ldb6x3$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_355nu0$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_5ya7ho$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_bvy38t$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_t349z9$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_rjqrz0$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_3cdrzs$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_tmsbgp$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_cc6qan$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_se6h4y$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_w98n8l$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_i2lc78$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_975xw0$: function ($receiver, collection) {
        var answer = _.kotlin.toArrayList_h3panj$($receiver);
        _.kotlin.addAll_wtmfso$(answer, collection);
        return answer;
      },
      plus_1lsq3i$: function ($receiver, collection) {
        return new _.kotlin.Multistream(_.kotlin.streamOf_mzrxf8$([$receiver, _.kotlin.stream_h3panj$(collection)]));
      },
      plus_fdw1a9$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_2hx8bi$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_bsmqrv$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_l1lu5s$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_hgt5d7$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_964n92$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_q79yhh$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_355nu0$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_96a6a3$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_bvy38t$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_thi4tv$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_rjqrz0$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_tb5gmf$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_tmsbgp$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_ssilt7$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_se6h4y$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_x27eb7$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_i2lc78$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_eq3phq$: function ($receiver, element) {
        var answer = _.kotlin.toArrayList_h3panj$($receiver);
        answer.add_za3rmp$(element);
        return answer;
      },
      plus_9ipe0w$: function ($receiver, element) {
        return new _.kotlin.Multistream(_.kotlin.streamOf_mzrxf8$([$receiver, _.kotlin.streamOf_mzrxf8$([element])]));
      },
      plus_y4w53o$: function ($receiver, stream) {
        return new _.kotlin.Multistream(_.kotlin.streamOf_mzrxf8$([$receiver, stream]));
      },
      zip_bctcxa$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_bctcxa$: function ($receiver, array) {
        return _.kotlin.merge_91t4nf$($receiver, array, _.kotlin.zip_bctcxa$f);
      },
      zip_w5fksc$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_w5fksc$: function ($receiver, array) {
        return _.kotlin.merge_zb2wxp$($receiver, array, _.kotlin.zip_w5fksc$f);
      },
      zip_qsh4fe$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_qsh4fe$: function ($receiver, array) {
        return _.kotlin.merge_au6o65$($receiver, array, _.kotlin.zip_qsh4fe$f);
      },
      zip_uy8ycc$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_uy8ycc$: function ($receiver, array) {
        return _.kotlin.merge_resd0r$($receiver, array, _.kotlin.zip_uy8ycc$f);
      },
      zip_kvfz4v$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_kvfz4v$: function ($receiver, array) {
        return _.kotlin.merge_6lndoa$($receiver, array, _.kotlin.zip_kvfz4v$f);
      },
      zip_tev20g$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_tev20g$: function ($receiver, array) {
        return _.kotlin.merge_g5oapj$($receiver, array, _.kotlin.zip_tev20g$f);
      },
      zip_wgl9xf$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_wgl9xf$: function ($receiver, array) {
        return _.kotlin.merge_f32dm2$($receiver, array, _.kotlin.zip_wgl9xf$f);
      },
      zip_v0fo6u$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_v0fo6u$: function ($receiver, array) {
        return _.kotlin.merge_oi38kv$($receiver, array, _.kotlin.zip_v0fo6u$f);
      },
      zip_wshjbk$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_wshjbk$: function ($receiver, array) {
        return _.kotlin.merge_pn4jvt$($receiver, array, _.kotlin.zip_wshjbk$f);
      },
      zip_fnn263$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_fnn263$: function ($receiver, array) {
        return _.kotlin.merge_tl80ny$($receiver, array, _.kotlin.zip_fnn263$f);
      },
      zip_ny9o$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_ny9o$: function ($receiver, array) {
        return _.kotlin.merge_29xg59$($receiver, array, _.kotlin.zip_ny9o$f);
      },
      zip_qxrbi5$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_qxrbi5$: function ($receiver, other) {
        return _.kotlin.merge_7bg1pg$($receiver, other, _.kotlin.zip_qxrbi5$f);
      },
      zip_34aosx$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_34aosx$: function ($receiver, other) {
        return _.kotlin.merge_vzyamu$($receiver, other, _.kotlin.zip_34aosx$f);
      },
      zip_dto1g5$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_dto1g5$: function ($receiver, other) {
        return _.kotlin.merge_r76i9w$($receiver, other, _.kotlin.zip_dto1g5$f);
      },
      zip_ldb6x3$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_ldb6x3$: function ($receiver, other) {
        return _.kotlin.merge_d5bgvi$($receiver, other, _.kotlin.zip_ldb6x3$f);
      },
      zip_5ya7ho$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_5ya7ho$: function ($receiver, other) {
        return _.kotlin.merge_d6i5gz$($receiver, other, _.kotlin.zip_5ya7ho$f);
      },
      zip_t349z9$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_t349z9$: function ($receiver, other) {
        return _.kotlin.merge_y6emce$($receiver, other, _.kotlin.zip_t349z9$f);
      },
      zip_3cdrzs$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_3cdrzs$: function ($receiver, other) {
        return _.kotlin.merge_k6l5td$($receiver, other, _.kotlin.zip_3cdrzs$f);
      },
      zip_cc6qan$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_cc6qan$: function ($receiver, other) {
        return _.kotlin.merge_ksuah4$($receiver, other, _.kotlin.zip_cc6qan$f);
      },
      zip_w98n8l$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_w98n8l$: function ($receiver, other) {
        return _.kotlin.merge_eqb4ua$($receiver, other, _.kotlin.zip_w98n8l$f);
      },
      zip_975xw0$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_975xw0$: function ($receiver, other) {
        return _.kotlin.merge_hqmbqh$($receiver, other, _.kotlin.zip_975xw0$f);
      },
      zip_n9t38v$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_n9t38v$: function ($receiver, other) {
        return _.kotlin.merge_q03f9y$($receiver, other, _.kotlin.zip_n9t38v$f);
      },
      zip_94jgcu$: function ($receiver, other) {
        var first = _.kotlin.iterator_gw00vq$($receiver);
        var second = _.kotlin.iterator_gw00vq$(other);
        var list = new Kotlin.ArrayList();
        while (first.hasNext() && second.hasNext()) {
          list.add_za3rmp$(_.kotlin.to_l1ob02$(first.next(), second.next()));
        }
        return list;
      },
      zip_y4w53o$f: function (t1, t2) {
        return _.kotlin.to_l1ob02$(t1, t2);
      },
      zip_y4w53o$: function ($receiver, stream) {
        return new _.kotlin.MergingStream($receiver, stream, _.kotlin.zip_y4w53o$f);
      },
      contains_fdw1a9$: function ($receiver, element) {
        return _.kotlin.indexOf_fdw1a9$($receiver, element) >= 0;
      },
      contains_bsmqrv$: function ($receiver, element) {
        return _.kotlin.indexOf_bsmqrv$($receiver, element) >= 0;
      },
      contains_hgt5d7$: function ($receiver, element) {
        return _.kotlin.indexOf_hgt5d7$($receiver, element) >= 0;
      },
      contains_q79yhh$: function ($receiver, element) {
        return _.kotlin.indexOf_q79yhh$($receiver, element) >= 0;
      },
      contains_96a6a3$: function ($receiver, element) {
        return _.kotlin.indexOf_96a6a3$($receiver, element) >= 0;
      },
      contains_thi4tv$: function ($receiver, element) {
        return _.kotlin.indexOf_thi4tv$($receiver, element) >= 0;
      },
      contains_tb5gmf$: function ($receiver, element) {
        return _.kotlin.indexOf_tb5gmf$($receiver, element) >= 0;
      },
      contains_ssilt7$: function ($receiver, element) {
        return _.kotlin.indexOf_ssilt7$($receiver, element) >= 0;
      },
      contains_x27eb7$: function ($receiver, element) {
        return _.kotlin.indexOf_x27eb7$($receiver, element) >= 0;
      },
      contains_eq3phq$: function ($receiver, element) {
        if (Kotlin.isType($receiver, _.kotlin.Collection))
          return $receiver.contains_za3rmp$(element);
        return _.kotlin.indexOf_eq3phq$($receiver, element) >= 0;
      },
      contains_9ipe0w$: function ($receiver, element) {
        if (Kotlin.isType($receiver, _.kotlin.Collection))
          return $receiver.contains_za3rmp$(element);
        return _.kotlin.indexOf_9ipe0w$($receiver, element) >= 0;
      },
      elementAt_fdw77o$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_rz0vgy$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_ucmip8$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_cwi0e2$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_3qx2rv$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_2e964m$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_tb5gmf$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_x09c4g$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_7naycm$: function ($receiver, index) {
        return $receiver[index];
      },
      elementAt_eq3vf5$: function ($receiver, index) {
        if (Kotlin.isType($receiver, _.kotlin.List))
          return $receiver.get_za3lpa$(index);
        var iterator = $receiver.iterator();
        var count = 0;
        while (iterator.hasNext()) {
          var element = iterator.next();
          if (index === count++)
            return element;
        }
        throw new RangeError("Collection doesn't contain element at index");
      },
      elementAt_ureun9$: function ($receiver, index) {
        return $receiver.get_za3lpa$(index);
      },
      elementAt_9ip83h$: function ($receiver, index) {
        var iterator = $receiver.iterator();
        var count = 0;
        while (iterator.hasNext()) {
          var element = iterator.next();
          if (index === count++)
            return element;
        }
        throw new RangeError("Collection doesn't contain element at index");
      },
      elementAt_n7iutu$: function ($receiver, index) {
        return $receiver.charAt(index);
      },
      first_2hx8bi$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_l1lu5s$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_964n92$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_355nu0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_bvy38t$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_rjqrz0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_tmsbgp$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_se6h4y$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_i2lc78$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[0];
      },
      first_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            return iterator.next();
          }
        }
      },
      first_mtvwn1$: function ($receiver) {
        if (_.kotlin.get_size_1($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.get_za3lpa$(0);
      },
      first_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            return iterator.next();
          }
        }
      },
      first_pdl1w0$: function ($receiver) {
        if (_.kotlin.get_size_0($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.charAt(0);
      },
      first_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      first_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        throw new Kotlin.NoSuchElementException('No element matching predicate was found');
      },
      firstOrNull_2hx8bi$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_l1lu5s$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_964n92$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_355nu0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_bvy38t$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_rjqrz0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_tmsbgp$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_se6h4y$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_i2lc78$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[0] : null;
      },
      firstOrNull_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              return null;
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            return iterator.next();
          }
        }
      },
      firstOrNull_mtvwn1$: function ($receiver) {
        return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(0) : null;
      },
      firstOrNull_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              return null;
            else
              return $receiver.get_za3lpa$(0);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            return iterator.next();
          }
        }
      },
      firstOrNull_pdl1w0$: function ($receiver) {
        return _.kotlin.get_size_0($receiver) > 0 ? $receiver.charAt(0) : null;
      },
      firstOrNull_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      firstOrNull_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return element;
          }
        }
        return null;
      },
      indexOf_fdw1a9$: function ($receiver, element) {
        if (element == null) {
          var tmp$0, tmp$1, tmp$2, tmp$3;
          {
            tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
            for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
              if ($receiver[index] == null) {
                return index;
              }
            }
          }
        }
         else {
          var tmp$4, tmp$5, tmp$6, tmp$7;
          {
            tmp$4 = Kotlin.arrayIndices($receiver), tmp$5 = tmp$4.start, tmp$6 = tmp$4.end, tmp$7 = tmp$4.increment;
            for (var index_0 = tmp$5; index_0 <= tmp$6; index_0 += tmp$7) {
              if (Kotlin.equals(element, $receiver[index_0])) {
                return index_0;
              }
            }
          }
        }
        return -1;
      },
      indexOf_bsmqrv$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (Kotlin.equals(element, $receiver[index])) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_hgt5d7$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_q79yhh$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_96a6a3$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_thi4tv$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_tb5gmf$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_ssilt7$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_x27eb7$: function ($receiver, element) {
        var tmp$0, tmp$1, tmp$2, tmp$3;
        {
          tmp$0 = Kotlin.arrayIndices($receiver), tmp$1 = tmp$0.start, tmp$2 = tmp$0.end, tmp$3 = tmp$0.increment;
          for (var index = tmp$1; index <= tmp$2; index += tmp$3) {
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      indexOf_eq3phq$: function ($receiver, element) {
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              return index;
            index++;
          }
        }
        return -1;
      },
      indexOf_9ipe0w$: function ($receiver, element) {
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              return index;
            index++;
          }
        }
        return -1;
      },
      last_2hx8bi$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_l1lu5s$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_964n92$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_355nu0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_bvy38t$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_rjqrz0$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_tmsbgp$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_se6h4y$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_i2lc78$: function ($receiver) {
        if ($receiver.length === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver[$receiver.length - 1];
      },
      last_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      last_mtvwn1$: function ($receiver) {
        if (_.kotlin.get_size_1($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1);
      },
      last_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List)) {
            if (_.kotlin.get_size_1($receiver) === 0)
              throw new Kotlin.NoSuchElementException('Collection is empty');
            else
              return $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1);
          }
           else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      last_pdl1w0$: function ($receiver) {
        if (_.kotlin.get_size_0($receiver) === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        return $receiver.charAt(_.kotlin.get_size_0($receiver) - 1);
      },
      last_de9h66$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last;
      },
      last_50zxbw$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_x245au$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_h5ed0c$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_24jijj$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_im8pe8$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_1xntkt$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_3cuuyy$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_p67zio$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      last_vqr6wr$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last;
      },
      last_9fpnal$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last;
      },
      last_t73kuc$: function ($receiver, predicate) {
        var last = null;
        var found = false;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return last != null ? last : Kotlin.throwNPE();
      },
      lastIndexOf_fdw1a9$: function ($receiver, element) {
        if (element == null) {
          {
            var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
            while (tmp$0.hasNext()) {
              var index = tmp$0.next();
              if ($receiver[index] == null) {
                return index;
              }
            }
          }
        }
         else {
          {
            var tmp$1 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
            while (tmp$1.hasNext()) {
              var index_0 = tmp$1.next();
              if (Kotlin.equals(element, $receiver[index_0])) {
                return index_0;
              }
            }
          }
        }
        return -1;
      },
      lastIndexOf_bsmqrv$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (Kotlin.equals(element, $receiver[index])) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_hgt5d7$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_q79yhh$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_96a6a3$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_thi4tv$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_tb5gmf$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_ssilt7$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_x27eb7$: function ($receiver, element) {
        {
          var tmp$0 = _.kotlin.reverse_h3panj$(Kotlin.arrayIndices($receiver)).iterator();
          while (tmp$0.hasNext()) {
            var index = tmp$0.next();
            if (element === $receiver[index]) {
              return index;
            }
          }
        }
        return -1;
      },
      lastIndexOf_eq3phq$: function ($receiver, element) {
        var lastIndex = -1;
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              lastIndex = index;
            index++;
          }
        }
        return lastIndex;
      },
      lastIndexOf_ureopu$: function ($receiver, element) {
        if (element == null) {
          {
            var tmp$0 = _.kotlin.reverse_h3panj$(_.kotlin.get_indices($receiver)).iterator();
            while (tmp$0.hasNext()) {
              var index = tmp$0.next();
              if ($receiver.get_za3lpa$(index) == null) {
                return index;
              }
            }
          }
        }
         else {
          {
            var tmp$1 = _.kotlin.reverse_h3panj$(_.kotlin.get_indices($receiver)).iterator();
            while (tmp$1.hasNext()) {
              var index_0 = tmp$1.next();
              if (Kotlin.equals(element, $receiver.get_za3lpa$(index_0))) {
                return index_0;
              }
            }
          }
        }
        return -1;
      },
      lastIndexOf_9ipe0w$: function ($receiver, element) {
        var lastIndex = -1;
        var index = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            if (Kotlin.equals(element, item))
              lastIndex = index;
            index++;
          }
        }
        return lastIndex;
      },
      lastOrNull_2hx8bi$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_l1lu5s$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_964n92$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_355nu0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_bvy38t$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_rjqrz0$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_tmsbgp$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_se6h4y$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_i2lc78$: function ($receiver) {
        return $receiver.length > 0 ? $receiver[$receiver.length - 1] : null;
      },
      lastOrNull_h3panj$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1) : null;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      lastOrNull_mtvwn1$: function ($receiver) {
        return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1) : null;
      },
      lastOrNull_pdnvbz$: function ($receiver) {
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return _.kotlin.get_size_1($receiver) > 0 ? $receiver.get_za3lpa$(_.kotlin.get_size_1($receiver) - 1) : null;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var last = iterator.next();
            while (iterator.hasNext())
              last = iterator.next();
            return last;
          }
        }
      },
      lastOrNull_pdl1w0$: function ($receiver) {
        return _.kotlin.get_size_0($receiver) > 0 ? $receiver.charAt(_.kotlin.get_size_0($receiver) - 1) : null;
      },
      lastOrNull_de9h66$: function ($receiver, predicate) {
        var last = null;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_50zxbw$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_x245au$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_h5ed0c$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_24jijj$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_im8pe8$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_1xntkt$: function ($receiver, predicate) {
        var last = null;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_3cuuyy$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_p67zio$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_vqr6wr$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_9fpnal$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      lastOrNull_t73kuc$: function ($receiver, predicate) {
        var last = null;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              last = element;
            }
          }
        }
        return last;
      },
      single_2hx8bi$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_l1lu5s$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_964n92$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_355nu0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_bvy38t$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_rjqrz0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_tmsbgp$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_se6h4y$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_i2lc78$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_h3panj$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      single_mtvwn1$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_pdnvbz$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              throw new Kotlin.NoSuchElementException('Collection is empty');
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      single_pdl1w0$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_0($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.charAt(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      single_de9h66$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single;
      },
      single_50zxbw$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_x245au$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_h5ed0c$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_24jijj$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_im8pe8$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_1xntkt$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_3cuuyy$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_p67zio$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      single_vqr6wr$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single;
      },
      single_9fpnal$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single;
      },
      single_t73kuc$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          throw new Kotlin.NoSuchElementException("Collection doesn't contain any element matching predicate");
        return single != null ? single : Kotlin.throwNPE();
      },
      singleOrNull_2hx8bi$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_l1lu5s$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_964n92$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_355nu0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_bvy38t$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_rjqrz0$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_tmsbgp$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_se6h4y$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_i2lc78$: function ($receiver) {
        var tmp$0 = $receiver.length, tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver[0];
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_h3panj$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          tmp$1 = null;
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      singleOrNull_mtvwn1$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_pdnvbz$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_1($receiver), tmp$1;
        if (tmp$0 === 0)
          tmp$1 = null;
        else if (tmp$0 === 1)
          tmp$1 = $receiver.get_za3lpa$(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        {
          if (Kotlin.isType($receiver, _.kotlin.List))
            return tmp$1;
          else {
            var iterator = $receiver.iterator();
            if (!iterator.hasNext())
              return null;
            var single = iterator.next();
            if (iterator.hasNext())
              throw new Kotlin.IllegalArgumentException('Collection has more than one element');
            return single;
          }
        }
      },
      singleOrNull_pdl1w0$: function ($receiver) {
        var tmp$0 = _.kotlin.get_size_0($receiver), tmp$1;
        if (tmp$0 === 0)
          throw new Kotlin.NoSuchElementException('Collection is empty');
        else if (tmp$0 === 1)
          tmp$1 = $receiver.charAt(0);
        else
          throw new Kotlin.IllegalArgumentException('Collection has more than one element');
        return tmp$1;
      },
      singleOrNull_de9h66$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_50zxbw$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_x245au$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_h5ed0c$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_24jijj$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_im8pe8$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_1xntkt$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_3cuuyy$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_p67zio$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_vqr6wr$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_9fpnal$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      singleOrNull_t73kuc$: function ($receiver, predicate) {
        var single = null;
        var found = false;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element)) {
              if (found)
                throw new Kotlin.IllegalArgumentException('Collection contains more than one matching element');
              single = element;
              found = true;
            }
          }
        }
        if (!found)
          return null;
        return single;
      },
      times_97ovpz$: function ($receiver, body) {
        var count = $receiver;
        while (count > 0) {
          body();
          count--;
        }
      },
      require_eltq40$: function (value, message) {
        if (message === void 0)
          message = 'Failed requirement';
        if (!value) {
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
      },
      require_zgzqbg$: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
      },
      requireNotNull_wn2jw4$: function (value, message) {
        if (message === void 0)
          message = 'Required value was null';
        if (value == null) {
          throw new Kotlin.IllegalArgumentException(message.toString());
        }
         else {
          return value;
        }
      },
      check_eltq40$: function (value, message) {
        if (message === void 0)
          message = 'Check failed';
        if (!value) {
          throw new Kotlin.IllegalStateException(message.toString());
        }
      },
      check_zgzqbg$: function (value, lazyMessage) {
        if (!value) {
          var message = lazyMessage();
          throw new Kotlin.IllegalStateException(message.toString());
        }
      },
      checkNotNull_hwpqgh$: function (value, message) {
        if (message === void 0)
          message = 'Required value was null';
        if (value == null) {
          throw new Kotlin.IllegalStateException(message);
        }
         else {
          return value;
        }
      },
      error_61zpoe$: function (message) {
        throw new Kotlin.RuntimeException(message);
      },
      toArrayList_2hx8bi$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_l1lu5s$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_964n92$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_355nu0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_bvy38t$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_rjqrz0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_tmsbgp$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_se6h4y$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_i2lc78$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toArrayList_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.ArrayList());
      },
      toArrayList_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.ArrayList());
      },
      toArrayList_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.ArrayList());
      },
      toCollection_xpmo5j$: function ($receiver, collection) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_aaeveh$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_d1lgh$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_ba3pld$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_enu0mi$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_gk003p$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_mglpxq$: function ($receiver, collection) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_vus1ud$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_5k8uqj$: function ($receiver, collection) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_4jj70a$: function ($receiver, collection) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_791eew$: function ($receiver, collection) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toCollection_j1020p$: function ($receiver, collection) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            collection.add_za3rmp$(item);
          }
        }
        return collection;
      },
      toHashSet_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.ComplexHashSet());
      },
      toHashSet_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toHashSet_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.ComplexHashSet());
      },
      toHashSet_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.ComplexHashSet());
      },
      toHashSet_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.PrimitiveHashSet());
      },
      toLinkedList_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.LinkedList());
      },
      toLinkedList_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.LinkedList());
      },
      toList_s8ckw1$: function ($receiver) {
        var result = new Kotlin.ArrayList(_.kotlin.get_size($receiver));
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            result.add_za3rmp$(item);
          }
        }
        return result;
      },
      toList_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.ArrayList());
      },
      toList_l1lu5s$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_964n92$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_355nu0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_bvy38t$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_rjqrz0$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_tmsbgp$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_se6h4y$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_i2lc78$: function ($receiver) {
        var list = new Kotlin.ArrayList($receiver.length);
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var item = tmp$0.next();
            list.add_za3rmp$(item);
          }
        }
        return list;
      },
      toList_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.ArrayList());
      },
      toList_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.ArrayList());
      },
      toList_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.ArrayList());
      },
      toSet_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.LinkedHashSet());
      },
      toSet_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.LinkedHashSet());
      },
      toSortedSet_2hx8bi$: function ($receiver) {
        return _.kotlin.toCollection_xpmo5j$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_l1lu5s$: function ($receiver) {
        return _.kotlin.toCollection_aaeveh$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_964n92$: function ($receiver) {
        return _.kotlin.toCollection_d1lgh$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_355nu0$: function ($receiver) {
        return _.kotlin.toCollection_ba3pld$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_bvy38t$: function ($receiver) {
        return _.kotlin.toCollection_enu0mi$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_rjqrz0$: function ($receiver) {
        return _.kotlin.toCollection_gk003p$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_tmsbgp$: function ($receiver) {
        return _.kotlin.toCollection_mglpxq$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_se6h4y$: function ($receiver) {
        return _.kotlin.toCollection_vus1ud$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_i2lc78$: function ($receiver) {
        return _.kotlin.toCollection_5k8uqj$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_h3panj$: function ($receiver) {
        return _.kotlin.toCollection_4jj70a$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_pdnvbz$: function ($receiver) {
        return _.kotlin.toCollection_791eew$($receiver, new Kotlin.TreeSet());
      },
      toSortedSet_pdl1w0$: function ($receiver) {
        return _.kotlin.toCollection_j1020p$($receiver, new Kotlin.TreeSet());
      },
      appendString_vt6b28$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_vt6b28$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_v2fgr2$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_v2fgr2$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_ds6lso$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_ds6lso$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_2b34ga$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_2b34ga$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_kjxfqn$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_kjxfqn$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_bt92bi$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_bt92bi$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_xc3j4b$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_xc3j4b$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_2bqqsc$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_2bqqsc$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_ex638e$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_ex638e$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_4ybsr7$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_4ybsr7$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      appendString_tsa3bz$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        _.kotlin.joinTo_tsa3bz$($receiver, buffer, separator, prefix, postfix, limit, truncated);
      },
      joinTo_vt6b28$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_v2fgr2$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_ds6lso$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_2b34ga$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_kjxfqn$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_bt92bi$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_xc3j4b$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_2bqqsc$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_ex638e$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_4ybsr7$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinTo_tsa3bz$: function ($receiver, buffer, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        buffer.append(prefix);
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (++count > 1)
              buffer.append(separator);
            if (limit < 0 || count <= limit) {
              var text = element == null ? 'null' : element.toString();
              buffer.append(text);
            }
             else
              break;
          }
        }
        if (limit >= 0 && count > limit)
          buffer.append(truncated);
        buffer.append(postfix);
        return buffer;
      },
      joinToString_7s66u8$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_vt6b28$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_cmivou$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_v2fgr2$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_7gqm6g$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_ds6lso$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_5g9kba$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_2b34ga$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_fwx41b$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_kjxfqn$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_sfhf6m$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_bt92bi$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_6b4cej$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_xc3j4b$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_s6c98k$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_2bqqsc$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_pukide$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_ex638e$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_mc2pv1$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_4ybsr7$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      joinToString_tpghi9$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinTo_tsa3bz$($receiver, new Kotlin.StringBuilder(), separator, prefix, postfix, limit, truncated).toString();
      },
      makeString_7s66u8$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_7s66u8$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_cmivou$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_cmivou$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_7gqm6g$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_7gqm6g$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_5g9kba$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_5g9kba$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_fwx41b$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_fwx41b$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_sfhf6m$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_sfhf6m$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_6b4cej$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_6b4cej$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_s6c98k$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_s6c98k$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_pukide$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_pukide$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_mc2pv1$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_mc2pv1$($receiver, separator, prefix, postfix, limit, truncated);
      },
      makeString_tpghi9$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_tpghi9$($receiver, separator, prefix, postfix, limit, truncated);
      },
      trim_94jgcu$: function ($receiver, text) {
        return _.kotlin.trimTrailing_94jgcu$(_.kotlin.trimLeading_94jgcu$($receiver, text), text);
      },
      trim_ex0kps$: function ($receiver, prefix, postfix) {
        return _.kotlin.trimTrailing_94jgcu$(_.kotlin.trimLeading_94jgcu$($receiver, prefix), postfix);
      },
      trimLeading_94jgcu$: function ($receiver, prefix) {
        var answer = $receiver;
        if (answer.startsWith(prefix)) {
          answer = answer.substring(prefix.length);
        }
        return answer;
      },
      trimTrailing_94jgcu$: function ($receiver, postfix) {
        var answer = $receiver;
        if (answer.endsWith(postfix)) {
          answer = answer.substring(0, $receiver.length - postfix.length);
        }
        return answer;
      },
      isNotEmpty_pdl1w0$: function ($receiver) {
        return $receiver != null && $receiver.length > 0;
      },
      iterator_gw00vq$: function ($receiver) {
        return Kotlin.createObject(function () {
          return [_.kotlin.CharIterator];
        }, function $fun() {
          $fun.baseInitializer.call(this);
          this.index_xuly00$ = 0;
        }, {
          nextChar: function () {
            return $receiver.get_za3lpa$(this.index_xuly00$++);
          },
          hasNext: function () {
            return this.index_xuly00$ < $receiver.length;
          }
        });
      },
      orEmpty_pdl1w0$: function ($receiver) {
        return $receiver != null ? $receiver : '';
      },
      get_size_2: {value: function ($receiver) {
        return $receiver.length;
      }},
      get_size_0: {value: function ($receiver) {
        return $receiver.length;
      }},
      get_indices_1: {value: function ($receiver) {
        return new Kotlin.NumberRange(0, $receiver.length - 1);
      }},
      slice_bchp91$: function ($receiver, indices) {
        var sb = new Kotlin.StringBuilder();
        {
          var tmp$0 = indices.iterator();
          while (tmp$0.hasNext()) {
            var i = tmp$0.next();
            sb.append($receiver.get_za3lpa$(i));
          }
        }
        return sb.toString();
      },
      substring_cumll7$: function ($receiver, range) {
        return $receiver.substring(range.start, range.end + 1);
      },
      join_mc2pv1$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_mc2pv1$($receiver, separator, prefix, postfix, limit, truncated);
      },
      join_7s66u8$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_7s66u8$($receiver, separator, prefix, postfix, limit, truncated);
      },
      join_tpghi9$: function ($receiver, separator, prefix, postfix, limit, truncated) {
        if (separator === void 0)
          separator = ', ';
        if (prefix === void 0)
          prefix = '';
        if (postfix === void 0)
          postfix = '';
        if (limit === void 0)
          limit = -1;
        if (truncated === void 0)
          truncated = '...';
        return _.kotlin.joinToString_tpghi9$($receiver, separator, prefix, postfix, limit, truncated);
      },
      substringBefore_960177$: function ($receiver, delimiter) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringBefore_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringAfter_960177$: function ($receiver, delimiter) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? '' : $receiver.substring(index + 1, $receiver.length);
      },
      substringAfter_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? '' : $receiver.substring(index + delimiter.length, $receiver.length);
      },
      substringBeforeLast_960177$: function ($receiver, delimiter) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringBeforeLast_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? $receiver : $receiver.substring(0, index);
      },
      substringAfterLast_960177$: function ($receiver, delimiter) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? '' : $receiver.substring(index + 1, $receiver.length);
      },
      substringAfterLast_94jgcu$: function ($receiver, delimiter) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? '' : $receiver.substring(index + delimiter.length, $receiver.length);
      },
      replaceRange_d9884y$: function ($receiver, firstIndex, lastIndex, replacement) {
        if (lastIndex < firstIndex)
          throw new RangeError('Last index (' + lastIndex + ') is less than first index (' + firstIndex + ')');
        var sb = new Kotlin.StringBuilder();
        sb.append($receiver, 0, firstIndex);
        sb.append(replacement);
        sb.append($receiver, lastIndex, $receiver.length);
        return sb.toString();
      },
      replaceRange_rxpzkz$: function ($receiver, range, replacement) {
        if (range.end < range.start)
          throw new RangeError('Last index (' + range.start + ') is less than first index (' + range.end + ')');
        var sb = new Kotlin.StringBuilder();
        sb.append($receiver, 0, range.start);
        sb.append(replacement);
        sb.append($receiver, range.end, $receiver.length);
        return sb.toString();
      },
      replaceBefore_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      replaceBefore_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      replaceAfter_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.indexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + 1, $receiver.length, replacement);
      },
      replaceAfter_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.indexOf(delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + delimiter.length, $receiver.length, replacement);
      },
      replaceAfterLast_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + delimiter.length, $receiver.length, replacement);
      },
      replaceAfterLast_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? $receiver : _.kotlin.replaceRange_d9884y$($receiver, index + 1, $receiver.length, replacement);
      },
      replaceBeforeLast_7uhrl1$: function ($receiver, delimiter, replacement) {
        var index = _.js.lastIndexOf_960177$($receiver, delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      replaceBeforeLast_ex0kps$: function ($receiver, delimiter, replacement) {
        var index = $receiver.lastIndexOf(delimiter);
        return index === -1 ? replacement : _.kotlin.replaceRange_d9884y$($receiver, 0, index, replacement);
      },
      StringBuilder_lxq41y$: function (body) {
        var sb = new Kotlin.StringBuilder();
        body.call(sb);
        return sb;
      },
      append_d4iu1a$: function ($receiver, value) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = value, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.append(item);
          }
        }
        return $receiver;
      },
      append_ya45mk$: function ($receiver, value) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = value, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.append(item);
          }
        }
        return $receiver;
      },
      append_ya45mk$_0: function ($receiver, value) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = value, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var item = tmp$0[tmp$2];
            $receiver.append(item);
          }
        }
        return $receiver;
      },
      sum_h3panj$: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_h3panj$_0: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_h3panj$_1: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_h3panj$_2: function ($receiver) {
        var iterator = $receiver.iterator();
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_tmsbgp$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_0: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_se6h4y$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_1: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_964n92$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_2: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_i2lc78$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_3: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_bvy38t$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_2hx8bi$_4: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      sum_rjqrz0$: function ($receiver) {
        var iterator = Kotlin.arrayIterator($receiver);
        var sum = 0.0;
        while (iterator.hasNext()) {
          sum += iterator.next();
        }
        return sum;
      },
      reverse_2hx8bi$: function ($receiver) {
        var list = _.kotlin.toArrayList_2hx8bi$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_l1lu5s$: function ($receiver) {
        var list = _.kotlin.toArrayList_l1lu5s$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_964n92$: function ($receiver) {
        var list = _.kotlin.toArrayList_964n92$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_355nu0$: function ($receiver) {
        var list = _.kotlin.toArrayList_355nu0$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_bvy38t$: function ($receiver) {
        var list = _.kotlin.toArrayList_bvy38t$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_rjqrz0$: function ($receiver) {
        var list = _.kotlin.toArrayList_rjqrz0$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_tmsbgp$: function ($receiver) {
        var list = _.kotlin.toArrayList_tmsbgp$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_se6h4y$: function ($receiver) {
        var list = _.kotlin.toArrayList_se6h4y$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_i2lc78$: function ($receiver) {
        var list = _.kotlin.toArrayList_i2lc78$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_h3panj$: function ($receiver) {
        var list = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.reverse(list);
        return list;
      },
      reverse_pdl1w0$: function ($receiver) {
        return (new Kotlin.StringBuilder()).append($receiver).reverse().toString();
      },
      sort_h3panj$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      sortBy_lykrt4$: function ($receiver, comparator) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        Kotlin.collectionsSort(sortedList, comparator);
        return sortedList;
      },
      sortBy_yknd17$: function ($receiver, comparator) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.collectionsSort(sortedList, comparator);
        return sortedList;
      },
      sortBy_de9h66$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortBy_de9h66$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortBy_de9h66$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortBy_vqr6wr$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortBy_vqr6wr$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortBy_vqr6wr$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortDescending_h3panj$f: function (x, y) {
        return -x.compareTo_za3rmp$(y);
      },
      sortDescending_h3panj$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortDescending_h3panj$f);
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortDescendingBy_de9h66$f: function (order) {
        return function (x, y) {
          return -order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortDescendingBy_de9h66$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortDescendingBy_de9h66$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      sortDescendingBy_vqr6wr$f: function (order) {
        return function (x, y) {
          return -order(x).compareTo_za3rmp$(order(y));
        };
      },
      sortDescendingBy_vqr6wr$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.sortDescendingBy_vqr6wr$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedList_2hx8bi$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_l1lu5s$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_l1lu5s$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_964n92$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_964n92$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_355nu0$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_355nu0$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_bvy38t$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_bvy38t$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_rjqrz0$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_rjqrz0$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_tmsbgp$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_tmsbgp$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_se6h4y$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_se6h4y$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_i2lc78$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_i2lc78$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_h3panj$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedList_pdnvbz$: function ($receiver) {
        var sortedList = _.kotlin.toArrayList_pdnvbz$($receiver);
        Kotlin.collectionsSort(sortedList);
        return sortedList;
      },
      toSortedListBy_de9h66$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_de9h66$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_2hx8bi$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_de9h66$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_50zxbw$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_50zxbw$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_l1lu5s$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_50zxbw$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_x245au$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_x245au$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_964n92$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_x245au$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_h5ed0c$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_h5ed0c$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_355nu0$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_h5ed0c$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_24jijj$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_24jijj$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_bvy38t$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_24jijj$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_im8pe8$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_im8pe8$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_rjqrz0$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_im8pe8$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_1xntkt$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_1xntkt$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_tmsbgp$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_1xntkt$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_3cuuyy$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_3cuuyy$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_se6h4y$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_3cuuyy$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_p67zio$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_p67zio$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_i2lc78$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_p67zio$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_vqr6wr$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_vqr6wr$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_h3panj$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_vqr6wr$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      toSortedListBy_9fpnal$f: function (order) {
        return function (x, y) {
          return order(x).compareTo_za3rmp$(order(y));
        };
      },
      toSortedListBy_9fpnal$: function ($receiver, order) {
        var sortedList = _.kotlin.toArrayList_pdnvbz$($receiver);
        var sortBy = Kotlin.comparator(_.kotlin.toSortedListBy_9fpnal$f(order));
        Kotlin.collectionsSort(sortedList, sortBy);
        return sortedList;
      },
      isEmpty_2hx8bi$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_l1lu5s$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_964n92$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_355nu0$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_bvy38t$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_rjqrz0$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_tmsbgp$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_se6h4y$: function ($receiver) {
        return $receiver.length === 0;
      },
      isEmpty_i2lc78$: function ($receiver) {
        return $receiver.length === 0;
      },
      isNotEmpty_2hx8bi$: function ($receiver) {
        return !_.kotlin.isEmpty_2hx8bi$($receiver);
      },
      isNotEmpty_l1lu5s$: function ($receiver) {
        return !_.kotlin.isEmpty_l1lu5s$($receiver);
      },
      isNotEmpty_964n92$: function ($receiver) {
        return !_.kotlin.isEmpty_964n92$($receiver);
      },
      isNotEmpty_355nu0$: function ($receiver) {
        return !_.kotlin.isEmpty_355nu0$($receiver);
      },
      isNotEmpty_bvy38t$: function ($receiver) {
        return !_.kotlin.isEmpty_bvy38t$($receiver);
      },
      isNotEmpty_rjqrz0$: function ($receiver) {
        return !_.kotlin.isEmpty_rjqrz0$($receiver);
      },
      isNotEmpty_tmsbgp$: function ($receiver) {
        return !_.kotlin.isEmpty_tmsbgp$($receiver);
      },
      isNotEmpty_se6h4y$: function ($receiver) {
        return !_.kotlin.isEmpty_se6h4y$($receiver);
      },
      isNotEmpty_i2lc78$: function ($receiver) {
        return !_.kotlin.isEmpty_i2lc78$($receiver);
      },
      all_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_gld13f$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      all_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (!predicate(element))
              return false;
          }
        }
        return true;
      },
      any_2hx8bi$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return true;
          }
        }
        return false;
      },
      any_l1lu5s$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_964n92$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_355nu0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_bvy38t$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_rjqrz0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_tmsbgp$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return true;
          }
        }
        return false;
      },
      any_se6h4y$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_i2lc78$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_h3panj$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_s8ckw1$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_pdnvbz$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_pdl1w0$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return true;
          }
        }
        return false;
      },
      any_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_gld13f$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      any_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return true;
          }
        }
        return false;
      },
      count_2hx8bi$: function ($receiver) {
        return $receiver.length;
      },
      count_l1lu5s$: function ($receiver) {
        return $receiver.length;
      },
      count_964n92$: function ($receiver) {
        return $receiver.length;
      },
      count_355nu0$: function ($receiver) {
        return $receiver.length;
      },
      count_bvy38t$: function ($receiver) {
        return $receiver.length;
      },
      count_rjqrz0$: function ($receiver) {
        return $receiver.length;
      },
      count_tmsbgp$: function ($receiver) {
        return $receiver.length;
      },
      count_se6h4y$: function ($receiver) {
        return $receiver.length;
      },
      count_i2lc78$: function ($receiver) {
        return $receiver.length;
      },
      count_tkvw3h$: function ($receiver) {
        return _.kotlin.get_size_1($receiver);
      },
      count_h3panj$: function ($receiver) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            count++;
          }
        }
        return count;
      },
      count_s8ckw1$: function ($receiver) {
        return _.kotlin.get_size($receiver);
      },
      count_pdnvbz$: function ($receiver) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            count++;
          }
        }
        return count;
      },
      count_pdl1w0$: function ($receiver) {
        return _.kotlin.get_size_0($receiver);
      },
      count_de9h66$: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_50zxbw$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_x245au$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_h5ed0c$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_24jijj$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_im8pe8$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_1xntkt$: function ($receiver, predicate) {
        var count = 0;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_3cuuyy$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_p67zio$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_vqr6wr$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_gld13f$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_9fpnal$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      count_t73kuc$: function ($receiver, predicate) {
        var count = 0;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              count++;
          }
        }
        return count;
      },
      fold_8stajs$: function ($receiver, initial, operation) {
        var accumulator = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_v8qmra$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_4lvz2o$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_gtjzry$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_pn2g5j$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_tj8q8m$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_s4q4mb$: function ($receiver, initial, operation) {
        var accumulator = initial;
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_g9t0ho$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_8hjqyy$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_gu2wyd$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_9hsf09$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      fold_xn4ira$: function ($receiver, initial, operation) {
        var accumulator = initial;
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            accumulator = operation(accumulator, element);
          }
        }
        return accumulator;
      },
      foldRight_8stajs$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_v8qmra$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_4lvz2o$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_gtjzry$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_pn2g5j$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_tj8q8m$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_s4q4mb$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_g9t0ho$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_8hjqyy$: function ($receiver, initial, operation) {
        var index = $receiver.length - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      foldRight_qwc90p$: function ($receiver, initial, operation) {
        var index = _.kotlin.get_size_1($receiver) - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver.get_za3lpa$(index--), accumulator);
        }
        return accumulator;
      },
      foldRight_xn4ira$: function ($receiver, initial, operation) {
        var index = _.kotlin.get_size_0($receiver) - 1;
        var accumulator = initial;
        while (index >= 0) {
          accumulator = operation($receiver.charAt(index--), accumulator);
        }
        return accumulator;
      },
      forEach_de9h66$: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      forEach_50zxbw$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_x245au$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_h5ed0c$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_24jijj$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_im8pe8$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_1xntkt$: function ($receiver, operation) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            operation(element);
          }
        }
      },
      forEach_3cuuyy$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_p67zio$: function ($receiver, operation) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_vqr6wr$: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_gld13f$: function ($receiver, operation) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_9fpnal$: function ($receiver, operation) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      forEach_t73kuc$: function ($receiver, operation) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            operation(element);
          }
        }
      },
      max_2hx8bi$: function ($receiver) {
        if (_.kotlin.isEmpty_2hx8bi$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_964n92$: function ($receiver) {
        if (_.kotlin.isEmpty_964n92$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_355nu0$: function ($receiver) {
        if (_.kotlin.isEmpty_355nu0$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_bvy38t$: function ($receiver) {
        if (_.kotlin.isEmpty_bvy38t$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_rjqrz0$: function ($receiver) {
        if (_.kotlin.isEmpty_rjqrz0$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_tmsbgp$: function ($receiver) {
        if (_.kotlin.isEmpty_tmsbgp$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_se6h4y$: function ($receiver) {
        if (_.kotlin.isEmpty_se6h4y$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_i2lc78$: function ($receiver) {
        if (_.kotlin.isEmpty_i2lc78$($receiver))
          return null;
        var max = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (max < e)
              max = e;
          }
        }
        return max;
      },
      max_h3panj$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var max = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (max < e)
            max = e;
        }
        return max;
      },
      max_pdnvbz$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var max = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (max < e)
            max = e;
        }
        return max;
      },
      max_pdl1w0$: function ($receiver) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var max = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (max < e)
            max = e;
        }
        return max;
      },
      maxBy_de9h66$: function ($receiver, f) {
        if (_.kotlin.isEmpty_2hx8bi$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_50zxbw$: function ($receiver, f) {
        if (_.kotlin.isEmpty_l1lu5s$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_x245au$: function ($receiver, f) {
        if (_.kotlin.isEmpty_964n92$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_h5ed0c$: function ($receiver, f) {
        if (_.kotlin.isEmpty_355nu0$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_24jijj$: function ($receiver, f) {
        if (_.kotlin.isEmpty_bvy38t$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_im8pe8$: function ($receiver, f) {
        if (_.kotlin.isEmpty_rjqrz0$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_1xntkt$: function ($receiver, f) {
        if (_.kotlin.isEmpty_tmsbgp$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_3cuuyy$: function ($receiver, f) {
        if (_.kotlin.isEmpty_se6h4y$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_p67zio$: function ($receiver, f) {
        if (_.kotlin.isEmpty_i2lc78$($receiver))
          return null;
        var maxElem = $receiver[0];
        var maxValue = f(maxElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (maxValue < v) {
              maxElem = e;
              maxValue = v;
            }
          }
        }
        return maxElem;
      },
      maxBy_vqr6wr$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      maxBy_9fpnal$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      maxBy_t73kuc$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      maxBy_gld13f$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_s8ckw1$($receiver);
        if (!iterator.hasNext())
          return null;
        var maxElem = iterator.next();
        var maxValue = f(maxElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (maxValue < v) {
            maxElem = e;
            maxValue = v;
          }
        }
        return maxElem;
      },
      min_2hx8bi$: function ($receiver) {
        if (_.kotlin.isEmpty_2hx8bi$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_964n92$: function ($receiver) {
        if (_.kotlin.isEmpty_964n92$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_355nu0$: function ($receiver) {
        if (_.kotlin.isEmpty_355nu0$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_bvy38t$: function ($receiver) {
        if (_.kotlin.isEmpty_bvy38t$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_rjqrz0$: function ($receiver) {
        if (_.kotlin.isEmpty_rjqrz0$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_tmsbgp$: function ($receiver) {
        if (_.kotlin.isEmpty_tmsbgp$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_se6h4y$: function ($receiver) {
        if (_.kotlin.isEmpty_se6h4y$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_i2lc78$: function ($receiver) {
        if (_.kotlin.isEmpty_i2lc78$($receiver))
          return null;
        var min = $receiver[0];
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            if (min > e)
              min = e;
          }
        }
        return min;
      },
      min_h3panj$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var min = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (min > e)
            min = e;
        }
        return min;
      },
      min_pdnvbz$: function ($receiver) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var min = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (min > e)
            min = e;
        }
        return min;
      },
      min_pdl1w0$: function ($receiver) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var min = iterator.next();
        while (iterator.hasNext()) {
          var e = iterator.next();
          if (min > e)
            min = e;
        }
        return min;
      },
      minBy_de9h66$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_7($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_50zxbw$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_x245au$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_0($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_h5ed0c$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_6($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_24jijj$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_5($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_im8pe8$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_4($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_1xntkt$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_2($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_3cuuyy$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_3($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_p67zio$: function ($receiver, f) {
        if ($receiver.length === 0)
          return null;
        var minElem = $receiver[0];
        var minValue = f(minElem);
        var tmp$0;
        {
          tmp$0 = _.kotlin.get_lastIndex_1($receiver) + 1;
          for (var i = 1; i !== tmp$0; i++) {
            var e = $receiver[i];
            var v = f(e);
            if (minValue > v) {
              minElem = e;
              minValue = v;
            }
          }
        }
        return minElem;
      },
      minBy_vqr6wr$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      minBy_9fpnal$: function ($receiver, f) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      minBy_t73kuc$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      minBy_gld13f$: function ($receiver, f) {
        var iterator = _.kotlin.iterator_s8ckw1$($receiver);
        if (!iterator.hasNext())
          return null;
        var minElem = iterator.next();
        var minValue = f(minElem);
        while (iterator.hasNext()) {
          var e = iterator.next();
          var v = f(e);
          if (minValue > v) {
            minElem = e;
            minValue = v;
          }
        }
        return minElem;
      },
      none_2hx8bi$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return false;
          }
        }
        return true;
      },
      none_l1lu5s$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_964n92$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_355nu0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_bvy38t$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_rjqrz0$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_tmsbgp$: function ($receiver) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            return false;
          }
        }
        return true;
      },
      none_se6h4y$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_i2lc78$: function ($receiver) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_h3panj$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_s8ckw1$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_pdnvbz$: function ($receiver) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_pdl1w0$: function ($receiver) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            return false;
          }
        }
        return true;
      },
      none_de9h66$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_50zxbw$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_x245au$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_h5ed0c$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_24jijj$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_im8pe8$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_1xntkt$: function ($receiver, predicate) {
        var tmp$0, tmp$1, tmp$2;
        {
          tmp$0 = $receiver, tmp$1 = tmp$0.length;
          for (var tmp$2 = 0; tmp$2 !== tmp$1; ++tmp$2) {
            var element = tmp$0[tmp$2];
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_3cuuyy$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_p67zio$: function ($receiver, predicate) {
        {
          var tmp$0 = Kotlin.arrayIterator($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_vqr6wr$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_gld13f$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_s8ckw1$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_9fpnal$: function ($receiver, predicate) {
        {
          var tmp$0 = $receiver.iterator();
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      none_t73kuc$: function ($receiver, predicate) {
        {
          var tmp$0 = _.kotlin.iterator_gw00vq$($receiver);
          while (tmp$0.hasNext()) {
            var element = tmp$0.next();
            if (predicate(element))
              return false;
          }
        }
        return true;
      },
      reduce_de9h67$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_50zxbx$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_x245av$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_h5ed0b$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_24jijk$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_im8pe7$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_1xntks$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_3cuuyz$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_p67zip$: function ($receiver, operation) {
        var iterator = Kotlin.arrayIterator($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_vqr6ws$: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_9fpnam$: function ($receiver, operation) {
        var iterator = $receiver.iterator();
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduce_t73kub$: function ($receiver, operation) {
        var iterator = _.kotlin.iterator_gw00vq$($receiver);
        if (!iterator.hasNext())
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = iterator.next();
        while (iterator.hasNext()) {
          accumulator = operation(accumulator, iterator.next());
        }
        return accumulator;
      },
      reduceRight_de9h67$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_50zxbx$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_x245av$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_h5ed0b$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_24jijk$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_im8pe7$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_1xntks$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_3cuuyz$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_p67zip$: function ($receiver, operation) {
        var index = $receiver.length - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver[index--];
        while (index >= 0) {
          accumulator = operation($receiver[index--], accumulator);
        }
        return accumulator;
      },
      reduceRight_7bxqi8$: function ($receiver, operation) {
        var index = _.kotlin.get_size_1($receiver) - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver.get_za3lpa$(index--);
        while (index >= 0) {
          accumulator = operation($receiver.get_za3lpa$(index--), accumulator);
        }
        return accumulator;
      },
      reduceRight_t73kub$: function ($receiver, operation) {
        var index = _.kotlin.get_size_0($receiver) - 1;
        if (index < 0)
          throw new Kotlin.UnsupportedOperationException("Empty iterable can't be reduced");
        var accumulator = $receiver.charAt(index--);
        while (index >= 0) {
          accumulator = operation($receiver.charAt(index--), accumulator);
        }
        return accumulator;
      },
      support: Kotlin.definePackage(function () {
        this.State = Kotlin.createObject(null, function () {
          this.Ready = 0;
          this.NotReady = 1;
          this.Done = 2;
          this.Failed = 3;
        });
      }, /** @lends _.kotlin.support */ {
        AbstractIterator: Kotlin.createClass(function () {
          return [Kotlin.Iterator];
        }, function () {
          this.state_xrvatb$ = _.kotlin.support.State.NotReady;
          this.nextValue_u0jzfw$ = null;
        }, /** @lends _.kotlin.support.AbstractIterator.prototype */ {
          hasNext: function () {
            _.kotlin.require_eltq40$(this.state_xrvatb$ !== _.kotlin.support.State.Failed);
            var tmp$0 = this.state_xrvatb$, tmp$1;
            if (tmp$0 === _.kotlin.support.State.Done)
              tmp$1 = false;
            else if (tmp$0 === _.kotlin.support.State.Ready)
              tmp$1 = true;
            else
              tmp$1 = this.tryToComputeNext();
            return tmp$1;
          },
          next: function () {
            if (!this.hasNext())
              throw new Kotlin.NoSuchElementException();
            this.state_xrvatb$ = _.kotlin.support.State.NotReady;
            return this.nextValue_u0jzfw$;
          },
          peek: function () {
            if (!this.hasNext())
              throw new Kotlin.NoSuchElementException();
            return this.nextValue_u0jzfw$;
          },
          tryToComputeNext: function () {
            this.state_xrvatb$ = _.kotlin.support.State.Failed;
            this.computeNext();
            return this.state_xrvatb$ === _.kotlin.support.State.Ready;
          },
          setNext_za3rmp$: function (value) {
            this.nextValue_u0jzfw$ = value;
            this.state_xrvatb$ = _.kotlin.support.State.Ready;
          },
          done: function () {
            this.state_xrvatb$ = _.kotlin.support.State.Done;
          }
        })
      })
    })
  });
  Kotlin.defineModule('kevoree', _);
}

module.exports = Kotlin.modules['kevoree'].org.kevoree;
module.exports.org = {
  kevoree: Kotlin.modules['kevoree'].org.kevoree
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"kevoree-kotlin":122}],125:[function(require,module,exports){
/*
	PseudoClass - JavaScript inheritance

	Construction:
		Setup and construction should happen in the construct() method.
		The construct() method is automatically chained, so all construct() methods defined by superclass methods will be called first.

	Initialization:
		Initialziation that needs to happen after all construct() methods have been called should be done in the init() method.
		The init() method is not automatically chained, so you must call this._super() if you intend to call the superclass' init method.
		init() is not passed any arguments

	Destruction:
		Teardown and destruction should happen in the destruct() method. The destruct() method is also chained.

	Mixins:
		An array of mixins can be provided with the mixins[] property. An object or the prototype of a class should be provided, not a constructor.
		Mixins can be added at any time by calling this.mixin(properties)

	Usage:
		var MyClass = Class(properties);
		var MyClass = new Class(properties);
		var MyClass = Class.extend(properties);

	Credits:
		Inspired by Simple JavaScript Inheritance by John Resig http://ejohn.org/

	Usage differences:
		construct() is used to setup instances and is chained so superclass construct() methods run automatically
		destruct() is used to tear down instances. destruct() is also chained
		init(), if defined, is called after construction is complete and is not chained
		toString() can be defined as a string or a function
		mixin() is provided to mix properties into an instance
		properties.mixins as an array results in each of the provided objects being mixed in (last object wins)
		this._super() is supported in mixins
		properties, if defined, should be a hash of property descriptors as accepted by Object.defineProperties
*/
(function(global) {
	// Extend the current context by the passed objects
	function extendThis() {
		var i, ni, objects, object, prop;
		objects = arguments;
		for (i = 0, ni = objects.length; i < ni; i++) {
			object = objects[i];
			for (prop in object) {
				this[prop] = object[prop];
			}
		}

		return this;
	}

	// Return a function that calls the specified method, passing arguments
	function makeApplier(method) {
		return function() {
			return this[method].apply(this, arguments);
		};
	}

	// Merge and define properties
	function defineAndInheritProperties(Component, properties) {
		var constructor,
			descriptor,
			property,
			propertyDescriptors,
			propertyDescriptorHash,
			propertyDescriptorQueue;

		// Set properties
		Component.properties = properties;

		// Traverse the chain of constructors and gather all property descriptors
		// Build a queue of property descriptors for combination
		propertyDescriptorHash = {};
		constructor = Component;
		do {
			if (constructor.properties) {
				for (property in constructor.properties) {
					propertyDescriptorQueue = propertyDescriptorHash[property] || (propertyDescriptorHash[property] = []);
					propertyDescriptorQueue.unshift(constructor.properties[property]);
				}
			}
			constructor = constructor.superConstructor;
		}
		while (constructor);

		// Combine property descriptors, allowing overriding of individual properties
		propertyDescriptors = {};
		for (property in propertyDescriptorHash) {
			descriptor = propertyDescriptors[property] = extendThis.apply({}, propertyDescriptorHash[property]);

			// Allow setters to be strings
			// An additional wrapping function is used to allow monkey-patching
			// apply is used to handle cases where the setter is called directly
			if (typeof descriptor.set === 'string') {
				descriptor.set = makeApplier(descriptor.set);
			}
			if (typeof descriptor.get === 'string') {
				descriptor.get = makeApplier(descriptor.get);
			}
		}

		// Store option descriptors on the constructor
		Component.properties = propertyDescriptors;
	}

	// Used for default initialization methods
	var noop = function() {};

	// Given a function, the superTest RE will match if _super is used in the function
	// The function will be serialized, then the serialized string will be searched for _super
	// If the environment isn't capable of function serialization, make it so superTest.test always returns true
	var superTest = /xyz/.test(function(){return 'xyz';}) ? /\._super\b/ : { test: function() { return true; } };

	// Bind an overriding method such that it gets the overridden method as its first argument
	var superifyDynamic = function(name, func, superPrototype) {
		return function PseudoClass_setStaticSuper() {
			// Store the old super
			var previousSuper = this._super;

			// Use the method from the superclass' prototype
			// This strategy allows monkey patching (modification of superclass prototypes)
			this._super = superPrototype[name];

			// Call the actual function
			var ret = func.apply(this, arguments);

			// Restore the previous value of super
			// This is required so that calls to methods that use _super within methods that use _super work
			this._super = previousSuper;

			return ret;
		};
	};

	var superifyStatic = function(name, func, object) {
		// Store a reference to the overridden function
		var _super = object[name];

		return function PseudoClass_setDynamicSuper() {
			// Use the method stored at declaration time
			this._super = _super;

			// Call the actual function
			return func.apply(this, arguments);
		};
	};

	// Mix the provided properties into the current context with the ability to call overridden methods with _super()
	var mixin = function(properties, superPrototype) {
		// Use this instance's prototype if no prototype provided
		superPrototype = superPrototype || this.constructor && this.constructor.prototype;
		
		// Copy the properties onto the new prototype
		for (var name in properties) {
			var value = properties[name];

			// Never mix construct or destruct
			if (name === 'construct' || name === 'destruct')
				continue;

			// Check if the property if a method that makes use of _super:
			// 1. The value should be a function
			// 2. The super prototype should have a function by the same name
			// 3. The function should use this._super somewhere
			var usesSuper = superPrototype && typeof value === 'function' && typeof superPrototype[name] === 'function' && superTest.test(value);

			if (usesSuper) {
				// Wrap the function such that this._super will be available
				if (this.hasOwnProperty(name)) {
					// Properties that exist directly on the object should be superified statically
					this[name] = superifyStatic(name, value, this);
				}
				else {
					// Properties that are part of the superPrototype should be superified dynamically
					this[name] = superifyDynamic(name, value, superPrototype);
				}
			}
			else {
				// Directly assign the property
				this[name] = value;
			}
		}
	};

	// The base Class implementation acts as extend alias, with the exception that it can take properties.extend as the Class to extend
	var PseudoClass = function(properties) {
		// If a class-like object is passed as properties.extend, just call extend on it
		if (properties && properties.extend)
			return properties.extend.extend(properties);

		// Otherwise, just create a new class with the passed properties
		return PseudoClass.extend(properties);
	};
	
	// Add the mixin method to all classes created with PseudoClass
	PseudoClass.prototype.mixin = mixin;
	
	// Creates a new PseudoClass that inherits from this class
	// Give the function a name so it can refer to itself without arguments.callee
	PseudoClass.extend = function extend(properties) {
		// The constructor handles creating an instance of the class, applying mixins, and calling construct() and init() methods
		function PseudoClass() {
			// Optimization: Requiring the new keyword and avoiding usage of Object.create() increases performance by 5x
			if (this instanceof PseudoClass === false) {
				throw new Error('Cannot create instance without new operator');
			}

			// Set properties
			var propertyDescriptors = PseudoClass.properties;
			if (propertyDescriptors) {
				Object.defineProperties(this, propertyDescriptors);
			}

			// Optimization: Avoiding conditionals in constructor increases performance of instantiation by 2x
			this.construct.apply(this, arguments);

			this.init();
		}

		var superConstructor = this;
		var superPrototype = this.prototype;

		// Store the superConstructor
		// It will be accessible on an instance as follows:
		//	instance.constructor.superConstructor
		PseudoClass.superConstructor = superConstructor;

		// Add extend() as a static method on the constructor
		PseudoClass.extend = extend;

		// Create an object with the prototype of the superclass
		// Store the extended class' prototype as the prototype of the constructor
		var prototype = PseudoClass.prototype = Object.create(superPrototype);

		// Assign prototype.constructor to the constructor itself
		// This allows instances to refer to this.constructor.prototype
		// This also allows creation of new instances using instance.constructor()
		prototype.constructor = PseudoClass;

		// Store the superPrototype
		// It will be accessible on an instance as follows:
		//	instance.superPrototype
		//	instance.constructor.prototype.superPrototype
		prototype.superPrototype = superPrototype;

		if (properties) {
			// Set property descriptors aside
			// We'll first inherit methods, then we'll apply these
			var propertyDescriptors = properties.properties;
			delete properties.properties;

			// Mix the new properties into the class prototype
			// This does not copy construct and destruct
			mixin.call(prototype, properties, superPrototype);

			// Mix in all the mixins
			// This also does not copy construct and destruct
			if (Array.isArray(properties.mixins)) {
				for (var i = 0, ni = properties.mixins.length; i < ni; i++) {
					// Mixins should be _super enabled, with the methods defined in the prototype as the superclass methods
					mixin.call(prototype, properties.mixins[i], prototype);
				}
			}

			// Define properties from this class and its parent classes
			defineAndInheritProperties(PseudoClass, propertyDescriptors);

			// Chain the construct() method (supermost executes first) if necessary
			if (properties.construct) {
				var construct = properties.construct;
				if (superPrototype.construct) {
					prototype.construct = function() {
						superPrototype.construct.apply(this, arguments);
						construct.apply(this, arguments);
					};
				}
				else {
					prototype.construct = construct;
				}
			}
			
			// Chain the destruct() method in reverse order (supermost executes last) if necessary
			if (properties.destruct) {
				var destruct = properties.destruct;
				if (superPrototype.destruct) {
					prototype.destruct = function() {
						destruct.apply(this, arguments);
						superPrototype.destruct.apply(this, arguments);
					};
				}
				else {
					prototype.destruct = destruct;
				}
			}

			// Allow definition of toString as a string (turn it into a function)
			if (typeof properties.toString === 'string') {
				var className = properties.toString;
				prototype.toString = function() { return className; };
			}
		}

		// Define construct and init as noops if undefined
		// This serves to avoid conditionals inside of the constructor
		if (typeof prototype.construct !== 'function')
			prototype.construct = noop;
		if (typeof prototype.init !== 'function')
			prototype.init = noop;

		return PseudoClass;
	};
	
	if (typeof module !== 'undefined' && module.exports) {
		// Node.js Support
		module.exports = PseudoClass;
	}
	else if (typeof global.define === 'function') {
		(function(define) {
			// AMD Support
			define(function() { return PseudoClass; });
		}(global.define));
	}
	else {
		// Browser support
		global.PseudoClass = PseudoClass;

		// Don't blow away existing Class variable
		if (!global.Class) {
			global.Class = PseudoClass;
		}
	}
}(this));

},{}],126:[function(require,module,exports){
/**
 *
 * @param [name] string used to log method name that causes the timeout
 * @param [timeout] number that defines the timeout (in milliseconds)
 * @param callback function called when done (if first parameter is an error, then something went wrong)
 */
function timesUp(name, timeout, callback) {
    if (typeof callback === 'undefined' && typeof timeout === 'undefined') {
        callback = name;
        name = null;
        timeout = 10000;
    } else if (typeof callback === 'undefined') {
        switch (typeof name) {
            case 'string':
                callback = timeout;
                timeout = 10000;
                break;
            default:
            case 'number':
                callback = timeout;
                timeout = name;
                name = null;
                break;
        }
    }

    var timedOut = false;

    var id = setTimeout(function () {
        // out of time
        timedOut = true;
        callback(new Error(name ? 'Method '+name+' timed out ('+timeout+'ms)' : 'Method timed out ('+timeout+'ms)'));
    }, timeout);

    return function () {
        if (!timedOut) {
            clearTimeout(id);
            callback.apply(callback, arguments);
        }
    };
}

module.exports = timesUp;
},{}],"kevoree-node-javascript":[function(require,module,exports){
var AbstractNode     = require('kevoree-entities').AbstractNode,
    KevoreeLogger    = require('kevoree-commons').KevoreeLogger,
    AdaptationEngine = require('./AdaptationEngine'),
    kevoree          = require('kevoree-library').org.kevoree;

var JavascriptNode = AbstractNode.extend({
    toString: 'JavascriptNode',

    dic_logLevel:   { defaultValue: 'INFO', optional: false },

    construct: function () {
        this.adaptationEngine = new AdaptationEngine(this);
    },

    start: function (done) {
        this.dictionary.on('logLevel', this.updateLogLevel);
        this.updateLogLevel();
        done();
    },

    /**
     * Called when the host node has to start an hosted subNode
     * @param node the hosted subNode
     * @param done
     */
    startSubNode: function (node, done) {
        this.log.warn(this.toString(), 'startSubNode(): not implemented yet');
        done();
    },

    /**
     * Called when the host node has to stop an hosted subNode
     * @param node the hosted subNode
     * @param done
     */
    stopSubNode: function (node, done) {
        this.log.warn(this.toString(), 'stopSubNode(): not implemented yet');
        done();
    },

    /**
     * Called when the host node has to destroy an hosted subNode instance
     * @param node the hosted subNode
     * @param done
     */
    destroySubNode: function (node, done) {
        this.log.warn(this.toString(), 'destroySubNode(): not implemented yet');
        done();
    },

    /**
     * Called when the host node has to remove an hosted subNode instance
     * @param node the hosted subNode
     * @param done
     */
    removeSubNode: function (node, done) {
        this.log.warn(this.toString(), 'removeSubNode(): not implemented yet');
        done();
    },

    /**
     * Process traces in order to do the adaptation logic on the current node
     * @param diffSeq diff traces generated by comparing current KevoreeCore model and given model
     * @param targetModel toDeploy model used by KevoreeCore to generate the trace
     * @returns {Array}
     */
    processTraces: function (diffSeq, targetModel) {
        return this.adaptationEngine.processTraces(diffSeq, targetModel);
    },

    updateLogLevel: function () {
        var logLevel = this.dictionary.getString('logLevel', this.dic_logLevel.defaultValue);
        switch (logLevel.toLowerCase().trim()) {
            case 'all':
                this.log.setLevel(KevoreeLogger.ALL);
                break;

            case 'debug':
                this.log.setLevel(KevoreeLogger.DEBUG);
                break;

            default:
            case 'info':
                this.log.setLevel(KevoreeLogger.INFO);
                break;

            case 'error':
                this.log.setLevel(KevoreeLogger.ERROR);
                break;

            case 'warn':
                this.log.setLevel(KevoreeLogger.WARN);
                break;
        }
    }
});

module.exports = JavascriptNode;
},{"./AdaptationEngine":1,"kevoree-commons":49,"kevoree-entities":58,"kevoree-library":124}]},{},[]);
